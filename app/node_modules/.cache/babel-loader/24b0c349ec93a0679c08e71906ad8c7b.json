{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst extensions_1 = __importDefault(require(\"../constants/extensions\"));\n\nconst scoringItemType_1 = require(\"../constants/scoringItemType\");\n\nconst extension_1 = require(\"./extension\");\n\nconst fhirpathLoaderHelper_1 = __importDefault(require(\"./fhirpathLoaderHelper\"));\n\nconst scoring_1 = require(\"./scoring\");\n\nconst skjemautfyller_core_1 = require(\"./skjemautfyller-core\");\n\nconst fhirpath = require('fhirpath');\n\nclass CalculatedScores {\n  constructor() {\n    this.totalScores = [];\n    this.sectionScores = [];\n    this.questionScores = [];\n  }\n\n  update(subRetVal) {\n    this.totalScores.push(...subRetVal.totalScores);\n    this.sectionScores.push(...subRetVal.sectionScores);\n    this.questionScores.push(...subRetVal.questionScores);\n  }\n\n  hasTotalScores() {\n    return this.totalScores.length > 0;\n  }\n\n  hasSectionScores() {\n    return this.sectionScores.length > 0;\n  }\n\n  hasQuestionScores() {\n    return this.questionScores.length > 0;\n  }\n\n}\n\nclass ScoringCalculator {\n  constructor(questionnaire) {\n    this.sectionScoreCache = {};\n    this.totalScoreCache = [];\n    this.itemCache = {};\n    this.updateQuestionnaire(questionnaire);\n  }\n\n  updateQuestionnaire(questionnaire) {\n    this.sectionScoreCache = {};\n    this.totalScoreCache = [];\n    this.itemCache = {};\n    this.totalScoreItem = undefined;\n    this.traverseQuestionnaire(questionnaire);\n  }\n\n  traverseQuestionnaire(qItem) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const retVal = new CalculatedScores();\n\n    if (qItem.item) {\n      for (const subItem of qItem.item) {\n        const subRetVal = this.traverseQuestionnaire(subItem, level + 1);\n        retVal.update(subRetVal);\n      }\n    }\n\n    if (level === 0) {\n      this.totalScoreItem = scoring_1.createDummySectionScoreItem();\n      const subRetVal = this.traverseQuestionnaire(this.totalScoreItem, level + 1);\n      retVal.update(subRetVal);\n    }\n\n    if (retVal.hasTotalScores()) {\n      for (const totalScore of retVal.totalScores) {\n        this.totalScoreCache.push(totalScore.linkId);\n        this.itemCache[totalScore.linkId] = totalScore;\n      }\n    }\n\n    if (retVal.hasSectionScores()) {\n      const firstSectionScore = retVal.sectionScores.shift();\n      this.sectionScoreCache[firstSectionScore.linkId] = retVal.questionScores;\n      this.itemCache[firstSectionScore.linkId] = firstSectionScore;\n\n      for (const sectionScore of retVal.sectionScores) {\n        this.sectionScoreCache[sectionScore.linkId] = [firstSectionScore];\n        this.itemCache[sectionScore.linkId] = sectionScore;\n      }\n\n      const newRetVal = new CalculatedScores();\n      newRetVal.questionScores.push(firstSectionScore);\n      return newRetVal;\n    }\n\n    if (this.isOfTypeQuestionnaireItem(qItem)) {\n      const type = scoring_1.scoringItemType(qItem);\n\n      if (type === scoringItemType_1.ScoringItemType.SECTION_SCORE) {\n        const newRetVal = new CalculatedScores();\n        newRetVal.sectionScores.push(qItem);\n        return newRetVal;\n      }\n\n      if (type === scoringItemType_1.ScoringItemType.TOTAL_SCORE) {\n        const newRetVal = new CalculatedScores();\n        newRetVal.totalScores.push(qItem);\n        return newRetVal;\n      }\n\n      if (type === scoringItemType_1.ScoringItemType.QUESTION_SCORE || type === scoringItemType_1.ScoringItemType.QUESTION_FHIRPATH_SCORE) {\n        const newRetVal = new CalculatedScores();\n        newRetVal.questionScores.push(qItem, ...retVal.questionScores);\n\n        if (type === scoringItemType_1.ScoringItemType.QUESTION_FHIRPATH_SCORE) {\n          this.itemCache[qItem.linkId] = qItem;\n        }\n\n        return newRetVal;\n      }\n    }\n\n    const newRetVal = new CalculatedScores();\n    newRetVal.questionScores.push(...retVal.questionScores);\n    return newRetVal;\n  }\n\n  isOfTypeQuestionnaireItem(item) {\n    return item.type !== undefined;\n  }\n\n  calculate(questionnaireResponse) {\n    const answerPad = {};\n\n    for (const sectionScoreLinkId in this.sectionScoreCache) {\n      answerPad[sectionScoreLinkId] = this.calculateSectionScore(sectionScoreLinkId, questionnaireResponse, answerPad);\n    }\n\n    for (const totalScoreLinkId of this.totalScoreCache) {\n      answerPad[totalScoreLinkId] = this.calculateSectionScore(this.totalScoreItem.linkId, questionnaireResponse, answerPad);\n    }\n\n    delete answerPad[this.totalScoreItem.linkId];\n    return answerPad;\n  }\n\n  calculateSectionScore(linkId, questionnaireResponse, answerPad) {\n    let sum = 0;\n    let hasCalculatedAtLeastOneAnswer = false;\n    const dependencies = this.sectionScoreCache[linkId];\n\n    for (const item of dependencies) {\n      const result = this.valueOf(item, questionnaireResponse, answerPad);\n\n      if (result !== undefined) {\n        sum += result;\n        hasCalculatedAtLeastOneAnswer = true;\n      }\n    }\n\n    return hasCalculatedAtLeastOneAnswer ? sum : undefined;\n  }\n\n  valueOf(item, questionnaireResponse, answerPad) {\n    const scoringType = scoring_1.scoringItemType(item);\n\n    switch (scoringType) {\n      case scoringItemType_1.ScoringItemType.SECTION_SCORE:\n        return this.valueOfSectionScoreItem(item, questionnaireResponse, answerPad);\n\n      case scoringItemType_1.ScoringItemType.QUESTION_SCORE:\n        return this.valueOfQuestionScoreItem(item, questionnaireResponse);\n\n      case scoringItemType_1.ScoringItemType.QUESTION_FHIRPATH_SCORE:\n        return this.valueOfQuestionFhirpathScoreItem(item, questionnaireResponse, answerPad);\n\n      default:\n        return;\n    }\n  }\n\n  valueOfQuestionFhirpathScoreItem(item, questionnaireResponse, answerPad) {\n    var _a;\n\n    const expressionExtension = extension_1.getCalculatedExpressionExtension(item);\n    let value = undefined;\n\n    if (expressionExtension) {\n      const result = fhirpath.evaluate(questionnaireResponse, expressionExtension.valueString, null, fhirpathLoaderHelper_1.default);\n\n      if (result.length) {\n        value = (_a = result[0]) !== null && _a !== void 0 ? _a : 0;\n\n        if (isNaN(value) || !isFinite(value)) {\n          value = undefined;\n        }\n      }\n    }\n\n    answerPad[item.linkId] = value;\n    return value;\n  }\n\n  valueOfQuestionScoreItem(item, questionnaireResponse) {\n    let sum = 0;\n    let hasCalculatedAtLeastOneAnswer = false;\n    const qrItems = skjemautfyller_core_1.getQuestionnaireResponseItemsWithLinkId(item.linkId, questionnaireResponse.item || [], true);\n\n    for (const qrItem of qrItems) {\n      if (!qrItem.answer) continue;\n\n      for (const answer of qrItem.answer) {\n        const option = this.getAnswerMatch(answer, item);\n\n        if (option) {\n          sum += this.getOptionScore(option);\n          hasCalculatedAtLeastOneAnswer = true;\n        }\n      }\n    }\n\n    return hasCalculatedAtLeastOneAnswer ? sum : undefined;\n  }\n\n  valueOfSectionScoreItem(item, questionnaireResponse, answerPad) {\n    if (item.linkId in answerPad) {\n      return answerPad[item.linkId];\n    }\n\n    return this.calculateSectionScore(item.linkId, questionnaireResponse, answerPad);\n  }\n\n  getOptionScore(option) {\n    const extension = extension_1.getExtension(extensions_1.default.ORDINAL_VALUE, option.valueCoding);\n\n    if (extension === null || extension === void 0 ? void 0 : extension.valueDecimal) {\n      return extension === null || extension === void 0 ? void 0 : extension.valueDecimal;\n    }\n\n    return 0;\n  }\n\n  getAnswerMatch(answer, item) {\n    if (answer.valueCoding) {\n      if (item.answerOption) {\n        for (const o of item.answerOption) {\n          if (o.valueCoding.code === answer.valueCoding.code && o.valueCoding.system === answer.valueCoding.system) {\n            return o;\n          }\n        }\n      }\n    }\n\n    return;\n  }\n\n  getCachedTotalOrSectionItem(linkId) {\n    return this.itemCache[linkId];\n  }\n\n}\n\nexports.ScoringCalculator = ScoringCalculator;","map":null,"metadata":{},"sourceType":"script"}