{"ast":null,"code":"import moment from 'moment';\nimport { ERROR_INVALID_TIME, ERROR_REQUIRED_DATE, ERROR_REQUIRED_TIME, ERROR_TIME_BEFORE_MIN, ERROR_TIME_AFTER_MAX } from '../../../constants/datetime';\nimport { isAfterMaxDate, isBeforeMinDate } from '@helsenorge/core-utils/moment-utils';\nexport const getFullMomentDate = (date, timeString) => {\n  if (!date) return;\n  const time = timeString ? moment(timeString, 'HH:mm') : undefined;\n  const hour = time ? time.hours() : 0;\n  const minute = time ? time.minutes() : 0;\n  const newDate = moment(date).set({\n    hour,\n    minute,\n    second: 0\n  }).toDate();\n  return moment(newDate);\n};\nexport const isFullDateTimeValid = (date, timeString, isRequired, minimumDateTime, maximumDateTime, isOtherFieldChecked) => {\n  let isValid = isOtherFieldChecked;\n  const currentDate = getFullMomentDate(date, timeString);\n\n  if (isRequired) {\n    isValid = !!date && date.isValid() && !!timeString && moment(timeString, 'HH:mm').isValid();\n  }\n\n  if (isValid && currentDate) {\n    if (isAfterMaxDate(currentDate, maximumDateTime)) isValid = false;\n    if (isBeforeMinDate(currentDate, minimumDateTime)) isValid = false;\n  }\n\n  return isValid;\n};\nexport const getErrorString = params => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  let errorString;\n  const {\n    date,\n    timeString,\n    valid,\n    resources,\n    minimumDateTime,\n    maximumDateTime,\n    isRequired,\n    isDateRequired,\n    isTimeRequired,\n    errorMessage,\n    dateFieldInstance,\n    timeFieldInstance\n  } = params;\n\n  if (valid) {\n    errorString = undefined;\n  } else {\n    const currentDate = getFullMomentDate(date, timeString);\n\n    if (errorMessage && date && timeString) {\n      errorString = typeof errorMessage === 'string' ? errorMessage : errorMessage(date, timeString);\n    } else if (dateFieldInstance && !dateFieldInstance.isValid()) {\n      errorString = dateFieldInstance.getErrorString();\n    } else if (timeFieldInstance && !timeFieldInstance.isValid()) {\n      errorString = timeFieldInstance.getErrorString();\n    } else {\n      if (currentDate && isBeforeMinDate(currentDate, minimumDateTime)) {\n        errorString = `${((_b = (_a = resources === null || resources === void 0 ? void 0 : resources.timeResources) === null || _a === void 0 ? void 0 : _a.errorResources) === null || _b === void 0 ? void 0 : _b.errorTimeBeforeMin) || ERROR_TIME_BEFORE_MIN}: ${minimumDateTime === null || minimumDateTime === void 0 ? void 0 : minimumDateTime.format('DD.MM.YYYY HH:mm')}`;\n      } else if (currentDate && isAfterMaxDate(currentDate, maximumDateTime)) {\n        errorString = `${((_d = (_c = resources === null || resources === void 0 ? void 0 : resources.timeResources) === null || _c === void 0 ? void 0 : _c.errorResources) === null || _d === void 0 ? void 0 : _d.errorTimeAfterMax) || ERROR_TIME_AFTER_MAX}: ${maximumDateTime === null || maximumDateTime === void 0 ? void 0 : maximumDateTime.format('DD.MM.YYYY HH:mm')}`;\n      } else if (errorString === undefined && !currentDate && (isRequired || isDateRequired)) {\n        errorString = ((_e = resources === null || resources === void 0 ? void 0 : resources.dateErrorResources) === null || _e === void 0 ? void 0 : _e.errorRequiredDate) || ERROR_REQUIRED_DATE;\n      } else if (errorString === undefined && !timeString && (isRequired || isTimeRequired)) {\n        errorString = ((_g = (_f = resources === null || resources === void 0 ? void 0 : resources.timeResources) === null || _f === void 0 ? void 0 : _f.errorResources) === null || _g === void 0 ? void 0 : _g.errorRequiredTime) || ERROR_REQUIRED_TIME;\n      } else {\n        errorString = ((_j = (_h = resources === null || resources === void 0 ? void 0 : resources.timeResources) === null || _h === void 0 ? void 0 : _h.errorResources) === null || _j === void 0 ? void 0 : _j.errorInvalidTime) || ERROR_INVALID_TIME;\n      }\n    }\n  }\n\n  return errorString;\n};","map":null,"metadata":{},"sourceType":"module"}