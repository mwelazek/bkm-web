{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\nvar Token = require('./Token').Token;\n\nrequire('./polyfills/codepointat');\n\nrequire('./polyfills/fromcodepoint'); // Vacuum all input from a string and then treat it like a buffer.\n\n\nfunction _loadString(stream) {\n  stream._index = 0;\n  stream.data = [];\n\n  if (stream.decodeToUnicodeCodePoints) {\n    for (var i = 0; i < stream.strdata.length;) {\n      var codePoint = stream.strdata.codePointAt(i);\n      stream.data.push(codePoint);\n      i += codePoint <= 0xFFFF ? 1 : 2;\n    }\n  } else {\n    for (var i = 0; i < stream.strdata.length; i++) {\n      var codeUnit = stream.strdata.charCodeAt(i);\n      stream.data.push(codeUnit);\n    }\n  }\n\n  stream._size = stream.data.length;\n} // If decodeToUnicodeCodePoints is true, the input is treated\n// as a series of Unicode code points.\n//\n// Otherwise, the input is treated as a series of 16-bit UTF-16 code\n// units.\n\n\nfunction InputStream(data, decodeToUnicodeCodePoints) {\n  this.name = \"<empty>\";\n  this.strdata = data;\n  this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n\n  _loadString(this);\n\n  return this;\n}\n\nObject.defineProperty(InputStream.prototype, \"index\", {\n  get: function () {\n    return this._index;\n  }\n});\nObject.defineProperty(InputStream.prototype, \"size\", {\n  get: function () {\n    return this._size;\n  }\n}); // Reset the stream so that it's in the same state it was\n// when the object was created *except* the data array is not\n// touched.\n//\n\nInputStream.prototype.reset = function () {\n  this._index = 0;\n};\n\nInputStream.prototype.consume = function () {\n  if (this._index >= this._size) {\n    // assert this.LA(1) == Token.EOF\n    throw \"cannot consume EOF\";\n  }\n\n  this._index += 1;\n};\n\nInputStream.prototype.LA = function (offset) {\n  if (offset === 0) {\n    return 0; // undefined\n  }\n\n  if (offset < 0) {\n    offset += 1; // e.g., translate LA(-1) to use offset=0\n  }\n\n  var pos = this._index + offset - 1;\n\n  if (pos < 0 || pos >= this._size) {\n    // invalid\n    return Token.EOF;\n  }\n\n  return this.data[pos];\n};\n\nInputStream.prototype.LT = function (offset) {\n  return this.LA(offset);\n}; // mark/release do nothing; we have entire buffer\n\n\nInputStream.prototype.mark = function () {\n  return -1;\n};\n\nInputStream.prototype.release = function (marker) {}; // consume() ahead until p==_index; can't just set p=_index as we must\n// update line and column. If we seek backwards, just set p\n//\n\n\nInputStream.prototype.seek = function (_index) {\n  if (_index <= this._index) {\n    this._index = _index; // just jump; don't update stream state (line,\n    // ...)\n\n    return;\n  } // seek forward\n\n\n  this._index = Math.min(_index, this._size);\n};\n\nInputStream.prototype.getText = function (start, stop) {\n  if (stop >= this._size) {\n    stop = this._size - 1;\n  }\n\n  if (start >= this._size) {\n    return \"\";\n  } else {\n    if (this.decodeToUnicodeCodePoints) {\n      var result = \"\";\n\n      for (var i = start; i <= stop; i++) {\n        result += String.fromCodePoint(this.data[i]);\n      }\n\n      return result;\n    } else {\n      return this.strdata.slice(start, stop + 1);\n    }\n  }\n};\n\nInputStream.prototype.toString = function () {\n  return this.strdata;\n};\n\nexports.InputStream = InputStream;","map":null,"metadata":{},"sourceType":"script"}