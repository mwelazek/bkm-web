{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\nvar Token = require('./../Token').Token;\n\nvar Errors = require('./Errors');\n\nvar NoViableAltException = Errors.NoViableAltException;\nvar InputMismatchException = Errors.InputMismatchException;\nvar FailedPredicateException = Errors.FailedPredicateException;\nvar ParseCancellationException = Errors.ParseCancellationException;\n\nvar ATNState = require('./../atn/ATNState').ATNState;\n\nvar Interval = require('./../IntervalSet').Interval;\n\nvar IntervalSet = require('./../IntervalSet').IntervalSet;\n\nfunction ErrorStrategy() {}\n\nErrorStrategy.prototype.reset = function (recognizer) {};\n\nErrorStrategy.prototype.recoverInline = function (recognizer) {};\n\nErrorStrategy.prototype.recover = function (recognizer, e) {};\n\nErrorStrategy.prototype.sync = function (recognizer) {};\n\nErrorStrategy.prototype.inErrorRecoveryMode = function (recognizer) {};\n\nErrorStrategy.prototype.reportError = function (recognizer) {}; // This is the default implementation of {@link ANTLRErrorStrategy} used for\n// error reporting and recovery in ANTLR parsers.\n//\n\n\nfunction DefaultErrorStrategy() {\n  ErrorStrategy.call(this); // Indicates whether the error strategy is currently \"recovering from an\n  // error\". This is used to suppress reporting multiple error messages while\n  // attempting to recover from a detected syntax error.\n  //\n  // @see //inErrorRecoveryMode\n  //\n\n  this.errorRecoveryMode = false; // The index into the input stream where the last error occurred.\n  // This is used to prevent infinite loops where an error is found\n  // but no token is consumed during recovery...another error is found,\n  // ad nauseum. This is a failsafe mechanism to guarantee that at least\n  // one token/tree node is consumed for two errors.\n  //\n\n  this.lastErrorIndex = -1;\n  this.lastErrorStates = null;\n  return this;\n}\n\nDefaultErrorStrategy.prototype = Object.create(ErrorStrategy.prototype);\nDefaultErrorStrategy.prototype.constructor = DefaultErrorStrategy; // <p>The default implementation simply calls {@link //endErrorCondition} to\n// ensure that the handler is not in error recovery mode.</p>\n\nDefaultErrorStrategy.prototype.reset = function (recognizer) {\n  this.endErrorCondition(recognizer);\n}; //\n// This method is called to enter error recovery mode when a recognition\n// exception is reported.\n//\n// @param recognizer the parser instance\n//\n\n\nDefaultErrorStrategy.prototype.beginErrorCondition = function (recognizer) {\n  this.errorRecoveryMode = true;\n};\n\nDefaultErrorStrategy.prototype.inErrorRecoveryMode = function (recognizer) {\n  return this.errorRecoveryMode;\n}; //\n// This method is called to leave error recovery mode after recovering from\n// a recognition exception.\n//\n// @param recognizer\n//\n\n\nDefaultErrorStrategy.prototype.endErrorCondition = function (recognizer) {\n  this.errorRecoveryMode = false;\n  this.lastErrorStates = null;\n  this.lastErrorIndex = -1;\n}; //\n// {@inheritDoc}\n//\n// <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n//\n\n\nDefaultErrorStrategy.prototype.reportMatch = function (recognizer) {\n  this.endErrorCondition(recognizer);\n}; //\n// {@inheritDoc}\n//\n// <p>The default implementation returns immediately if the handler is already\n// in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n// and dispatches the reporting task based on the runtime type of {@code e}\n// according to the following table.</p>\n//\n// <ul>\n// <li>{@link NoViableAltException}: Dispatches the call to\n// {@link //reportNoViableAlternative}</li>\n// <li>{@link InputMismatchException}: Dispatches the call to\n// {@link //reportInputMismatch}</li>\n// <li>{@link FailedPredicateException}: Dispatches the call to\n// {@link //reportFailedPredicate}</li>\n// <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n// the exception</li>\n// </ul>\n//\n\n\nDefaultErrorStrategy.prototype.reportError = function (recognizer, e) {\n  // if we've already reported an error and have not matched a token\n  // yet successfully, don't report any errors.\n  if (this.inErrorRecoveryMode(recognizer)) {\n    return; // don't report spurious errors\n  }\n\n  this.beginErrorCondition(recognizer);\n\n  if (e instanceof NoViableAltException) {\n    this.reportNoViableAlternative(recognizer, e);\n  } else if (e instanceof InputMismatchException) {\n    this.reportInputMismatch(recognizer, e);\n  } else if (e instanceof FailedPredicateException) {\n    this.reportFailedPredicate(recognizer, e);\n  } else {\n    console.log(\"unknown recognition error type: \" + e.constructor.name);\n    console.log(e.stack);\n    recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n  }\n}; //\n// {@inheritDoc}\n//\n// <p>The default implementation resynchronizes the parser by consuming tokens\n// until we find one in the resynchronization set--loosely the set of tokens\n// that can follow the current rule.</p>\n//\n\n\nDefaultErrorStrategy.prototype.recover = function (recognizer, e) {\n  if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {\n    // uh oh, another error at same token index and previously-visited\n    // state in ATN; must be a case where LT(1) is in the recovery\n    // token set so nothing got consumed. Consume a single token\n    // at least to prevent an infinite loop; this is a failsafe.\n    recognizer.consume();\n  }\n\n  this.lastErrorIndex = recognizer._input.index;\n\n  if (this.lastErrorStates === null) {\n    this.lastErrorStates = [];\n  }\n\n  this.lastErrorStates.push(recognizer.state);\n  var followSet = this.getErrorRecoverySet(recognizer);\n  this.consumeUntil(recognizer, followSet);\n}; // The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n// that the current lookahead symbol is consistent with what were expecting\n// at this point in the ATN. You can call this anytime but ANTLR only\n// generates code to check before subrules/loops and each iteration.\n//\n// <p>Implements Jim Idle's magic sync mechanism in closures and optional\n// subrules. E.g.,</p>\n//\n// <pre>\n// a : sync ( stuff sync )* ;\n// sync : {consume to what can follow sync} ;\n// </pre>\n//\n// At the start of a sub rule upon error, {@link //sync} performs single\n// token deletion, if possible. If it can't do that, it bails on the current\n// rule and uses the default error recovery, which consumes until the\n// resynchronization set of the current rule.\n//\n// <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n// with an empty alternative), then the expected set includes what follows\n// the subrule.</p>\n//\n// <p>During loop iteration, it consumes until it sees a token that can start a\n// sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n// stay in the loop as long as possible.</p>\n//\n// <p><strong>ORIGINS</strong></p>\n//\n// <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n// A single mismatch token or missing token would force the parser to bail\n// out of the entire rules surrounding the loop. So, for rule</p>\n//\n// <pre>\n// classDef : 'class' ID '{' member* '}'\n// </pre>\n//\n// input with an extra token between members would force the parser to\n// consume until it found the next class definition rather than the next\n// member definition of the current class.\n//\n// <p>This functionality cost a little bit of effort because the parser has to\n// compare token set at the start of the loop and at each iteration. If for\n// some reason speed is suffering for you, you can turn off this\n// functionality by simply overriding this method as a blank { }.</p>\n//\n\n\nDefaultErrorStrategy.prototype.sync = function (recognizer) {\n  // If already recovering, don't try to sync\n  if (this.inErrorRecoveryMode(recognizer)) {\n    return;\n  }\n\n  var s = recognizer._interp.atn.states[recognizer.state];\n  var la = recognizer.getTokenStream().LA(1); // try cheaper subset first; might get lucky. seems to shave a wee bit off\n\n  var nextTokens = recognizer.atn.nextTokens(s);\n\n  if (nextTokens.contains(Token.EPSILON) || nextTokens.contains(la)) {\n    return;\n  }\n\n  switch (s.stateType) {\n    case ATNState.BLOCK_START:\n    case ATNState.STAR_BLOCK_START:\n    case ATNState.PLUS_BLOCK_START:\n    case ATNState.STAR_LOOP_ENTRY:\n      // report error and recover if possible\n      if (this.singleTokenDeletion(recognizer) !== null) {\n        return;\n      } else {\n        throw new InputMismatchException(recognizer);\n      }\n\n      break;\n\n    case ATNState.PLUS_LOOP_BACK:\n    case ATNState.STAR_LOOP_BACK:\n      this.reportUnwantedToken(recognizer);\n      var expecting = new IntervalSet();\n      expecting.addSet(recognizer.getExpectedTokens());\n      var whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));\n      this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n      break;\n\n    default: // do nothing if we can't identify the exact kind of ATN state\n\n  }\n}; // This is called by {@link //reportError} when the exception is a\n// {@link NoViableAltException}.\n//\n// @see //reportError\n//\n// @param recognizer the parser instance\n// @param e the recognition exception\n//\n\n\nDefaultErrorStrategy.prototype.reportNoViableAlternative = function (recognizer, e) {\n  var tokens = recognizer.getTokenStream();\n  var input;\n\n  if (tokens !== null) {\n    if (e.startToken.type === Token.EOF) {\n      input = \"<EOF>\";\n    } else {\n      input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n    }\n  } else {\n    input = \"<unknown input>\";\n  }\n\n  var msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n  recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n}; //\n// This is called by {@link //reportError} when the exception is an\n// {@link InputMismatchException}.\n//\n// @see //reportError\n//\n// @param recognizer the parser instance\n// @param e the recognition exception\n//\n\n\nDefaultErrorStrategy.prototype.reportInputMismatch = function (recognizer, e) {\n  var msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) + \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);\n  recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n}; //\n// This is called by {@link //reportError} when the exception is a\n// {@link FailedPredicateException}.\n//\n// @see //reportError\n//\n// @param recognizer the parser instance\n// @param e the recognition exception\n//\n\n\nDefaultErrorStrategy.prototype.reportFailedPredicate = function (recognizer, e) {\n  var ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];\n  var msg = \"rule \" + ruleName + \" \" + e.message;\n  recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n}; // This method is called to report a syntax error which requires the removal\n// of a token from the input stream. At the time this method is called, the\n// erroneous symbol is current {@code LT(1)} symbol and has not yet been\n// removed from the input stream. When this method returns,\n// {@code recognizer} is in error recovery mode.\n//\n// <p>This method is called when {@link //singleTokenDeletion} identifies\n// single-token deletion as a viable recovery strategy for a mismatched\n// input error.</p>\n//\n// <p>The default implementation simply returns if the handler is already in\n// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n// enter error recovery mode, followed by calling\n// {@link Parser//notifyErrorListeners}.</p>\n//\n// @param recognizer the parser instance\n//\n\n\nDefaultErrorStrategy.prototype.reportUnwantedToken = function (recognizer) {\n  if (this.inErrorRecoveryMode(recognizer)) {\n    return;\n  }\n\n  this.beginErrorCondition(recognizer);\n  var t = recognizer.getCurrentToken();\n  var tokenName = this.getTokenErrorDisplay(t);\n  var expecting = this.getExpectedTokens(recognizer);\n  var msg = \"extraneous input \" + tokenName + \" expecting \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);\n  recognizer.notifyErrorListeners(msg, t, null);\n}; // This method is called to report a syntax error which requires the\n// insertion of a missing token into the input stream. At the time this\n// method is called, the missing token has not yet been inserted. When this\n// method returns, {@code recognizer} is in error recovery mode.\n//\n// <p>This method is called when {@link //singleTokenInsertion} identifies\n// single-token insertion as a viable recovery strategy for a mismatched\n// input error.</p>\n//\n// <p>The default implementation simply returns if the handler is already in\n// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n// enter error recovery mode, followed by calling\n// {@link Parser//notifyErrorListeners}.</p>\n//\n// @param recognizer the parser instance\n//\n\n\nDefaultErrorStrategy.prototype.reportMissingToken = function (recognizer) {\n  if (this.inErrorRecoveryMode(recognizer)) {\n    return;\n  }\n\n  this.beginErrorCondition(recognizer);\n  var t = recognizer.getCurrentToken();\n  var expecting = this.getExpectedTokens(recognizer);\n  var msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + \" at \" + this.getTokenErrorDisplay(t);\n  recognizer.notifyErrorListeners(msg, t, null);\n}; // <p>The default implementation attempts to recover from the mismatched input\n// by using single token insertion and deletion as described below. If the\n// recovery attempt fails, this method throws an\n// {@link InputMismatchException}.</p>\n//\n// <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n//\n// <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n// right token, however, then assume {@code LA(1)} is some extra spurious\n// token and delete it. Then consume and return the next token (which was\n// the {@code LA(2)} token) as the successful result of the match operation.</p>\n//\n// <p>This recovery strategy is implemented by {@link\n// //singleTokenDeletion}.</p>\n//\n// <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n//\n// <p>If current token (at {@code LA(1)}) is consistent with what could come\n// after the expected {@code LA(1)} token, then assume the token is missing\n// and use the parser's {@link TokenFactory} to create it on the fly. The\n// \"insertion\" is performed by returning the created token as the successful\n// result of the match operation.</p>\n//\n// <p>This recovery strategy is implemented by {@link\n// //singleTokenInsertion}.</p>\n//\n// <p><strong>EXAMPLE</strong></p>\n//\n// <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n// the parser returns from the nested call to {@code expr}, it will have\n// call chain:</p>\n//\n// <pre>\n// stat &rarr; expr &rarr; atom\n// </pre>\n//\n// and it will be trying to match the {@code ')'} at this point in the\n// derivation:\n//\n// <pre>\n// =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n// ^\n// </pre>\n//\n// The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n// call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n// is in the set of tokens that can follow the {@code ')'} token reference\n// in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n//\n\n\nDefaultErrorStrategy.prototype.recoverInline = function (recognizer) {\n  // SINGLE TOKEN DELETION\n  var matchedSymbol = this.singleTokenDeletion(recognizer);\n\n  if (matchedSymbol !== null) {\n    // we have deleted the extra token.\n    // now, move past ttype token as if all were ok\n    recognizer.consume();\n    return matchedSymbol;\n  } // SINGLE TOKEN INSERTION\n\n\n  if (this.singleTokenInsertion(recognizer)) {\n    return this.getMissingSymbol(recognizer);\n  } // even that didn't work; must throw the exception\n\n\n  throw new InputMismatchException(recognizer);\n}; //\n// This method implements the single-token insertion inline error recovery\n// strategy. It is called by {@link //recoverInline} if the single-token\n// deletion strategy fails to recover from the mismatched input. If this\n// method returns {@code true}, {@code recognizer} will be in error recovery\n// mode.\n//\n// <p>This method determines whether or not single-token insertion is viable by\n// checking if the {@code LA(1)} input symbol could be successfully matched\n// if it were instead the {@code LA(2)} symbol. If this method returns\n// {@code true}, the caller is responsible for creating and inserting a\n// token with the correct type to produce this behavior.</p>\n//\n// @param recognizer the parser instance\n// @return {@code true} if single-token insertion is a viable recovery\n// strategy for the current mismatched input, otherwise {@code false}\n//\n\n\nDefaultErrorStrategy.prototype.singleTokenInsertion = function (recognizer) {\n  var currentSymbolType = recognizer.getTokenStream().LA(1); // if current token is consistent with what could come after current\n  // ATN state, then we know we're missing a token; error recovery\n  // is free to conjure up and insert the missing token\n\n  var atn = recognizer._interp.atn;\n  var currentState = atn.states[recognizer.state];\n  var next = currentState.transitions[0].target;\n  var expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);\n\n  if (expectingAtLL2.contains(currentSymbolType)) {\n    this.reportMissingToken(recognizer);\n    return true;\n  } else {\n    return false;\n  }\n}; // This method implements the single-token deletion inline error recovery\n// strategy. It is called by {@link //recoverInline} to attempt to recover\n// from mismatched input. If this method returns null, the parser and error\n// handler state will not have changed. If this method returns non-null,\n// {@code recognizer} will <em>not</em> be in error recovery mode since the\n// returned token was a successful match.\n//\n// <p>If the single-token deletion is successful, this method calls\n// {@link //reportUnwantedToken} to report the error, followed by\n// {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n// before returning {@link //reportMatch} is called to signal a successful\n// match.</p>\n//\n// @param recognizer the parser instance\n// @return the successfully matched {@link Token} instance if single-token\n// deletion successfully recovers from the mismatched input, otherwise\n// {@code null}\n//\n\n\nDefaultErrorStrategy.prototype.singleTokenDeletion = function (recognizer) {\n  var nextTokenType = recognizer.getTokenStream().LA(2);\n  var expecting = this.getExpectedTokens(recognizer);\n\n  if (expecting.contains(nextTokenType)) {\n    this.reportUnwantedToken(recognizer); // print(\"recoverFromMismatchedToken deleting \" \\\n    // + str(recognizer.getTokenStream().LT(1)) \\\n    // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n    // + \" is what we want\", file=sys.stderr)\n\n    recognizer.consume(); // simply delete extra token\n    // we want to return the token we're actually matching\n\n    var matchedSymbol = recognizer.getCurrentToken();\n    this.reportMatch(recognizer); // we know current token is correct\n\n    return matchedSymbol;\n  } else {\n    return null;\n  }\n}; // Conjure up a missing token during error recovery.\n//\n// The recognizer attempts to recover from single missing\n// symbols. But, actions might refer to that missing symbol.\n// For example, x=ID {f($x);}. The action clearly assumes\n// that there has been an identifier matched previously and that\n// $x points at that token. If that token is missing, but\n// the next token in the stream is what we want we assume that\n// this token is missing and we keep going. Because we\n// have to return some token to replace the missing token,\n// we have to conjure one up. This method gives the user control\n// over the tokens returned for missing tokens. Mostly,\n// you will want to create something special for identifier\n// tokens. For literals such as '{' and ',', the default\n// action in the parser or tree parser works. It simply creates\n// a CommonToken of the appropriate type. The text will be the token.\n// If you change what tokens must be created by the lexer,\n// override this method to create the appropriate tokens.\n//\n\n\nDefaultErrorStrategy.prototype.getMissingSymbol = function (recognizer) {\n  var currentSymbol = recognizer.getCurrentToken();\n  var expecting = this.getExpectedTokens(recognizer);\n  var expectedTokenType = expecting.first(); // get any element\n\n  var tokenText;\n\n  if (expectedTokenType === Token.EOF) {\n    tokenText = \"<missing EOF>\";\n  } else {\n    tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n  }\n\n  var current = currentSymbol;\n  var lookback = recognizer.getTokenStream().LT(-1);\n\n  if (current.type === Token.EOF && lookback !== null) {\n    current = lookback;\n  }\n\n  return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, Token.DEFAULT_CHANNEL, -1, -1, current.line, current.column);\n};\n\nDefaultErrorStrategy.prototype.getExpectedTokens = function (recognizer) {\n  return recognizer.getExpectedTokens();\n}; // How should a token be displayed in an error message? The default\n// is to display just the text, but during development you might\n// want to have a lot of information spit out. Override in that case\n// to use t.toString() (which, for CommonToken, dumps everything about\n// the token). This is better than forcing you to override a method in\n// your token objects because you don't have to go modify your lexer\n// so that it creates a new Java type.\n//\n\n\nDefaultErrorStrategy.prototype.getTokenErrorDisplay = function (t) {\n  if (t === null) {\n    return \"<no token>\";\n  }\n\n  var s = t.text;\n\n  if (s === null) {\n    if (t.type === Token.EOF) {\n      s = \"<EOF>\";\n    } else {\n      s = \"<\" + t.type + \">\";\n    }\n  }\n\n  return this.escapeWSAndQuote(s);\n};\n\nDefaultErrorStrategy.prototype.escapeWSAndQuote = function (s) {\n  s = s.replace(/\\n/g, \"\\\\n\");\n  s = s.replace(/\\r/g, \"\\\\r\");\n  s = s.replace(/\\t/g, \"\\\\t\");\n  return \"'\" + s + \"'\";\n}; // Compute the error recovery set for the current rule. During\n// rule invocation, the parser pushes the set of tokens that can\n// follow that rule reference on the stack; this amounts to\n// computing FIRST of what follows the rule reference in the\n// enclosing rule. See LinearApproximator.FIRST().\n// This local follow set only includes tokens\n// from within the rule; i.e., the FIRST computation done by\n// ANTLR stops at the end of a rule.\n//\n// EXAMPLE\n//\n// When you find a \"no viable alt exception\", the input is not\n// consistent with any of the alternatives for rule r. The best\n// thing to do is to consume tokens until you see something that\n// can legally follow a call to r//or* any rule that called r.\n// You don't want the exact set of viable next tokens because the\n// input might just be missing a token--you might consume the\n// rest of the input looking for one of the missing tokens.\n//\n// Consider grammar:\n//\n// a : '[' b ']'\n// | '(' b ')'\n// ;\n// b : c '^' INT ;\n// c : ID\n// | INT\n// ;\n//\n// At each rule invocation, the set of tokens that could follow\n// that rule is pushed on a stack. Here are the various\n// context-sensitive follow sets:\n//\n// FOLLOW(b1_in_a) = FIRST(']') = ']'\n// FOLLOW(b2_in_a) = FIRST(')') = ')'\n// FOLLOW(c_in_b) = FIRST('^') = '^'\n//\n// Upon erroneous input \"[]\", the call chain is\n//\n// a -> b -> c\n//\n// and, hence, the follow context stack is:\n//\n// depth follow set start of rule execution\n// 0 <EOF> a (from main())\n// 1 ']' b\n// 2 '^' c\n//\n// Notice that ')' is not included, because b would have to have\n// been called from a different context in rule a for ')' to be\n// included.\n//\n// For error recovery, we cannot consider FOLLOW(c)\n// (context-sensitive or otherwise). We need the combined set of\n// all context-sensitive FOLLOW sets--the set of all tokens that\n// could follow any reference in the call chain. We need to\n// resync to one of those tokens. Note that FOLLOW(c)='^' and if\n// we resync'd to that token, we'd consume until EOF. We need to\n// sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n// In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n// not consume anything. After printing an error, rule c would\n// return normally. Rule b would not find the required '^' though.\n// At this point, it gets a mismatched token error and throws an\n// exception (since LA(1) is not in the viable following token\n// set). The rule exception handler tries to recover, but finds\n// the same recovery set and doesn't consume anything. Rule b\n// exits normally returning to rule a. Now it finds the ']' (and\n// with the successful match exits errorRecovery mode).\n//\n// So, you can see that the parser walks up the call chain looking\n// for the token that was a member of the recovery set.\n//\n// Errors are not generated in errorRecovery mode.\n//\n// ANTLR's error recovery mechanism is based upon original ideas:\n//\n// \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n//\n// and\n//\n// \"A note on error recovery in recursive descent parsers\":\n// http://portal.acm.org/citation.cfm?id=947902.947905\n//\n// Later, Josef Grosch had some good ideas:\n//\n// \"Efficient and Comfortable Error Recovery in Recursive Descent\n// Parsers\":\n// ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n//\n// Like Grosch I implement context-sensitive FOLLOW sets that are combined\n// at run-time upon error to avoid overhead during parsing.\n//\n\n\nDefaultErrorStrategy.prototype.getErrorRecoverySet = function (recognizer) {\n  var atn = recognizer._interp.atn;\n  var ctx = recognizer._ctx;\n  var recoverSet = new IntervalSet();\n\n  while (ctx !== null && ctx.invokingState >= 0) {\n    // compute what follows who invoked us\n    var invokingState = atn.states[ctx.invokingState];\n    var rt = invokingState.transitions[0];\n    var follow = atn.nextTokens(rt.followState);\n    recoverSet.addSet(follow);\n    ctx = ctx.parentCtx;\n  }\n\n  recoverSet.removeOne(Token.EPSILON);\n  return recoverSet;\n}; // Consume tokens until one matches the given token set.//\n\n\nDefaultErrorStrategy.prototype.consumeUntil = function (recognizer, set) {\n  var ttype = recognizer.getTokenStream().LA(1);\n\n  while (ttype !== Token.EOF && !set.contains(ttype)) {\n    recognizer.consume();\n    ttype = recognizer.getTokenStream().LA(1);\n  }\n}; //\n// This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n// by immediately canceling the parse operation with a\n// {@link ParseCancellationException}. The implementation ensures that the\n// {@link ParserRuleContext//exception} field is set for all parse tree nodes\n// that were not completed prior to encountering the error.\n//\n// <p>\n// This error strategy is useful in the following scenarios.</p>\n//\n// <ul>\n// <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n// stage of two-stage parsing to immediately terminate if an error is\n// encountered, and immediately fall back to the second stage. In addition to\n// avoiding wasted work by attempting to recover from errors here, the empty\n// implementation of {@link BailErrorStrategy//sync} improves the performance of\n// the first stage.</li>\n// <li><strong>Silent validation:</strong> When syntax errors are not being\n// reported or logged, and the parse result is simply ignored if errors occur,\n// the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n// when the result will be ignored either way.</li>\n// </ul>\n//\n// <p>\n// {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n//\n// @see Parser//setErrorHandler(ANTLRErrorStrategy)\n//\n\n\nfunction BailErrorStrategy() {\n  DefaultErrorStrategy.call(this);\n  return this;\n}\n\nBailErrorStrategy.prototype = Object.create(DefaultErrorStrategy.prototype);\nBailErrorStrategy.prototype.constructor = BailErrorStrategy; // Instead of recovering from exception {@code e}, re-throw it wrapped\n// in a {@link ParseCancellationException} so it is not caught by the\n// rule function catches. Use {@link Exception//getCause()} to get the\n// original {@link RecognitionException}.\n//\n\nBailErrorStrategy.prototype.recover = function (recognizer, e) {\n  var context = recognizer._ctx;\n\n  while (context !== null) {\n    context.exception = e;\n    context = context.parentCtx;\n  }\n\n  throw new ParseCancellationException(e);\n}; // Make sure we don't attempt to recover inline; if the parser\n// successfully recovers, it won't throw an exception.\n//\n\n\nBailErrorStrategy.prototype.recoverInline = function (recognizer) {\n  this.recover(recognizer, new InputMismatchException(recognizer));\n}; // Make sure we don't attempt to recover from problems in subrules.//\n\n\nBailErrorStrategy.prototype.sync = function (recognizer) {// pass\n};\n\nexports.BailErrorStrategy = BailErrorStrategy;\nexports.DefaultErrorStrategy = DefaultErrorStrategy;","map":null,"metadata":{},"sourceType":"script"}