{"ast":null,"code":"// Generated from FHIRPath.g4 by ANTLR 4.7.1\n// jshint ignore: start\nvar antlr4 = require('../antlr4-index');\n\nvar FHIRPathListener = require('./FHIRPathListener').FHIRPathListener;\n\nvar grammarFileName = \"FHIRPath.g4\";\nvar serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\", \"\\u0003A\\u009c\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\\u0004\\t\", \"\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\\u0007\\u0004\", \"\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\\f\\t\\f\\u0004\", \"\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\\t\\u0010\\u0003\", \"\\u0002\\u0003\\u0002\\u0003\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\", \"\\u0003\\u0005\\u0003(\\n\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\", \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\", \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\", \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\", \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\", \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\", \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0007\\u0003P\", \"\\n\\u0003\\f\\u0003\\u000e\\u0003S\\u000b\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\", \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0005\\u0004\\\\\", \"\\n\\u0004\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\", \"\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0005\\u0005f\\n\\u0005\\u0003\\u0006\", \"\\u0003\\u0006\\u0003\\u0006\\u0005\\u0006k\\n\\u0006\\u0003\\u0007\\u0003\\u0007\", \"\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0005\\u0007r\\n\\u0007\\u0003\\b\\u0003\", \"\\b\\u0003\\b\\u0005\\bw\\n\\b\\u0003\\b\\u0003\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0007\", \"\\t~\\n\\t\\f\\t\\u000e\\t\\u0081\\u000b\\t\\u0003\\n\\u0003\\n\\u0005\\n\\u0085\\n\\n\", \"\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0005\\u000b\\u008a\\n\\u000b\\u0003\", \"\\f\\u0003\\f\\u0003\\r\\u0003\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000f\\u0003\", \"\\u000f\\u0003\\u000f\\u0007\\u000f\\u0095\\n\\u000f\\f\\u000f\\u000e\\u000f\\u0098\", \"\\u000b\\u000f\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\\u0002\\u0003\\u0004\\u0011\", \"\\u0002\\u0004\\u0006\\b\\n\\f\\u000e\\u0010\\u0012\\u0014\\u0016\\u0018\\u001a\\u001c\", \"\\u001e\\u0002\\u000e\\u0003\\u0002\\u0006\\u0007\\u0003\\u0002\\b\\u000b\\u0004\", \"\\u0002\\u0006\\u0007\\f\\f\\u0003\\u0002\\u000e\\u0011\\u0003\\u0002\\u0014\\u0017\", \"\\u0003\\u0002\\u0018\\u0019\\u0003\\u0002\\u001b\\u001c\\u0003\\u0002\\u0012\\u0013\", \"\\u0003\\u0002\\\"#\\u0003\\u0002)0\\u0003\\u000218\\u0005\\u0002\\u0012\\u0013\", \"\\u0018\\u0019;<\\u0002\\u00ad\\u0002 \\u0003\\u0002\\u0002\\u0002\\u0004\\'\\u0003\", \"\\u0002\\u0002\\u0002\\u0006[\\u0003\\u0002\\u0002\\u0002\\be\\u0003\\u0002\\u0002\", \"\\u0002\\ng\\u0003\\u0002\\u0002\\u0002\\fq\\u0003\\u0002\\u0002\\u0002\\u000es\", \"\\u0003\\u0002\\u0002\\u0002\\u0010z\\u0003\\u0002\\u0002\\u0002\\u0012\\u0082\", \"\\u0003\\u0002\\u0002\\u0002\\u0014\\u0089\\u0003\\u0002\\u0002\\u0002\\u0016\\u008b\", \"\\u0003\\u0002\\u0002\\u0002\\u0018\\u008d\\u0003\\u0002\\u0002\\u0002\\u001a\\u008f\", \"\\u0003\\u0002\\u0002\\u0002\\u001c\\u0091\\u0003\\u0002\\u0002\\u0002\\u001e\\u0099\", \"\\u0003\\u0002\\u0002\\u0002 !\\u0005\\u0004\\u0003\\u0002!\\\"\\u0007\\u0002\\u0002\", \"\\u0003\\\"\\u0003\\u0003\\u0002\\u0002\\u0002#$\\b\\u0003\\u0001\\u0002$(\\u0005\", \"\\u0006\\u0004\\u0002%&\\t\\u0002\\u0002\\u0002&(\\u0005\\u0004\\u0003\\r\\'#\\u0003\", \"\\u0002\\u0002\\u0002\\'%\\u0003\\u0002\\u0002\\u0002(Q\\u0003\\u0002\\u0002\\u0002\", \")*\\f\\f\\u0002\\u0002*+\\t\\u0003\\u0002\\u0002+P\\u0005\\u0004\\u0003\\r,-\\f\\u000b\", \"\\u0002\\u0002-.\\t\\u0004\\u0002\\u0002.P\\u0005\\u0004\\u0003\\f/0\\f\\n\\u0002\", \"\\u000201\\u0007\\r\\u0002\\u00021P\\u0005\\u0004\\u0003\\u000b23\\f\\t\\u0002\\u0002\", \"34\\t\\u0005\\u0002\\u00024P\\u0005\\u0004\\u0003\\n56\\f\\u0007\\u0002\\u00026\", \"7\\t\\u0006\\u0002\\u00027P\\u0005\\u0004\\u0003\\b89\\f\\u0006\\u0002\\u00029:\", \"\\t\\u0007\\u0002\\u0002:P\\u0005\\u0004\\u0003\\u0007;<\\f\\u0005\\u0002\\u0002\", \"<=\\u0007\\u001a\\u0002\\u0002=P\\u0005\\u0004\\u0003\\u0006>?\\f\\u0004\\u0002\", \"\\u0002?@\\t\\b\\u0002\\u0002@P\\u0005\\u0004\\u0003\\u0005AB\\f\\u0003\\u0002\\u0002\", \"BC\\u0007\\u001d\\u0002\\u0002CP\\u0005\\u0004\\u0003\\u0004DE\\f\\u000f\\u0002\", \"\\u0002EF\\u0007\\u0003\\u0002\\u0002FP\\u0005\\f\\u0007\\u0002GH\\f\\u000e\\u0002\", \"\\u0002HI\\u0007\\u0004\\u0002\\u0002IJ\\u0005\\u0004\\u0003\\u0002JK\\u0007\\u0005\", \"\\u0002\\u0002KP\\u0003\\u0002\\u0002\\u0002LM\\f\\b\\u0002\\u0002MN\\t\\t\\u0002\", \"\\u0002NP\\u0005\\u001a\\u000e\\u0002O)\\u0003\\u0002\\u0002\\u0002O,\\u0003\\u0002\", \"\\u0002\\u0002O/\\u0003\\u0002\\u0002\\u0002O2\\u0003\\u0002\\u0002\\u0002O5\\u0003\", \"\\u0002\\u0002\\u0002O8\\u0003\\u0002\\u0002\\u0002O;\\u0003\\u0002\\u0002\\u0002\", \"O>\\u0003\\u0002\\u0002\\u0002OA\\u0003\\u0002\\u0002\\u0002OD\\u0003\\u0002\\u0002\", \"\\u0002OG\\u0003\\u0002\\u0002\\u0002OL\\u0003\\u0002\\u0002\\u0002PS\\u0003\\u0002\", \"\\u0002\\u0002QO\\u0003\\u0002\\u0002\\u0002QR\\u0003\\u0002\\u0002\\u0002R\\u0005\", \"\\u0003\\u0002\\u0002\\u0002SQ\\u0003\\u0002\\u0002\\u0002T\\\\\\u0005\\f\\u0007\", \"\\u0002U\\\\\\u0005\\b\\u0005\\u0002V\\\\\\u0005\\n\\u0006\\u0002WX\\u0007\\u001e\\u0002\", \"\\u0002XY\\u0005\\u0004\\u0003\\u0002YZ\\u0007\\u001f\\u0002\\u0002Z\\\\\\u0003\", \"\\u0002\\u0002\\u0002[T\\u0003\\u0002\\u0002\\u0002[U\\u0003\\u0002\\u0002\\u0002\", \"[V\\u0003\\u0002\\u0002\\u0002[W\\u0003\\u0002\\u0002\\u0002\\\\\\u0007\\u0003\\u0002\", \"\\u0002\\u0002]^\\u0007 \\u0002\\u0002^f\\u0007!\\u0002\\u0002_f\\t\\n\\u0002\\u0002\", \"`f\\u0007=\\u0002\\u0002af\\u0007>\\u0002\\u0002bf\\u00079\\u0002\\u0002cf\\u0007\", \":\\u0002\\u0002df\\u0005\\u0012\\n\\u0002e]\\u0003\\u0002\\u0002\\u0002e_\\u0003\", \"\\u0002\\u0002\\u0002e`\\u0003\\u0002\\u0002\\u0002ea\\u0003\\u0002\\u0002\\u0002\", \"eb\\u0003\\u0002\\u0002\\u0002ec\\u0003\\u0002\\u0002\\u0002ed\\u0003\\u0002\\u0002\", \"\\u0002f\\t\\u0003\\u0002\\u0002\\u0002gj\\u0007$\\u0002\\u0002hk\\u0005\\u001e\", \"\\u0010\\u0002ik\\u0007=\\u0002\\u0002jh\\u0003\\u0002\\u0002\\u0002ji\\u0003\", \"\\u0002\\u0002\\u0002k\\u000b\\u0003\\u0002\\u0002\\u0002lr\\u0005\\u001e\\u0010\", \"\\u0002mr\\u0005\\u000e\\b\\u0002nr\\u0007%\\u0002\\u0002or\\u0007&\\u0002\\u0002\", \"pr\\u0007\\'\\u0002\\u0002ql\\u0003\\u0002\\u0002\\u0002qm\\u0003\\u0002\\u0002\", \"\\u0002qn\\u0003\\u0002\\u0002\\u0002qo\\u0003\\u0002\\u0002\\u0002qp\\u0003\\u0002\", \"\\u0002\\u0002r\\r\\u0003\\u0002\\u0002\\u0002st\\u0005\\u001e\\u0010\\u0002tv\", \"\\u0007\\u001e\\u0002\\u0002uw\\u0005\\u0010\\t\\u0002vu\\u0003\\u0002\\u0002\\u0002\", \"vw\\u0003\\u0002\\u0002\\u0002wx\\u0003\\u0002\\u0002\\u0002xy\\u0007\\u001f\\u0002\", \"\\u0002y\\u000f\\u0003\\u0002\\u0002\\u0002z\\u007f\\u0005\\u0004\\u0003\\u0002\", \"{|\\u0007(\\u0002\\u0002|~\\u0005\\u0004\\u0003\\u0002}{\\u0003\\u0002\\u0002\", \"\\u0002~\\u0081\\u0003\\u0002\\u0002\\u0002\\u007f}\\u0003\\u0002\\u0002\\u0002\", \"\\u007f\\u0080\\u0003\\u0002\\u0002\\u0002\\u0080\\u0011\\u0003\\u0002\\u0002\\u0002\", \"\\u0081\\u007f\\u0003\\u0002\\u0002\\u0002\\u0082\\u0084\\u0007>\\u0002\\u0002\", \"\\u0083\\u0085\\u0005\\u0014\\u000b\\u0002\\u0084\\u0083\\u0003\\u0002\\u0002\\u0002\", \"\\u0084\\u0085\\u0003\\u0002\\u0002\\u0002\\u0085\\u0013\\u0003\\u0002\\u0002\\u0002\", \"\\u0086\\u008a\\u0005\\u0016\\f\\u0002\\u0087\\u008a\\u0005\\u0018\\r\\u0002\\u0088\", \"\\u008a\\u0007=\\u0002\\u0002\\u0089\\u0086\\u0003\\u0002\\u0002\\u0002\\u0089\", \"\\u0087\\u0003\\u0002\\u0002\\u0002\\u0089\\u0088\\u0003\\u0002\\u0002\\u0002\\u008a\", \"\\u0015\\u0003\\u0002\\u0002\\u0002\\u008b\\u008c\\t\\u000b\\u0002\\u0002\\u008c\", \"\\u0017\\u0003\\u0002\\u0002\\u0002\\u008d\\u008e\\t\\f\\u0002\\u0002\\u008e\\u0019\", \"\\u0003\\u0002\\u0002\\u0002\\u008f\\u0090\\u0005\\u001c\\u000f\\u0002\\u0090\\u001b\", \"\\u0003\\u0002\\u0002\\u0002\\u0091\\u0096\\u0005\\u001e\\u0010\\u0002\\u0092\\u0093\", \"\\u0007\\u0003\\u0002\\u0002\\u0093\\u0095\\u0005\\u001e\\u0010\\u0002\\u0094\\u0092\", \"\\u0003\\u0002\\u0002\\u0002\\u0095\\u0098\\u0003\\u0002\\u0002\\u0002\\u0096\\u0094\", \"\\u0003\\u0002\\u0002\\u0002\\u0096\\u0097\\u0003\\u0002\\u0002\\u0002\\u0097\\u001d\", \"\\u0003\\u0002\\u0002\\u0002\\u0098\\u0096\\u0003\\u0002\\u0002\\u0002\\u0099\\u009a\", \"\\t\\r\\u0002\\u0002\\u009a\\u001f\\u0003\\u0002\\u0002\\u0002\\u000e\\'OQ[ejqv\", \"\\u007f\\u0084\\u0089\\u0096\"].join(\"\");\nvar atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\nvar decisionsToDFA = atn.decisionToState.map(function (ds, index) {\n  return new antlr4.dfa.DFA(ds, index);\n});\nvar sharedContextCache = new antlr4.PredictionContextCache();\nvar literalNames = [null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \"'~'\", \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \"'and'\", \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \"')'\", \"'{'\", \"'}'\", \"'true'\", \"'false'\", \"'%'\", \"'$this'\", \"'$index'\", \"'$total'\", \"','\", \"'year'\", \"'month'\", \"'week'\", \"'day'\", \"'hour'\", \"'minute'\", \"'second'\", \"'millisecond'\", \"'years'\", \"'months'\", \"'weeks'\", \"'days'\", \"'hours'\", \"'minutes'\", \"'seconds'\", \"'milliseconds'\"];\nvar symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"DATETIME\", \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\"];\nvar ruleNames = [\"entireExpression\", \"expression\", \"term\", \"literal\", \"externalConstant\", \"invocation\", \"functn\", \"paramList\", \"quantity\", \"unit\", \"dateTimePrecision\", \"pluralDateTimePrecision\", \"typeSpecifier\", \"qualifiedIdentifier\", \"identifier\"];\n\nfunction FHIRPathParser(input) {\n  antlr4.Parser.call(this, input);\n  this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\n  this.ruleNames = ruleNames;\n  this.literalNames = literalNames;\n  this.symbolicNames = symbolicNames;\n  return this;\n}\n\nFHIRPathParser.prototype = Object.create(antlr4.Parser.prototype);\nFHIRPathParser.prototype.constructor = FHIRPathParser;\nObject.defineProperty(FHIRPathParser.prototype, \"atn\", {\n  get: function () {\n    return atn;\n  }\n});\nFHIRPathParser.EOF = antlr4.Token.EOF;\nFHIRPathParser.T__0 = 1;\nFHIRPathParser.T__1 = 2;\nFHIRPathParser.T__2 = 3;\nFHIRPathParser.T__3 = 4;\nFHIRPathParser.T__4 = 5;\nFHIRPathParser.T__5 = 6;\nFHIRPathParser.T__6 = 7;\nFHIRPathParser.T__7 = 8;\nFHIRPathParser.T__8 = 9;\nFHIRPathParser.T__9 = 10;\nFHIRPathParser.T__10 = 11;\nFHIRPathParser.T__11 = 12;\nFHIRPathParser.T__12 = 13;\nFHIRPathParser.T__13 = 14;\nFHIRPathParser.T__14 = 15;\nFHIRPathParser.T__15 = 16;\nFHIRPathParser.T__16 = 17;\nFHIRPathParser.T__17 = 18;\nFHIRPathParser.T__18 = 19;\nFHIRPathParser.T__19 = 20;\nFHIRPathParser.T__20 = 21;\nFHIRPathParser.T__21 = 22;\nFHIRPathParser.T__22 = 23;\nFHIRPathParser.T__23 = 24;\nFHIRPathParser.T__24 = 25;\nFHIRPathParser.T__25 = 26;\nFHIRPathParser.T__26 = 27;\nFHIRPathParser.T__27 = 28;\nFHIRPathParser.T__28 = 29;\nFHIRPathParser.T__29 = 30;\nFHIRPathParser.T__30 = 31;\nFHIRPathParser.T__31 = 32;\nFHIRPathParser.T__32 = 33;\nFHIRPathParser.T__33 = 34;\nFHIRPathParser.T__34 = 35;\nFHIRPathParser.T__35 = 36;\nFHIRPathParser.T__36 = 37;\nFHIRPathParser.T__37 = 38;\nFHIRPathParser.T__38 = 39;\nFHIRPathParser.T__39 = 40;\nFHIRPathParser.T__40 = 41;\nFHIRPathParser.T__41 = 42;\nFHIRPathParser.T__42 = 43;\nFHIRPathParser.T__43 = 44;\nFHIRPathParser.T__44 = 45;\nFHIRPathParser.T__45 = 46;\nFHIRPathParser.T__46 = 47;\nFHIRPathParser.T__47 = 48;\nFHIRPathParser.T__48 = 49;\nFHIRPathParser.T__49 = 50;\nFHIRPathParser.T__50 = 51;\nFHIRPathParser.T__51 = 52;\nFHIRPathParser.T__52 = 53;\nFHIRPathParser.T__53 = 54;\nFHIRPathParser.DATETIME = 55;\nFHIRPathParser.TIME = 56;\nFHIRPathParser.IDENTIFIER = 57;\nFHIRPathParser.DELIMITEDIDENTIFIER = 58;\nFHIRPathParser.STRING = 59;\nFHIRPathParser.NUMBER = 60;\nFHIRPathParser.WS = 61;\nFHIRPathParser.COMMENT = 62;\nFHIRPathParser.LINE_COMMENT = 63;\nFHIRPathParser.RULE_entireExpression = 0;\nFHIRPathParser.RULE_expression = 1;\nFHIRPathParser.RULE_term = 2;\nFHIRPathParser.RULE_literal = 3;\nFHIRPathParser.RULE_externalConstant = 4;\nFHIRPathParser.RULE_invocation = 5;\nFHIRPathParser.RULE_functn = 6;\nFHIRPathParser.RULE_paramList = 7;\nFHIRPathParser.RULE_quantity = 8;\nFHIRPathParser.RULE_unit = 9;\nFHIRPathParser.RULE_dateTimePrecision = 10;\nFHIRPathParser.RULE_pluralDateTimePrecision = 11;\nFHIRPathParser.RULE_typeSpecifier = 12;\nFHIRPathParser.RULE_qualifiedIdentifier = 13;\nFHIRPathParser.RULE_identifier = 14;\n\nfunction EntireExpressionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_entireExpression;\n  return this;\n}\n\nEntireExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nEntireExpressionContext.prototype.constructor = EntireExpressionContext;\n\nEntireExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nEntireExpressionContext.prototype.EOF = function () {\n  return this.getToken(FHIRPathParser.EOF, 0);\n};\n\nEntireExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterEntireExpression(this);\n  }\n};\n\nEntireExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitEntireExpression(this);\n  }\n};\n\nFHIRPathParser.EntireExpressionContext = EntireExpressionContext;\n\nFHIRPathParser.prototype.entireExpression = function () {\n  var localctx = new EntireExpressionContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 30;\n    this.expression(0);\n    this.state = 31;\n    this.match(FHIRPathParser.EOF);\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction ExpressionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_expression;\n  return this;\n}\n\nExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nExpressionContext.prototype.constructor = ExpressionContext;\n\nExpressionContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction IndexerExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nIndexerExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nIndexerExpressionContext.prototype.constructor = IndexerExpressionContext;\nFHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;\n\nIndexerExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nIndexerExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterIndexerExpression(this);\n  }\n};\n\nIndexerExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitIndexerExpression(this);\n  }\n};\n\nfunction PolarityExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nPolarityExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nPolarityExpressionContext.prototype.constructor = PolarityExpressionContext;\nFHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;\n\nPolarityExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nPolarityExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterPolarityExpression(this);\n  }\n};\n\nPolarityExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitPolarityExpression(this);\n  }\n};\n\nfunction AdditiveExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nAdditiveExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nAdditiveExpressionContext.prototype.constructor = AdditiveExpressionContext;\nFHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;\n\nAdditiveExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nAdditiveExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterAdditiveExpression(this);\n  }\n};\n\nAdditiveExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitAdditiveExpression(this);\n  }\n};\n\nfunction MultiplicativeExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nMultiplicativeExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nMultiplicativeExpressionContext.prototype.constructor = MultiplicativeExpressionContext;\nFHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;\n\nMultiplicativeExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nMultiplicativeExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterMultiplicativeExpression(this);\n  }\n};\n\nMultiplicativeExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitMultiplicativeExpression(this);\n  }\n};\n\nfunction UnionExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nUnionExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nUnionExpressionContext.prototype.constructor = UnionExpressionContext;\nFHIRPathParser.UnionExpressionContext = UnionExpressionContext;\n\nUnionExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nUnionExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterUnionExpression(this);\n  }\n};\n\nUnionExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitUnionExpression(this);\n  }\n};\n\nfunction OrExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nOrExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nOrExpressionContext.prototype.constructor = OrExpressionContext;\nFHIRPathParser.OrExpressionContext = OrExpressionContext;\n\nOrExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nOrExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterOrExpression(this);\n  }\n};\n\nOrExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitOrExpression(this);\n  }\n};\n\nfunction AndExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nAndExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nAndExpressionContext.prototype.constructor = AndExpressionContext;\nFHIRPathParser.AndExpressionContext = AndExpressionContext;\n\nAndExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nAndExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterAndExpression(this);\n  }\n};\n\nAndExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitAndExpression(this);\n  }\n};\n\nfunction MembershipExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nMembershipExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nMembershipExpressionContext.prototype.constructor = MembershipExpressionContext;\nFHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;\n\nMembershipExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nMembershipExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterMembershipExpression(this);\n  }\n};\n\nMembershipExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitMembershipExpression(this);\n  }\n};\n\nfunction InequalityExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nInequalityExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nInequalityExpressionContext.prototype.constructor = InequalityExpressionContext;\nFHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;\n\nInequalityExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nInequalityExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterInequalityExpression(this);\n  }\n};\n\nInequalityExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitInequalityExpression(this);\n  }\n};\n\nfunction InvocationExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nInvocationExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nInvocationExpressionContext.prototype.constructor = InvocationExpressionContext;\nFHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;\n\nInvocationExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nInvocationExpressionContext.prototype.invocation = function () {\n  return this.getTypedRuleContext(InvocationContext, 0);\n};\n\nInvocationExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterInvocationExpression(this);\n  }\n};\n\nInvocationExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitInvocationExpression(this);\n  }\n};\n\nfunction EqualityExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nEqualityExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nEqualityExpressionContext.prototype.constructor = EqualityExpressionContext;\nFHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;\n\nEqualityExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nEqualityExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterEqualityExpression(this);\n  }\n};\n\nEqualityExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitEqualityExpression(this);\n  }\n};\n\nfunction ImpliesExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nImpliesExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nImpliesExpressionContext.prototype.constructor = ImpliesExpressionContext;\nFHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;\n\nImpliesExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nImpliesExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterImpliesExpression(this);\n  }\n};\n\nImpliesExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitImpliesExpression(this);\n  }\n};\n\nfunction TermExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTermExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nTermExpressionContext.prototype.constructor = TermExpressionContext;\nFHIRPathParser.TermExpressionContext = TermExpressionContext;\n\nTermExpressionContext.prototype.term = function () {\n  return this.getTypedRuleContext(TermContext, 0);\n};\n\nTermExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTermExpression(this);\n  }\n};\n\nTermExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTermExpression(this);\n  }\n};\n\nfunction TypeExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTypeExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nTypeExpressionContext.prototype.constructor = TypeExpressionContext;\nFHIRPathParser.TypeExpressionContext = TypeExpressionContext;\n\nTypeExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nTypeExpressionContext.prototype.typeSpecifier = function () {\n  return this.getTypedRuleContext(TypeSpecifierContext, 0);\n};\n\nTypeExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTypeExpression(this);\n  }\n};\n\nTypeExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTypeExpression(this);\n  }\n};\n\nFHIRPathParser.prototype.expression = function (_p) {\n  if (_p === undefined) {\n    _p = 0;\n  }\n\n  var _parentctx = this._ctx;\n  var _parentState = this.state;\n  var localctx = new ExpressionContext(this, this._ctx, _parentState);\n  var _prevctx = localctx;\n  var _startState = 2;\n  this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 37;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__15:\n      case FHIRPathParser.T__16:\n      case FHIRPathParser.T__21:\n      case FHIRPathParser.T__22:\n      case FHIRPathParser.T__27:\n      case FHIRPathParser.T__29:\n      case FHIRPathParser.T__31:\n      case FHIRPathParser.T__32:\n      case FHIRPathParser.T__33:\n      case FHIRPathParser.T__34:\n      case FHIRPathParser.T__35:\n      case FHIRPathParser.T__36:\n      case FHIRPathParser.DATETIME:\n      case FHIRPathParser.TIME:\n      case FHIRPathParser.IDENTIFIER:\n      case FHIRPathParser.DELIMITEDIDENTIFIER:\n      case FHIRPathParser.STRING:\n      case FHIRPathParser.NUMBER:\n        localctx = new TermExpressionContext(this, localctx);\n        this._ctx = localctx;\n        _prevctx = localctx;\n        this.state = 34;\n        this.term();\n        break;\n\n      case FHIRPathParser.T__3:\n      case FHIRPathParser.T__4:\n        localctx = new PolarityExpressionContext(this, localctx);\n        this._ctx = localctx;\n        _prevctx = localctx;\n        this.state = 35;\n        _la = this._input.LA(1);\n\n        if (!(_la === FHIRPathParser.T__3 || _la === FHIRPathParser.T__4)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          this._errHandler.reportMatch(this);\n\n          this.consume();\n        }\n\n        this.state = 36;\n        this.expression(11);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n\n    this._ctx.stop = this._input.LT(-1);\n    this.state = 79;\n\n    this._errHandler.sync(this);\n\n    var _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);\n\n    while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n      if (_alt === 1) {\n        if (this._parseListeners !== null) {\n          this.triggerExitRuleEvent();\n        }\n\n        _prevctx = localctx;\n        this.state = 77;\n\n        this._errHandler.sync(this);\n\n        var la_ = this._interp.adaptivePredict(this._input, 1, this._ctx);\n\n        switch (la_) {\n          case 1:\n            localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 39;\n\n            if (!this.precpred(this._ctx, 10)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 10)\");\n            }\n\n            this.state = 40;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__5 | 1 << FHIRPathParser.T__6 | 1 << FHIRPathParser.T__7 | 1 << FHIRPathParser.T__8)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 41;\n            this.expression(11);\n            break;\n\n          case 2:\n            localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 42;\n\n            if (!this.precpred(this._ctx, 9)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 9)\");\n            }\n\n            this.state = 43;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__9)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 44;\n            this.expression(10);\n            break;\n\n          case 3:\n            localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 45;\n\n            if (!this.precpred(this._ctx, 8)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 8)\");\n            }\n\n            this.state = 46;\n            this.match(FHIRPathParser.T__10);\n            this.state = 47;\n            this.expression(9);\n            break;\n\n          case 4:\n            localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 48;\n\n            if (!this.precpred(this._ctx, 7)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 7)\");\n            }\n\n            this.state = 49;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__11 | 1 << FHIRPathParser.T__12 | 1 << FHIRPathParser.T__13 | 1 << FHIRPathParser.T__14)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 50;\n            this.expression(8);\n            break;\n\n          case 5:\n            localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 51;\n\n            if (!this.precpred(this._ctx, 5)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 5)\");\n            }\n\n            this.state = 52;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__17 | 1 << FHIRPathParser.T__18 | 1 << FHIRPathParser.T__19 | 1 << FHIRPathParser.T__20)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 53;\n            this.expression(6);\n            break;\n\n          case 6:\n            localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 54;\n\n            if (!this.precpred(this._ctx, 4)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 4)\");\n            }\n\n            this.state = 55;\n            _la = this._input.LA(1);\n\n            if (!(_la === FHIRPathParser.T__21 || _la === FHIRPathParser.T__22)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 56;\n            this.expression(5);\n            break;\n\n          case 7:\n            localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 57;\n\n            if (!this.precpred(this._ctx, 3)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 3)\");\n            }\n\n            this.state = 58;\n            this.match(FHIRPathParser.T__23);\n            this.state = 59;\n            this.expression(4);\n            break;\n\n          case 8:\n            localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 60;\n\n            if (!this.precpred(this._ctx, 2)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n            }\n\n            this.state = 61;\n            _la = this._input.LA(1);\n\n            if (!(_la === FHIRPathParser.T__24 || _la === FHIRPathParser.T__25)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 62;\n            this.expression(3);\n            break;\n\n          case 9:\n            localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 63;\n\n            if (!this.precpred(this._ctx, 1)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n            }\n\n            this.state = 64;\n            this.match(FHIRPathParser.T__26);\n            this.state = 65;\n            this.expression(2);\n            break;\n\n          case 10:\n            localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 66;\n\n            if (!this.precpred(this._ctx, 13)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 13)\");\n            }\n\n            this.state = 67;\n            this.match(FHIRPathParser.T__0);\n            this.state = 68;\n            this.invocation();\n            break;\n\n          case 11:\n            localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 69;\n\n            if (!this.precpred(this._ctx, 12)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 12)\");\n            }\n\n            this.state = 70;\n            this.match(FHIRPathParser.T__1);\n            this.state = 71;\n            this.expression(0);\n            this.state = 72;\n            this.match(FHIRPathParser.T__2);\n            break;\n\n          case 12:\n            localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 74;\n\n            if (!this.precpred(this._ctx, 6)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 6)\");\n            }\n\n            this.state = 75;\n            _la = this._input.LA(1);\n\n            if (!(_la === FHIRPathParser.T__15 || _la === FHIRPathParser.T__16)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 76;\n            this.typeSpecifier();\n            break;\n        }\n      }\n\n      this.state = 81;\n\n      this._errHandler.sync(this);\n\n      _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);\n    }\n  } catch (error) {\n    if (error instanceof antlr4.error.RecognitionException) {\n      localctx.exception = error;\n\n      this._errHandler.reportError(this, error);\n\n      this._errHandler.recover(this, error);\n    } else {\n      throw error;\n    }\n  } finally {\n    this.unrollRecursionContexts(_parentctx);\n  }\n\n  return localctx;\n};\n\nfunction TermContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_term;\n  return this;\n}\n\nTermContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nTermContext.prototype.constructor = TermContext;\n\nTermContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction ExternalConstantTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nExternalConstantTermContext.prototype = Object.create(TermContext.prototype);\nExternalConstantTermContext.prototype.constructor = ExternalConstantTermContext;\nFHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;\n\nExternalConstantTermContext.prototype.externalConstant = function () {\n  return this.getTypedRuleContext(ExternalConstantContext, 0);\n};\n\nExternalConstantTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterExternalConstantTerm(this);\n  }\n};\n\nExternalConstantTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitExternalConstantTerm(this);\n  }\n};\n\nfunction LiteralTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nLiteralTermContext.prototype = Object.create(TermContext.prototype);\nLiteralTermContext.prototype.constructor = LiteralTermContext;\nFHIRPathParser.LiteralTermContext = LiteralTermContext;\n\nLiteralTermContext.prototype.literal = function () {\n  return this.getTypedRuleContext(LiteralContext, 0);\n};\n\nLiteralTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterLiteralTerm(this);\n  }\n};\n\nLiteralTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitLiteralTerm(this);\n  }\n};\n\nfunction ParenthesizedTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nParenthesizedTermContext.prototype = Object.create(TermContext.prototype);\nParenthesizedTermContext.prototype.constructor = ParenthesizedTermContext;\nFHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;\n\nParenthesizedTermContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nParenthesizedTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterParenthesizedTerm(this);\n  }\n};\n\nParenthesizedTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitParenthesizedTerm(this);\n  }\n};\n\nfunction InvocationTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nInvocationTermContext.prototype = Object.create(TermContext.prototype);\nInvocationTermContext.prototype.constructor = InvocationTermContext;\nFHIRPathParser.InvocationTermContext = InvocationTermContext;\n\nInvocationTermContext.prototype.invocation = function () {\n  return this.getTypedRuleContext(InvocationContext, 0);\n};\n\nInvocationTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterInvocationTerm(this);\n  }\n};\n\nInvocationTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitInvocationTerm(this);\n  }\n};\n\nFHIRPathParser.TermContext = TermContext;\n\nFHIRPathParser.prototype.term = function () {\n  var localctx = new TermContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 4, FHIRPathParser.RULE_term);\n\n  try {\n    this.state = 89;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__15:\n      case FHIRPathParser.T__16:\n      case FHIRPathParser.T__21:\n      case FHIRPathParser.T__22:\n      case FHIRPathParser.T__34:\n      case FHIRPathParser.T__35:\n      case FHIRPathParser.T__36:\n      case FHIRPathParser.IDENTIFIER:\n      case FHIRPathParser.DELIMITEDIDENTIFIER:\n        localctx = new InvocationTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 1);\n        this.state = 82;\n        this.invocation();\n        break;\n\n      case FHIRPathParser.T__29:\n      case FHIRPathParser.T__31:\n      case FHIRPathParser.T__32:\n      case FHIRPathParser.DATETIME:\n      case FHIRPathParser.TIME:\n      case FHIRPathParser.STRING:\n      case FHIRPathParser.NUMBER:\n        localctx = new LiteralTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 2);\n        this.state = 83;\n        this.literal();\n        break;\n\n      case FHIRPathParser.T__33:\n        localctx = new ExternalConstantTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 3);\n        this.state = 84;\n        this.externalConstant();\n        break;\n\n      case FHIRPathParser.T__27:\n        localctx = new ParenthesizedTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 4);\n        this.state = 85;\n        this.match(FHIRPathParser.T__27);\n        this.state = 86;\n        this.expression(0);\n        this.state = 87;\n        this.match(FHIRPathParser.T__28);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction LiteralContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_literal;\n  return this;\n}\n\nLiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nLiteralContext.prototype.constructor = LiteralContext;\n\nLiteralContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction TimeLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTimeLiteralContext.prototype = Object.create(LiteralContext.prototype);\nTimeLiteralContext.prototype.constructor = TimeLiteralContext;\nFHIRPathParser.TimeLiteralContext = TimeLiteralContext;\n\nTimeLiteralContext.prototype.TIME = function () {\n  return this.getToken(FHIRPathParser.TIME, 0);\n};\n\nTimeLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTimeLiteral(this);\n  }\n};\n\nTimeLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTimeLiteral(this);\n  }\n};\n\nfunction NullLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nNullLiteralContext.prototype = Object.create(LiteralContext.prototype);\nNullLiteralContext.prototype.constructor = NullLiteralContext;\nFHIRPathParser.NullLiteralContext = NullLiteralContext;\n\nNullLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterNullLiteral(this);\n  }\n};\n\nNullLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitNullLiteral(this);\n  }\n};\n\nfunction DateTimeLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nDateTimeLiteralContext.prototype = Object.create(LiteralContext.prototype);\nDateTimeLiteralContext.prototype.constructor = DateTimeLiteralContext;\nFHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;\n\nDateTimeLiteralContext.prototype.DATETIME = function () {\n  return this.getToken(FHIRPathParser.DATETIME, 0);\n};\n\nDateTimeLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterDateTimeLiteral(this);\n  }\n};\n\nDateTimeLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitDateTimeLiteral(this);\n  }\n};\n\nfunction StringLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nStringLiteralContext.prototype = Object.create(LiteralContext.prototype);\nStringLiteralContext.prototype.constructor = StringLiteralContext;\nFHIRPathParser.StringLiteralContext = StringLiteralContext;\n\nStringLiteralContext.prototype.STRING = function () {\n  return this.getToken(FHIRPathParser.STRING, 0);\n};\n\nStringLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterStringLiteral(this);\n  }\n};\n\nStringLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitStringLiteral(this);\n  }\n};\n\nfunction BooleanLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nBooleanLiteralContext.prototype = Object.create(LiteralContext.prototype);\nBooleanLiteralContext.prototype.constructor = BooleanLiteralContext;\nFHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;\n\nBooleanLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterBooleanLiteral(this);\n  }\n};\n\nBooleanLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitBooleanLiteral(this);\n  }\n};\n\nfunction NumberLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nNumberLiteralContext.prototype = Object.create(LiteralContext.prototype);\nNumberLiteralContext.prototype.constructor = NumberLiteralContext;\nFHIRPathParser.NumberLiteralContext = NumberLiteralContext;\n\nNumberLiteralContext.prototype.NUMBER = function () {\n  return this.getToken(FHIRPathParser.NUMBER, 0);\n};\n\nNumberLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterNumberLiteral(this);\n  }\n};\n\nNumberLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitNumberLiteral(this);\n  }\n};\n\nfunction QuantityLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nQuantityLiteralContext.prototype = Object.create(LiteralContext.prototype);\nQuantityLiteralContext.prototype.constructor = QuantityLiteralContext;\nFHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;\n\nQuantityLiteralContext.prototype.quantity = function () {\n  return this.getTypedRuleContext(QuantityContext, 0);\n};\n\nQuantityLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterQuantityLiteral(this);\n  }\n};\n\nQuantityLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitQuantityLiteral(this);\n  }\n};\n\nFHIRPathParser.LiteralContext = LiteralContext;\n\nFHIRPathParser.prototype.literal = function () {\n  var localctx = new LiteralContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);\n  var _la = 0; // Token type\n\n  try {\n    this.state = 99;\n\n    this._errHandler.sync(this);\n\n    var la_ = this._interp.adaptivePredict(this._input, 4, this._ctx);\n\n    switch (la_) {\n      case 1:\n        localctx = new NullLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 1);\n        this.state = 91;\n        this.match(FHIRPathParser.T__29);\n        this.state = 92;\n        this.match(FHIRPathParser.T__30);\n        break;\n\n      case 2:\n        localctx = new BooleanLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 2);\n        this.state = 93;\n        _la = this._input.LA(1);\n\n        if (!(_la === FHIRPathParser.T__31 || _la === FHIRPathParser.T__32)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          this._errHandler.reportMatch(this);\n\n          this.consume();\n        }\n\n        break;\n\n      case 3:\n        localctx = new StringLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 3);\n        this.state = 94;\n        this.match(FHIRPathParser.STRING);\n        break;\n\n      case 4:\n        localctx = new NumberLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 4);\n        this.state = 95;\n        this.match(FHIRPathParser.NUMBER);\n        break;\n\n      case 5:\n        localctx = new DateTimeLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 5);\n        this.state = 96;\n        this.match(FHIRPathParser.DATETIME);\n        break;\n\n      case 6:\n        localctx = new TimeLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 6);\n        this.state = 97;\n        this.match(FHIRPathParser.TIME);\n        break;\n\n      case 7:\n        localctx = new QuantityLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 7);\n        this.state = 98;\n        this.quantity();\n        break;\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction ExternalConstantContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_externalConstant;\n  return this;\n}\n\nExternalConstantContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nExternalConstantContext.prototype.constructor = ExternalConstantContext;\n\nExternalConstantContext.prototype.identifier = function () {\n  return this.getTypedRuleContext(IdentifierContext, 0);\n};\n\nExternalConstantContext.prototype.STRING = function () {\n  return this.getToken(FHIRPathParser.STRING, 0);\n};\n\nExternalConstantContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterExternalConstant(this);\n  }\n};\n\nExternalConstantContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitExternalConstant(this);\n  }\n};\n\nFHIRPathParser.ExternalConstantContext = ExternalConstantContext;\n\nFHIRPathParser.prototype.externalConstant = function () {\n  var localctx = new ExternalConstantContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 101;\n    this.match(FHIRPathParser.T__33);\n    this.state = 104;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__15:\n      case FHIRPathParser.T__16:\n      case FHIRPathParser.T__21:\n      case FHIRPathParser.T__22:\n      case FHIRPathParser.IDENTIFIER:\n      case FHIRPathParser.DELIMITEDIDENTIFIER:\n        this.state = 102;\n        this.identifier();\n        break;\n\n      case FHIRPathParser.STRING:\n        this.state = 103;\n        this.match(FHIRPathParser.STRING);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction InvocationContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_invocation;\n  return this;\n}\n\nInvocationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nInvocationContext.prototype.constructor = InvocationContext;\n\nInvocationContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction TotalInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTotalInvocationContext.prototype = Object.create(InvocationContext.prototype);\nTotalInvocationContext.prototype.constructor = TotalInvocationContext;\nFHIRPathParser.TotalInvocationContext = TotalInvocationContext;\n\nTotalInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTotalInvocation(this);\n  }\n};\n\nTotalInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTotalInvocation(this);\n  }\n};\n\nfunction ThisInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nThisInvocationContext.prototype = Object.create(InvocationContext.prototype);\nThisInvocationContext.prototype.constructor = ThisInvocationContext;\nFHIRPathParser.ThisInvocationContext = ThisInvocationContext;\n\nThisInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterThisInvocation(this);\n  }\n};\n\nThisInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitThisInvocation(this);\n  }\n};\n\nfunction IndexInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nIndexInvocationContext.prototype = Object.create(InvocationContext.prototype);\nIndexInvocationContext.prototype.constructor = IndexInvocationContext;\nFHIRPathParser.IndexInvocationContext = IndexInvocationContext;\n\nIndexInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterIndexInvocation(this);\n  }\n};\n\nIndexInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitIndexInvocation(this);\n  }\n};\n\nfunction FunctionInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nFunctionInvocationContext.prototype = Object.create(InvocationContext.prototype);\nFunctionInvocationContext.prototype.constructor = FunctionInvocationContext;\nFHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;\n\nFunctionInvocationContext.prototype.functn = function () {\n  return this.getTypedRuleContext(FunctnContext, 0);\n};\n\nFunctionInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterFunctionInvocation(this);\n  }\n};\n\nFunctionInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitFunctionInvocation(this);\n  }\n};\n\nfunction MemberInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nMemberInvocationContext.prototype = Object.create(InvocationContext.prototype);\nMemberInvocationContext.prototype.constructor = MemberInvocationContext;\nFHIRPathParser.MemberInvocationContext = MemberInvocationContext;\n\nMemberInvocationContext.prototype.identifier = function () {\n  return this.getTypedRuleContext(IdentifierContext, 0);\n};\n\nMemberInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterMemberInvocation(this);\n  }\n};\n\nMemberInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitMemberInvocation(this);\n  }\n};\n\nFHIRPathParser.InvocationContext = InvocationContext;\n\nFHIRPathParser.prototype.invocation = function () {\n  var localctx = new InvocationContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);\n\n  try {\n    this.state = 111;\n\n    this._errHandler.sync(this);\n\n    var la_ = this._interp.adaptivePredict(this._input, 6, this._ctx);\n\n    switch (la_) {\n      case 1:\n        localctx = new MemberInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 1);\n        this.state = 106;\n        this.identifier();\n        break;\n\n      case 2:\n        localctx = new FunctionInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 2);\n        this.state = 107;\n        this.functn();\n        break;\n\n      case 3:\n        localctx = new ThisInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 3);\n        this.state = 108;\n        this.match(FHIRPathParser.T__34);\n        break;\n\n      case 4:\n        localctx = new IndexInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 4);\n        this.state = 109;\n        this.match(FHIRPathParser.T__35);\n        break;\n\n      case 5:\n        localctx = new TotalInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 5);\n        this.state = 110;\n        this.match(FHIRPathParser.T__36);\n        break;\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction FunctnContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_functn;\n  return this;\n}\n\nFunctnContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nFunctnContext.prototype.constructor = FunctnContext;\n\nFunctnContext.prototype.identifier = function () {\n  return this.getTypedRuleContext(IdentifierContext, 0);\n};\n\nFunctnContext.prototype.paramList = function () {\n  return this.getTypedRuleContext(ParamListContext, 0);\n};\n\nFunctnContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterFunctn(this);\n  }\n};\n\nFunctnContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitFunctn(this);\n  }\n};\n\nFHIRPathParser.FunctnContext = FunctnContext;\n\nFHIRPathParser.prototype.functn = function () {\n  var localctx = new FunctnContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 113;\n    this.identifier();\n    this.state = 114;\n    this.match(FHIRPathParser.T__27);\n    this.state = 116;\n\n    this._errHandler.sync(this);\n\n    _la = this._input.LA(1);\n\n    if ((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22 | 1 << FHIRPathParser.T__27 | 1 << FHIRPathParser.T__29)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << FHIRPathParser.T__31 - 32 | 1 << FHIRPathParser.T__32 - 32 | 1 << FHIRPathParser.T__33 - 32 | 1 << FHIRPathParser.T__34 - 32 | 1 << FHIRPathParser.T__35 - 32 | 1 << FHIRPathParser.T__36 - 32 | 1 << FHIRPathParser.DATETIME - 32 | 1 << FHIRPathParser.TIME - 32 | 1 << FHIRPathParser.IDENTIFIER - 32 | 1 << FHIRPathParser.DELIMITEDIDENTIFIER - 32 | 1 << FHIRPathParser.STRING - 32 | 1 << FHIRPathParser.NUMBER - 32)) !== 0) {\n      this.state = 115;\n      this.paramList();\n    }\n\n    this.state = 118;\n    this.match(FHIRPathParser.T__28);\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction ParamListContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_paramList;\n  return this;\n}\n\nParamListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nParamListContext.prototype.constructor = ParamListContext;\n\nParamListContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nParamListContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterParamList(this);\n  }\n};\n\nParamListContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitParamList(this);\n  }\n};\n\nFHIRPathParser.ParamListContext = ParamListContext;\n\nFHIRPathParser.prototype.paramList = function () {\n  var localctx = new ParamListContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 120;\n    this.expression(0);\n    this.state = 125;\n\n    this._errHandler.sync(this);\n\n    _la = this._input.LA(1);\n\n    while (_la === FHIRPathParser.T__37) {\n      this.state = 121;\n      this.match(FHIRPathParser.T__37);\n      this.state = 122;\n      this.expression(0);\n      this.state = 127;\n\n      this._errHandler.sync(this);\n\n      _la = this._input.LA(1);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction QuantityContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_quantity;\n  return this;\n}\n\nQuantityContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nQuantityContext.prototype.constructor = QuantityContext;\n\nQuantityContext.prototype.NUMBER = function () {\n  return this.getToken(FHIRPathParser.NUMBER, 0);\n};\n\nQuantityContext.prototype.unit = function () {\n  return this.getTypedRuleContext(UnitContext, 0);\n};\n\nQuantityContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterQuantity(this);\n  }\n};\n\nQuantityContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitQuantity(this);\n  }\n};\n\nFHIRPathParser.QuantityContext = QuantityContext;\n\nFHIRPathParser.prototype.quantity = function () {\n  var localctx = new QuantityContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 128;\n    this.match(FHIRPathParser.NUMBER);\n    this.state = 130;\n\n    this._errHandler.sync(this);\n\n    var la_ = this._interp.adaptivePredict(this._input, 9, this._ctx);\n\n    if (la_ === 1) {\n      this.state = 129;\n      this.unit();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction UnitContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_unit;\n  return this;\n}\n\nUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nUnitContext.prototype.constructor = UnitContext;\n\nUnitContext.prototype.dateTimePrecision = function () {\n  return this.getTypedRuleContext(DateTimePrecisionContext, 0);\n};\n\nUnitContext.prototype.pluralDateTimePrecision = function () {\n  return this.getTypedRuleContext(PluralDateTimePrecisionContext, 0);\n};\n\nUnitContext.prototype.STRING = function () {\n  return this.getToken(FHIRPathParser.STRING, 0);\n};\n\nUnitContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterUnit(this);\n  }\n};\n\nUnitContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitUnit(this);\n  }\n};\n\nFHIRPathParser.UnitContext = UnitContext;\n\nFHIRPathParser.prototype.unit = function () {\n  var localctx = new UnitContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);\n\n  try {\n    this.state = 135;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__38:\n      case FHIRPathParser.T__39:\n      case FHIRPathParser.T__40:\n      case FHIRPathParser.T__41:\n      case FHIRPathParser.T__42:\n      case FHIRPathParser.T__43:\n      case FHIRPathParser.T__44:\n      case FHIRPathParser.T__45:\n        this.enterOuterAlt(localctx, 1);\n        this.state = 132;\n        this.dateTimePrecision();\n        break;\n\n      case FHIRPathParser.T__46:\n      case FHIRPathParser.T__47:\n      case FHIRPathParser.T__48:\n      case FHIRPathParser.T__49:\n      case FHIRPathParser.T__50:\n      case FHIRPathParser.T__51:\n      case FHIRPathParser.T__52:\n      case FHIRPathParser.T__53:\n        this.enterOuterAlt(localctx, 2);\n        this.state = 133;\n        this.pluralDateTimePrecision();\n        break;\n\n      case FHIRPathParser.STRING:\n        this.enterOuterAlt(localctx, 3);\n        this.state = 134;\n        this.match(FHIRPathParser.STRING);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction DateTimePrecisionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;\n  return this;\n}\n\nDateTimePrecisionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nDateTimePrecisionContext.prototype.constructor = DateTimePrecisionContext;\n\nDateTimePrecisionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterDateTimePrecision(this);\n  }\n};\n\nDateTimePrecisionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitDateTimePrecision(this);\n  }\n};\n\nFHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext;\n\nFHIRPathParser.prototype.dateTimePrecision = function () {\n  var localctx = new DateTimePrecisionContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 137;\n    _la = this._input.LA(1);\n\n    if (!((_la - 39 & ~0x1f) == 0 && (1 << _la - 39 & (1 << FHIRPathParser.T__38 - 39 | 1 << FHIRPathParser.T__39 - 39 | 1 << FHIRPathParser.T__40 - 39 | 1 << FHIRPathParser.T__41 - 39 | 1 << FHIRPathParser.T__42 - 39 | 1 << FHIRPathParser.T__43 - 39 | 1 << FHIRPathParser.T__44 - 39 | 1 << FHIRPathParser.T__45 - 39)) !== 0)) {\n      this._errHandler.recoverInline(this);\n    } else {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction PluralDateTimePrecisionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;\n  return this;\n}\n\nPluralDateTimePrecisionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nPluralDateTimePrecisionContext.prototype.constructor = PluralDateTimePrecisionContext;\n\nPluralDateTimePrecisionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterPluralDateTimePrecision(this);\n  }\n};\n\nPluralDateTimePrecisionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitPluralDateTimePrecision(this);\n  }\n};\n\nFHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext;\n\nFHIRPathParser.prototype.pluralDateTimePrecision = function () {\n  var localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 139;\n    _la = this._input.LA(1);\n\n    if (!((_la - 47 & ~0x1f) == 0 && (1 << _la - 47 & (1 << FHIRPathParser.T__46 - 47 | 1 << FHIRPathParser.T__47 - 47 | 1 << FHIRPathParser.T__48 - 47 | 1 << FHIRPathParser.T__49 - 47 | 1 << FHIRPathParser.T__50 - 47 | 1 << FHIRPathParser.T__51 - 47 | 1 << FHIRPathParser.T__52 - 47 | 1 << FHIRPathParser.T__53 - 47)) !== 0)) {\n      this._errHandler.recoverInline(this);\n    } else {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction TypeSpecifierContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;\n  return this;\n}\n\nTypeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nTypeSpecifierContext.prototype.constructor = TypeSpecifierContext;\n\nTypeSpecifierContext.prototype.qualifiedIdentifier = function () {\n  return this.getTypedRuleContext(QualifiedIdentifierContext, 0);\n};\n\nTypeSpecifierContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTypeSpecifier(this);\n  }\n};\n\nTypeSpecifierContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTypeSpecifier(this);\n  }\n};\n\nFHIRPathParser.TypeSpecifierContext = TypeSpecifierContext;\n\nFHIRPathParser.prototype.typeSpecifier = function () {\n  var localctx = new TypeSpecifierContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 141;\n    this.qualifiedIdentifier();\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction QualifiedIdentifierContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;\n  return this;\n}\n\nQualifiedIdentifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nQualifiedIdentifierContext.prototype.constructor = QualifiedIdentifierContext;\n\nQualifiedIdentifierContext.prototype.identifier = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(IdentifierContext);\n  } else {\n    return this.getTypedRuleContext(IdentifierContext, i);\n  }\n};\n\nQualifiedIdentifierContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterQualifiedIdentifier(this);\n  }\n};\n\nQualifiedIdentifierContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitQualifiedIdentifier(this);\n  }\n};\n\nFHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext;\n\nFHIRPathParser.prototype.qualifiedIdentifier = function () {\n  var localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 143;\n    this.identifier();\n    this.state = 148;\n\n    this._errHandler.sync(this);\n\n    var _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);\n\n    while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n      if (_alt === 1) {\n        this.state = 144;\n        this.match(FHIRPathParser.T__0);\n        this.state = 145;\n        this.identifier();\n      }\n\n      this.state = 150;\n\n      this._errHandler.sync(this);\n\n      _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction IdentifierContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_identifier;\n  return this;\n}\n\nIdentifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nIdentifierContext.prototype.constructor = IdentifierContext;\n\nIdentifierContext.prototype.IDENTIFIER = function () {\n  return this.getToken(FHIRPathParser.IDENTIFIER, 0);\n};\n\nIdentifierContext.prototype.DELIMITEDIDENTIFIER = function () {\n  return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);\n};\n\nIdentifierContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterIdentifier(this);\n  }\n};\n\nIdentifierContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitIdentifier(this);\n  }\n};\n\nFHIRPathParser.IdentifierContext = IdentifierContext;\n\nFHIRPathParser.prototype.identifier = function () {\n  var localctx = new IdentifierContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 151;\n    _la = this._input.LA(1);\n\n    if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22)) !== 0 || _la === FHIRPathParser.IDENTIFIER || _la === FHIRPathParser.DELIMITEDIDENTIFIER)) {\n      this._errHandler.recoverInline(this);\n    } else {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nFHIRPathParser.prototype.sempred = function (localctx, ruleIndex, predIndex) {\n  switch (ruleIndex) {\n    case 1:\n      return this.expression_sempred(localctx, predIndex);\n\n    default:\n      throw \"No predicate with index:\" + ruleIndex;\n  }\n};\n\nFHIRPathParser.prototype.expression_sempred = function (localctx, predIndex) {\n  switch (predIndex) {\n    case 0:\n      return this.precpred(this._ctx, 10);\n\n    case 1:\n      return this.precpred(this._ctx, 9);\n\n    case 2:\n      return this.precpred(this._ctx, 8);\n\n    case 3:\n      return this.precpred(this._ctx, 7);\n\n    case 4:\n      return this.precpred(this._ctx, 5);\n\n    case 5:\n      return this.precpred(this._ctx, 4);\n\n    case 6:\n      return this.precpred(this._ctx, 3);\n\n    case 7:\n      return this.precpred(this._ctx, 2);\n\n    case 8:\n      return this.precpred(this._ctx, 1);\n\n    case 9:\n      return this.precpred(this._ctx, 13);\n\n    case 10:\n      return this.precpred(this._ctx, 12);\n\n    case 11:\n      return this.precpred(this._ctx, 6);\n\n    default:\n      throw \"No predicate with index:\" + predIndex;\n  }\n};\n\nexports.FHIRPathParser = FHIRPathParser;","map":null,"metadata":{},"sourceType":"script"}