{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n// The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n//  3 kinds of errors: prediction errors, failed predicate errors, and\n//  mismatched input errors. In each case, the parser knows where it is\n//  in the input, where it is in the ATN, the rule invocation stack,\n//  and what kind of problem occurred.\nvar PredicateTransition = require('./../atn/Transition').PredicateTransition;\n\nfunction RecognitionException(params) {\n  Error.call(this);\n\n  if (!!Error.captureStackTrace) {\n    Error.captureStackTrace(this, RecognitionException);\n  } else {\n    var stack = new Error().stack;\n  }\n\n  this.message = params.message;\n  this.recognizer = params.recognizer;\n  this.input = params.input;\n  this.ctx = params.ctx; // The current {@link Token} when an error occurred. Since not all streams\n  // support accessing symbols by index, we have to track the {@link Token}\n  // instance itself.\n\n  this.offendingToken = null; // Get the ATN state number the parser was in at the time the error\n  // occurred. For {@link NoViableAltException} and\n  // {@link LexerNoViableAltException} exceptions, this is the\n  // {@link DecisionState} number. For others, it is the state whose outgoing\n  // edge we couldn't match.\n\n  this.offendingState = -1;\n\n  if (this.recognizer !== null) {\n    this.offendingState = this.recognizer.state;\n  }\n\n  return this;\n}\n\nRecognitionException.prototype = Object.create(Error.prototype);\nRecognitionException.prototype.constructor = RecognitionException; // <p>If the state number is not known, this method returns -1.</p>\n//\n// Gets the set of input symbols which could potentially follow the\n// previously matched symbol at the time this exception was thrown.\n//\n// <p>If the set of expected tokens is not known and could not be computed,\n// this method returns {@code null}.</p>\n//\n// @return The set of token types that could potentially follow the current\n// state in the ATN, or {@code null} if the information is not available.\n// /\n\nRecognitionException.prototype.getExpectedTokens = function () {\n  if (this.recognizer !== null) {\n    return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n  } else {\n    return null;\n  }\n};\n\nRecognitionException.prototype.toString = function () {\n  return this.message;\n};\n\nfunction LexerNoViableAltException(lexer, input, startIndex, deadEndConfigs) {\n  RecognitionException.call(this, {\n    message: \"\",\n    recognizer: lexer,\n    input: input,\n    ctx: null\n  });\n  this.startIndex = startIndex;\n  this.deadEndConfigs = deadEndConfigs;\n  return this;\n}\n\nLexerNoViableAltException.prototype = Object.create(RecognitionException.prototype);\nLexerNoViableAltException.prototype.constructor = LexerNoViableAltException;\n\nLexerNoViableAltException.prototype.toString = function () {\n  var symbol = \"\";\n\n  if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n    symbol = this.input.getText((this.startIndex, this.startIndex));\n  }\n\n  return \"LexerNoViableAltException\" + symbol;\n}; // Indicates that the parser could not decide which of two or more paths\n// to take based upon the remaining input. It tracks the starting token\n// of the offending input and also knows where the parser was\n// in the various paths when the error. Reported by reportNoViableAlternative()\n//\n\n\nfunction NoViableAltException(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n  ctx = ctx || recognizer._ctx;\n  offendingToken = offendingToken || recognizer.getCurrentToken();\n  startToken = startToken || recognizer.getCurrentToken();\n  input = input || recognizer.getInputStream();\n  RecognitionException.call(this, {\n    message: \"\",\n    recognizer: recognizer,\n    input: input,\n    ctx: ctx\n  }); // Which configurations did we try at input.index() that couldn't match\n  // input.LT(1)?//\n\n  this.deadEndConfigs = deadEndConfigs; // The token object at the start index; the input stream might\n  // not be buffering tokens so get a reference to it. (At the\n  // time the error occurred, of course the stream needs to keep a\n  // buffer all of the tokens but later we might not have access to those.)\n\n  this.startToken = startToken;\n  this.offendingToken = offendingToken;\n}\n\nNoViableAltException.prototype = Object.create(RecognitionException.prototype);\nNoViableAltException.prototype.constructor = NoViableAltException; // This signifies any kind of mismatched input exceptions such as\n// when the current input does not match the expected token.\n//\n\nfunction InputMismatchException(recognizer) {\n  RecognitionException.call(this, {\n    message: \"\",\n    recognizer: recognizer,\n    input: recognizer.getInputStream(),\n    ctx: recognizer._ctx\n  });\n  this.offendingToken = recognizer.getCurrentToken();\n}\n\nInputMismatchException.prototype = Object.create(RecognitionException.prototype);\nInputMismatchException.prototype.constructor = InputMismatchException; // A semantic predicate failed during validation. Validation of predicates\n// occurs when normally parsing the alternative just like matching a token.\n// Disambiguating predicate evaluation occurs when we test a predicate during\n// prediction.\n\nfunction FailedPredicateException(recognizer, predicate, message) {\n  RecognitionException.call(this, {\n    message: this.formatMessage(predicate, message || null),\n    recognizer: recognizer,\n    input: recognizer.getInputStream(),\n    ctx: recognizer._ctx\n  });\n  var s = recognizer._interp.atn.states[recognizer.state];\n  var trans = s.transitions[0];\n\n  if (trans instanceof PredicateTransition) {\n    this.ruleIndex = trans.ruleIndex;\n    this.predicateIndex = trans.predIndex;\n  } else {\n    this.ruleIndex = 0;\n    this.predicateIndex = 0;\n  }\n\n  this.predicate = predicate;\n  this.offendingToken = recognizer.getCurrentToken();\n  return this;\n}\n\nFailedPredicateException.prototype = Object.create(RecognitionException.prototype);\nFailedPredicateException.prototype.constructor = FailedPredicateException;\n\nFailedPredicateException.prototype.formatMessage = function (predicate, message) {\n  if (message !== null) {\n    return message;\n  } else {\n    return \"failed predicate: {\" + predicate + \"}?\";\n  }\n};\n\nfunction ParseCancellationException() {\n  Error.call(this);\n  Error.captureStackTrace(this, ParseCancellationException);\n  return this;\n}\n\nParseCancellationException.prototype = Object.create(Error.prototype);\nParseCancellationException.prototype.constructor = ParseCancellationException;\nexports.RecognitionException = RecognitionException;\nexports.NoViableAltException = NoViableAltException;\nexports.LexerNoViableAltException = LexerNoViableAltException;\nexports.InputMismatchException = InputMismatchException;\nexports.FailedPredicateException = FailedPredicateException;\nexports.ParseCancellationException = ParseCancellationException;","map":null,"metadata":{},"sourceType":"script"}