{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n//\n// The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n//\n// <p>\n// The basic complexity of the adaptive strategy makes it harder to understand.\n// We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n// requests go through the DFA first. If they reach a state without an edge for\n// the current symbol, the algorithm fails over to the ATN simulation to\n// complete the DFA path for the current input (until it finds a conflict state\n// or uniquely predicting state).</p>\n//\n// <p>\n// All of that is done without using the outer context because we want to create\n// a DFA that is not dependent upon the rule invocation stack when we do a\n// prediction. One DFA works in all contexts. We avoid using context not\n// necessarily because it's slower, although it can be, but because of the DFA\n// caching problem. The closure routine only considers the rule invocation stack\n// created during prediction beginning in the decision rule. For example, if\n// prediction occurs without invoking another rule's ATN, there are no context\n// stacks in the configurations. When lack of context leads to a conflict, we\n// don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n// strategy (versus full LL(*)).</p>\n//\n// <p>\n// When SLL yields a configuration set with conflict, we rewind the input and\n// retry the ATN simulation, this time using full outer context without adding\n// to the DFA. Configuration context stacks will be the full invocation stacks\n// from the start rule. If we get a conflict using full context, then we can\n// definitively say we have a true ambiguity for that input sequence. If we\n// don't get a conflict, it implies that the decision is sensitive to the outer\n// context. (It is not context-sensitive in the sense of context-sensitive\n// grammars.)</p>\n//\n// <p>\n// The next time we reach this DFA state with an SLL conflict, through DFA\n// simulation, we will again retry the ATN simulation using full context mode.\n// This is slow because we can't save the results and have to \"interpret\" the\n// ATN each time we get that input.</p>\n//\n// <p>\n// <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n//\n// <p>\n// We could cache results from full context to predicted alternative easily and\n// that saves a lot of time but doesn't work in presence of predicates. The set\n// of visible predicates from the ATN start state changes depending on the\n// context, because closure can fall off the end of a rule. I tried to cache\n// tuples (stack context, semantic context, predicted alt) but it was slower\n// than interpreting and much more complicated. Also required a huge amount of\n// memory. The goal is not to create the world's fastest parser anyway. I'd like\n// to keep this algorithm simple. By launching multiple threads, we can improve\n// the speed of parsing across a large number of files.</p>\n//\n// <p>\n// There is no strict ordering between the amount of input used by SLL vs LL,\n// which makes it really hard to build a cache for full context. Let's say that\n// we have input A B C that leads to an SLL conflict with full context X. That\n// implies that using X we might only use A B but we could also use A B C D to\n// resolve conflict. Input A B C D could predict alternative 1 in one position\n// in the input and A B C E could predict alternative 2 in another position in\n// input. The conflicting SLL configurations could still be non-unique in the\n// full context prediction, which would lead us to requiring more input than the\n// original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n// input\tused during the previous prediction. That amounts to a cache that maps\n// X to a specific DFA for that context.</p>\n//\n// <p>\n// Something should be done for left-recursive expression predictions. They are\n// likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n// with full LL thing Sam does.</p>\n//\n// <p>\n// <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n//\n// <p>\n// We avoid doing full context retry when the outer context is empty, we did not\n// dip into the outer context by falling off the end of the decision state rule,\n// or when we force SLL mode.</p>\n//\n// <p>\n// As an example of the not dip into outer context case, consider as super\n// constructor calls versus function calls. One grammar might look like\n// this:</p>\n//\n// <pre>\n// ctorBody\n//   : '{' superCall? stat* '}'\n//   ;\n// </pre>\n//\n// <p>\n// Or, you might see something like</p>\n//\n// <pre>\n// stat\n//   : superCall ';'\n//   | expression ';'\n//   | ...\n//   ;\n// </pre>\n//\n// <p>\n// In both cases I believe that no closure operations will dip into the outer\n// context. In the first case ctorBody in the worst case will stop at the '}'.\n// In the 2nd case it should stop at the ';'. Both cases should stay within the\n// entry rule and not dip into the outer context.</p>\n//\n// <p>\n// <strong>PREDICATES</strong></p>\n//\n// <p>\n// Predicates are always evaluated if present in either SLL or LL both. SLL and\n// LL simulation deals with predicates differently. SLL collects predicates as\n// it performs closure operations like ANTLR v3 did. It delays predicate\n// evaluation until it reaches and accept state. This allows us to cache the SLL\n// ATN simulation whereas, if we had evaluated predicates on-the-fly during\n// closure, the DFA state configuration sets would be different and we couldn't\n// build up a suitable DFA.</p>\n//\n// <p>\n// When building a DFA accept state during ATN simulation, we evaluate any\n// predicates and return the sole semantically valid alternative. If there is\n// more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n// we throw an exception. Alternatives without predicates act like they have\n// true predicates. The simple way to think about it is to strip away all\n// alternatives with false predicates and choose the minimum alternative that\n// remains.</p>\n//\n// <p>\n// When we start in the DFA and reach an accept state that's predicated, we test\n// those and return the minimum semantically viable alternative. If no\n// alternatives are viable, we throw an exception.</p>\n//\n// <p>\n// During full LL ATN simulation, closure always evaluates predicates and\n// on-the-fly. This is crucial to reducing the configuration set size during\n// closure. It hits a landmine when parsing with the Java grammar, for example,\n// without this on-the-fly evaluation.</p>\n//\n// <p>\n// <strong>SHARING DFA</strong></p>\n//\n// <p>\n// All instances of the same parser share the same decision DFAs through a\n// static field. Each instance gets its own ATN simulator but they share the\n// same {@link //decisionToDFA} field. They also share a\n// {@link PredictionContextCache} object that makes sure that all\n// {@link PredictionContext} objects are shared among the DFA states. This makes\n// a big size difference.</p>\n//\n// <p>\n// <strong>THREAD SAFETY</strong></p>\n//\n// <p>\n// The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n// it adds a new DFA object to that array. {@link //addDFAEdge}\n// locks on the DFA for the current decision when setting the\n// {@link DFAState//edges} field. {@link //addDFAState} locks on\n// the DFA for the current decision when looking up a DFA state to see if it\n// already exists. We must make sure that all requests to add DFA states that\n// are equivalent result in the same shared DFA object. This is because lots of\n// threads will be trying to update the DFA at once. The\n// {@link //addDFAState} method also locks inside the DFA lock\n// but this time on the shared context cache when it rebuilds the\n// configurations' {@link PredictionContext} objects using cached\n// subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n// safe as long as we can guarantee that all threads referencing\n// {@code s.edge[t]} get the same physical target {@link DFAState}, or\n// {@code null}. Once into the DFA, the DFA simulation does not reference the\n// {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n// targets. The DFA simulator will either find {@link DFAState//edges} to be\n// {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n// {@code dfa.edges[t]} to be non-null. The\n// {@link //addDFAEdge} method could be racing to set the field\n// but in either case the DFA simulator works; if {@code null}, and requests ATN\n// simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n// way it will work because it's not doing a test and set operation.</p>\n//\n// <p>\n// <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n// Parsing)</strong></p>\n//\n// <p>\n// Sam pointed out that if SLL does not give a syntax error, then there is no\n// point in doing full LL, which is slower. We only have to try LL if we get a\n// syntax error. For maximum speed, Sam starts the parser set to pure SLL\n// mode with the {@link BailErrorStrategy}:</p>\n//\n// <pre>\n// parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n// parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n// </pre>\n//\n// <p>\n// If it does not get a syntax error, then we're done. If it does get a syntax\n// error, we need to retry with the combined SLL/LL strategy.</p>\n//\n// <p>\n// The reason this works is as follows. If there are no SLL conflicts, then the\n// grammar is SLL (at least for that input set). If there is an SLL conflict,\n// the full LL analysis must yield a set of viable alternatives which is a\n// subset of the alternatives reported by SLL. If the LL set is a singleton,\n// then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n// set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n// is truly ambiguous on the current input. If the LL set is smaller, then the\n// SLL conflict resolution might choose an alternative that the full LL would\n// rule out as a possibility based upon better context information. If that's\n// the case, then the SLL parse will definitely get an error because the full LL\n// analysis says it's not viable. If SLL conflict resolution chooses an\n// alternative within the LL set, them both SLL and LL would choose the same\n// alternative because they both choose the minimum of multiple conflicting\n// alternatives.</p>\n//\n// <p>\n// Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n// a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n// parsing will get an error because SLL will pursue alternative 1. If\n// <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n// choose the same alternative because alternative one is the minimum of either\n// set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n// error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n//\n// <p>\n// Of course, if the input is invalid, then we will get an error for sure in\n// both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n// the input.</p>\n//\nvar Utils = require('./../Utils');\n\nvar Set = Utils.Set;\nvar BitSet = Utils.BitSet;\nvar DoubleDict = Utils.DoubleDict;\n\nvar ATN = require('./ATN').ATN;\n\nvar ATNState = require('./ATNState').ATNState;\n\nvar ATNConfig = require('./ATNConfig').ATNConfig;\n\nvar ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;\n\nvar Token = require('./../Token').Token;\n\nvar DFAState = require('./../dfa/DFAState').DFAState;\n\nvar PredPrediction = require('./../dfa/DFAState').PredPrediction;\n\nvar ATNSimulator = require('./ATNSimulator').ATNSimulator;\n\nvar PredictionMode = require('./PredictionMode').PredictionMode;\n\nvar RuleContext = require('./../RuleContext').RuleContext;\n\nvar ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;\n\nvar SemanticContext = require('./SemanticContext').SemanticContext;\n\nvar StarLoopEntryState = require('./ATNState').StarLoopEntryState;\n\nvar RuleStopState = require('./ATNState').RuleStopState;\n\nvar PredictionContext = require('./../PredictionContext').PredictionContext;\n\nvar Interval = require('./../IntervalSet').Interval;\n\nvar Transitions = require('./Transition');\n\nvar Transition = Transitions.Transition;\nvar SetTransition = Transitions.SetTransition;\nvar NotSetTransition = Transitions.NotSetTransition;\nvar RuleTransition = Transitions.RuleTransition;\nvar ActionTransition = Transitions.ActionTransition;\n\nvar NoViableAltException = require('./../error/Errors').NoViableAltException;\n\nvar SingletonPredictionContext = require('./../PredictionContext').SingletonPredictionContext;\n\nvar predictionContextFromRuleContext = require('./../PredictionContext').predictionContextFromRuleContext;\n\nfunction ParserATNSimulator(parser, atn, decisionToDFA, sharedContextCache) {\n  ATNSimulator.call(this, atn, sharedContextCache);\n  this.parser = parser;\n  this.decisionToDFA = decisionToDFA; // SLL, LL, or LL + exact ambig detection?//\n\n  this.predictionMode = PredictionMode.LL; // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n\n  this._input = null;\n  this._startIndex = 0;\n  this._outerContext = null;\n  this._dfa = null; // Each prediction operation uses a cache for merge of prediction contexts.\n  //  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n  //  isn't synchronized but we're ok since two threads shouldn't reuse same\n  //  parser/atnsim object because it can only handle one input at a time.\n  //  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n  //  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n  //  also be examined during cache lookup.\n  //\n\n  this.mergeCache = null;\n  return this;\n}\n\nParserATNSimulator.prototype = Object.create(ATNSimulator.prototype);\nParserATNSimulator.prototype.constructor = ParserATNSimulator;\nParserATNSimulator.prototype.debug = false;\nParserATNSimulator.prototype.debug_closure = false;\nParserATNSimulator.prototype.debug_add = false;\nParserATNSimulator.prototype.debug_list_atn_decisions = false;\nParserATNSimulator.prototype.dfa_debug = false;\nParserATNSimulator.prototype.retry_debug = false;\n\nParserATNSimulator.prototype.reset = function () {};\n\nParserATNSimulator.prototype.adaptivePredict = function (input, decision, outerContext) {\n  if (this.debug || this.debug_list_atn_decisions) {\n    console.log(\"adaptivePredict decision \" + decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n  }\n\n  this._input = input;\n  this._startIndex = input.index;\n  this._outerContext = outerContext;\n  var dfa = this.decisionToDFA[decision];\n  this._dfa = dfa;\n  var m = input.mark();\n  var index = input.index; // Now we are certain to have a specific decision's DFA\n  // But, do we still need an initial state?\n\n  try {\n    var s0;\n\n    if (dfa.precedenceDfa) {\n      // the start state for a precedence DFA depends on the current\n      // parser precedence, and is provided by a DFA method.\n      s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n    } else {\n      // the start state for a \"regular\" DFA is just s0\n      s0 = dfa.s0;\n    }\n\n    if (s0 === null) {\n      if (outerContext === null) {\n        outerContext = RuleContext.EMPTY;\n      }\n\n      if (this.debug || this.debug_list_atn_decisions) {\n        console.log(\"predictATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n      }\n\n      var fullCtx = false;\n      var s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n      if (dfa.precedenceDfa) {\n        // If this is a precedence DFA, we use applyPrecedenceFilter\n        // to convert the computed start state to a precedence start\n        // state. We then use DFA.setPrecedenceStartState to set the\n        // appropriate start state for the precedence level rather\n        // than simply setting DFA.s0.\n        //\n        dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n\n        s0_closure = this.applyPrecedenceFilter(s0_closure);\n        s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n        dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n      } else {\n        s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n        dfa.s0 = s0;\n      }\n    }\n\n    var alt = this.execATN(dfa, s0, input, index, outerContext);\n\n    if (this.debug) {\n      console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames));\n    }\n\n    return alt;\n  } finally {\n    this._dfa = null;\n    this.mergeCache = null; // wack cache after each prediction\n\n    input.seek(index);\n    input.release(m);\n  }\n}; // Performs ATN simulation to compute a predicted alternative based\n//  upon the remaining input, but also updates the DFA cache to avoid\n//  having to traverse the ATN again for the same input sequence.\n// There are some key conditions we're looking for after computing a new\n// set of ATN configs (proposed DFA state):\n// if the set is empty, there is no viable alternative for current symbol\n// does the state uniquely predict an alternative?\n// does the state have a conflict that would prevent us from\n//   putting it on the work list?\n// We also have some key operations to do:\n// add an edge from previous DFA state to potentially new DFA state, D,\n//   upon current symbol but only if adding to work list, which means in all\n//   cases except no viable alternative (and possibly non-greedy decisions?)\n// collecting predicates and adding semantic context to DFA accept states\n// adding rule context to context-sensitive DFA accept states\n// consuming an input symbol\n// reporting a conflict\n// reporting an ambiguity\n// reporting a context sensitivity\n// reporting insufficient predicates\n// cover these cases:\n//    dead end\n//    single alt\n//    single alt + preds\n//    conflict\n//    conflict + preds\n//\n\n\nParserATNSimulator.prototype.execATN = function (dfa, s0, input, startIndex, outerContext) {\n  if (this.debug || this.debug_list_atn_decisions) {\n    console.log(\"execATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input) + \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n  }\n\n  var alt;\n  var previousD = s0;\n\n  if (this.debug) {\n    console.log(\"s0 = \" + s0);\n  }\n\n  var t = input.LA(1);\n\n  while (true) {\n    // while more work\n    var D = this.getExistingTargetState(previousD, t);\n\n    if (D === null) {\n      D = this.computeTargetState(dfa, previousD, t);\n    }\n\n    if (D === ATNSimulator.ERROR) {\n      // if any configs in previous dipped into outer context, that\n      // means that input up to t actually finished entry rule\n      // at least for SLL decision. Full LL doesn't dip into outer\n      // so don't need special case.\n      // We will get an error no matter what so delay until after\n      // decision; better error message. Also, no reachable target\n      // ATN states in SLL implies LL will also get nowhere.\n      // If conflict in states that dip out, choose min since we\n      // will get error no matter what.\n      var e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n      input.seek(startIndex);\n      alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n\n      if (alt !== ATN.INVALID_ALT_NUMBER) {\n        return alt;\n      } else {\n        throw e;\n      }\n    }\n\n    if (D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n      // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n      var conflictingAlts = null;\n\n      if (D.predicates !== null) {\n        if (this.debug) {\n          console.log(\"DFA state has preds in DFA sim LL failover\");\n        }\n\n        var conflictIndex = input.index;\n\n        if (conflictIndex !== startIndex) {\n          input.seek(startIndex);\n        }\n\n        conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n\n        if (conflictingAlts.length === 1) {\n          if (this.debug) {\n            console.log(\"Full LL avoided\");\n          }\n\n          return conflictingAlts.minValue();\n        }\n\n        if (conflictIndex !== startIndex) {\n          // restore the index so reporting the fallback to full\n          // context occurs with the index at the correct spot\n          input.seek(conflictIndex);\n        }\n      }\n\n      if (this.dfa_debug) {\n        console.log(\"ctx sensitive state \" + outerContext + \" in \" + D);\n      }\n\n      var fullCtx = true;\n      var s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n      this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n      alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n      return alt;\n    }\n\n    if (D.isAcceptState) {\n      if (D.predicates === null) {\n        return D.prediction;\n      }\n\n      var stopIndex = input.index;\n      input.seek(startIndex);\n      var alts = this.evalSemanticContext(D.predicates, outerContext, true);\n\n      if (alts.length === 0) {\n        throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n      } else if (alts.length === 1) {\n        return alts.minValue();\n      } else {\n        // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n        this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n        return alts.minValue();\n      }\n    }\n\n    previousD = D;\n\n    if (t !== Token.EOF) {\n      input.consume();\n      t = input.LA(1);\n    }\n  }\n}; //\n// Get an existing target state for an edge in the DFA. If the target state\n// for the edge has not yet been computed or is otherwise not available,\n// this method returns {@code null}.\n//\n// @param previousD The current DFA state\n// @param t The next input symbol\n// @return The existing target DFA state for the given input symbol\n// {@code t}, or {@code null} if the target state for this edge is not\n// already cached\n//\n\n\nParserATNSimulator.prototype.getExistingTargetState = function (previousD, t) {\n  var edges = previousD.edges;\n\n  if (edges === null) {\n    return null;\n  } else {\n    return edges[t + 1] || null;\n  }\n}; //\n// Compute a target state for an edge in the DFA, and attempt to add the\n// computed state and corresponding edge to the DFA.\n//\n// @param dfa The DFA\n// @param previousD The current DFA state\n// @param t The next input symbol\n//\n// @return The computed target DFA state for the given input symbol\n// {@code t}. If {@code t} does not lead to a valid DFA state, this method\n// returns {@link //ERROR}.\n//\n\n\nParserATNSimulator.prototype.computeTargetState = function (dfa, previousD, t) {\n  var reach = this.computeReachSet(previousD.configs, t, false);\n\n  if (reach === null) {\n    this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n    return ATNSimulator.ERROR;\n  } // create new target state; we'll add to DFA after it's complete\n\n\n  var D = new DFAState(null, reach);\n  var predictedAlt = this.getUniqueAlt(reach);\n\n  if (this.debug) {\n    var altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n    console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) + \", previous=\" + previousD.configs + \", configs=\" + reach + \", predict=\" + predictedAlt + \", allSubsetsConflict=\" + PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" + this.getConflictingAlts(reach));\n  }\n\n  if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n    // NO CONFLICT, UNIQUELY PREDICTED ALT\n    D.isAcceptState = true;\n    D.configs.uniqueAlt = predictedAlt;\n    D.prediction = predictedAlt;\n  } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n    // MORE THAN ONE VIABLE ALTERNATIVE\n    D.configs.conflictingAlts = this.getConflictingAlts(reach);\n    D.requiresFullContext = true; // in SLL-only mode, we will stop at this state and return the minimum alt\n\n    D.isAcceptState = true;\n    D.prediction = D.configs.conflictingAlts.minValue();\n  }\n\n  if (D.isAcceptState && D.configs.hasSemanticContext) {\n    this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n\n    if (D.predicates !== null) {\n      D.prediction = ATN.INVALID_ALT_NUMBER;\n    }\n  } // all adds to dfa are done after we've created full D state\n\n\n  D = this.addDFAEdge(dfa, previousD, t, D);\n  return D;\n};\n\nParserATNSimulator.prototype.predicateDFAState = function (dfaState, decisionState) {\n  // We need to test all predicates, even in DFA states that\n  // uniquely predict alternative.\n  var nalts = decisionState.transitions.length; // Update DFA so reach becomes accept state with (predicate,alt)\n  // pairs if preds found for conflicting alts\n\n  var altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n  var altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n\n  if (altToPred !== null) {\n    dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n    dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n  } else {\n    // There are preds in configs but they might go away\n    // when OR'd together like {p}? || NONE == NONE. If neither\n    // alt has preds, resolve to min alt\n    dfaState.prediction = altsToCollectPredsFrom.minValue();\n  }\n}; // comes back with reach.uniqueAlt set to a valid alt\n\n\nParserATNSimulator.prototype.execATNWithFullContext = function (dfa, D, // how far we got before failing over\ns0, input, startIndex, outerContext) {\n  if (this.debug || this.debug_list_atn_decisions) {\n    console.log(\"execATNWithFullContext \" + s0);\n  }\n\n  var fullCtx = true;\n  var foundExactAmbig = false;\n  var reach = null;\n  var previous = s0;\n  input.seek(startIndex);\n  var t = input.LA(1);\n  var predictedAlt = -1;\n\n  while (true) {\n    // while more work\n    reach = this.computeReachSet(previous, t, fullCtx);\n\n    if (reach === null) {\n      // if any configs in previous dipped into outer context, that\n      // means that input up to t actually finished entry rule\n      // at least for LL decision. Full LL doesn't dip into outer\n      // so don't need special case.\n      // We will get an error no matter what so delay until after\n      // decision; better error message. Also, no reachable target\n      // ATN states in SLL implies LL will also get nowhere.\n      // If conflict in states that dip out, choose min since we\n      // will get error no matter what.\n      var e = this.noViableAlt(input, outerContext, previous, startIndex);\n      input.seek(startIndex);\n      var alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n\n      if (alt !== ATN.INVALID_ALT_NUMBER) {\n        return alt;\n      } else {\n        throw e;\n      }\n    }\n\n    var altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n\n    if (this.debug) {\n      console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" + PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n    }\n\n    reach.uniqueAlt = this.getUniqueAlt(reach); // unique prediction?\n\n    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n      predictedAlt = reach.uniqueAlt;\n      break;\n    } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n      predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n\n      if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n        break;\n      }\n    } else {\n      // In exact ambiguity mode, we never try to terminate early.\n      // Just keeps scarfing until we know what the conflict is\n      if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n        foundExactAmbig = true;\n        predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n        break;\n      } // else there are multiple non-conflicting subsets or\n      // we're not sure what the ambiguity is yet.\n      // So, keep going.\n\n    }\n\n    previous = reach;\n\n    if (t !== Token.EOF) {\n      input.consume();\n      t = input.LA(1);\n    }\n  } // If the configuration set uniquely predicts an alternative,\n  // without conflict, then we know that it's a full LL decision\n  // not SLL.\n\n\n  if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n    this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n    return predictedAlt;\n  } // We do not check predicates here because we have checked them\n  // on-the-fly when doing full context prediction.\n  //\n  // In non-exact ambiguity detection mode, we might\tactually be able to\n  // detect an exact ambiguity, but I'm not going to spend the cycles\n  // needed to check. We only emit ambiguity warnings in exact ambiguity\n  // mode.\n  //\n  // For example, we might know that we have conflicting configurations.\n  // But, that does not mean that there is no way forward without a\n  // conflict. It's possible to have nonconflicting alt subsets as in:\n  // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n  // from\n  //\n  //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n  //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n  //\n  // In this case, (17,1,[5 $]) indicates there is some next sequence that\n  // would resolve this without conflict to alternative 1. Any other viable\n  // next sequence, however, is associated with a conflict.  We stop\n  // looking for input because no amount of further lookahead will alter\n  // the fact that we should predict alternative 1.  We just can't say for\n  // sure that there is an ambiguity without looking further.\n\n\n  this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n  return predictedAlt;\n};\n\nParserATNSimulator.prototype.computeReachSet = function (closure, t, fullCtx) {\n  if (this.debug) {\n    console.log(\"in computeReachSet, starting closure: \" + closure);\n  }\n\n  if (this.mergeCache === null) {\n    this.mergeCache = new DoubleDict();\n  }\n\n  var intermediate = new ATNConfigSet(fullCtx); // Configurations already in a rule stop state indicate reaching the end\n  // of the decision rule (local context) or end of the start rule (full\n  // context). Once reached, these configurations are never updated by a\n  // closure operation, so they are handled separately for the performance\n  // advantage of having a smaller intermediate set when calling closure.\n  //\n  // For full-context reach operations, separate handling is required to\n  // ensure that the alternative matching the longest overall sequence is\n  // chosen when multiple such configurations can match the input.\n\n  var skippedStopStates = null; // First figure out where we can reach on input t\n\n  for (var i = 0; i < closure.items.length; i++) {\n    var c = closure.items[i];\n\n    if (this.debug_add) {\n      console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n    }\n\n    if (c.state instanceof RuleStopState) {\n      if (fullCtx || t === Token.EOF) {\n        if (skippedStopStates === null) {\n          skippedStopStates = [];\n        }\n\n        skippedStopStates.push(c);\n\n        if (this.debug_add) {\n          console.log(\"added \" + c + \" to skippedStopStates\");\n        }\n      }\n\n      continue;\n    }\n\n    for (var j = 0; j < c.state.transitions.length; j++) {\n      var trans = c.state.transitions[j];\n      var target = this.getReachableTarget(trans, t);\n\n      if (target !== null) {\n        var cfg = new ATNConfig({\n          state: target\n        }, c);\n        intermediate.add(cfg, this.mergeCache);\n\n        if (this.debug_add) {\n          console.log(\"added \" + cfg + \" to intermediate\");\n        }\n      }\n    }\n  } // Now figure out where the reach operation can take us...\n\n\n  var reach = null; // This block optimizes the reach operation for intermediate sets which\n  // trivially indicate a termination state for the overall\n  // adaptivePredict operation.\n  //\n  // The conditions assume that intermediate\n  // contains all configurations relevant to the reach set, but this\n  // condition is not true when one or more configurations have been\n  // withheld in skippedStopStates, or when the current symbol is EOF.\n  //\n\n  if (skippedStopStates === null && t !== Token.EOF) {\n    if (intermediate.items.length === 1) {\n      // Don't pursue the closure if there is just one state.\n      // It can only have one alternative; just add to result\n      // Also don't pursue the closure if there is unique alternative\n      // among the configurations.\n      reach = intermediate;\n    } else if (this.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {\n      // Also don't pursue the closure if there is unique alternative\n      // among the configurations.\n      reach = intermediate;\n    }\n  } // If the reach set could not be trivially determined, perform a closure\n  // operation on the intermediate set to compute its initial value.\n  //\n\n\n  if (reach === null) {\n    reach = new ATNConfigSet(fullCtx);\n    var closureBusy = new Set();\n    var treatEofAsEpsilon = t === Token.EOF;\n\n    for (var k = 0; k < intermediate.items.length; k++) {\n      this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n    }\n  }\n\n  if (t === Token.EOF) {\n    // After consuming EOF no additional input is possible, so we are\n    // only interested in configurations which reached the end of the\n    // decision rule (local context) or end of the start rule (full\n    // context). Update reach to contain only these configurations. This\n    // handles both explicit EOF transitions in the grammar and implicit\n    // EOF transitions following the end of the decision or start rule.\n    //\n    // When reach==intermediate, no closure operation was performed. In\n    // this case, removeAllConfigsNotInRuleStopState needs to check for\n    // reachable rule stop states as well as configurations already in\n    // a rule stop state.\n    //\n    // This is handled before the configurations in skippedStopStates,\n    // because any configurations potentially added from that list are\n    // already guaranteed to meet this condition whether or not it's\n    // required.\n    //\n    reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n  } // If skippedStopStates!==null, then it contains at least one\n  // configuration. For full-context reach operations, these\n  // configurations reached the end of the start rule, in which case we\n  // only add them back to reach if no configuration during the current\n  // closure operation reached such a state. This ensures adaptivePredict\n  // chooses an alternative matching the longest overall sequence when\n  // multiple alternatives are viable.\n  //\n\n\n  if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {\n    for (var l = 0; l < skippedStopStates.length; l++) {\n      reach.add(skippedStopStates[l], this.mergeCache);\n    }\n  }\n\n  if (reach.items.length === 0) {\n    return null;\n  } else {\n    return reach;\n  }\n}; //\n// Return a configuration set containing only the configurations from\n// {@code configs} which are in a {@link RuleStopState}. If all\n// configurations in {@code configs} are already in a rule stop state, this\n// method simply returns {@code configs}.\n//\n// <p>When {@code lookToEndOfRule} is true, this method uses\n// {@link ATN//nextTokens} for each configuration in {@code configs} which is\n// not already in a rule stop state to see if a rule stop state is reachable\n// from the configuration via epsilon-only transitions.</p>\n//\n// @param configs the configuration set to update\n// @param lookToEndOfRule when true, this method checks for rule stop states\n// reachable by epsilon-only transitions from each configuration in\n// {@code configs}.\n//\n// @return {@code configs} if all configurations in {@code configs} are in a\n// rule stop state, otherwise return a new configuration set containing only\n// the configurations from {@code configs} which are in a rule stop state\n//\n\n\nParserATNSimulator.prototype.removeAllConfigsNotInRuleStopState = function (configs, lookToEndOfRule) {\n  if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n    return configs;\n  }\n\n  var result = new ATNConfigSet(configs.fullCtx);\n\n  for (var i = 0; i < configs.items.length; i++) {\n    var config = configs.items[i];\n\n    if (config.state instanceof RuleStopState) {\n      result.add(config, this.mergeCache);\n      continue;\n    }\n\n    if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n      var nextTokens = this.atn.nextTokens(config.state);\n\n      if (nextTokens.contains(Token.EPSILON)) {\n        var endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n        result.add(new ATNConfig({\n          state: endOfRuleState\n        }, config), this.mergeCache);\n      }\n    }\n  }\n\n  return result;\n};\n\nParserATNSimulator.prototype.computeStartState = function (p, ctx, fullCtx) {\n  // always at least the implicit call to start rule\n  var initialContext = predictionContextFromRuleContext(this.atn, ctx);\n  var configs = new ATNConfigSet(fullCtx);\n\n  for (var i = 0; i < p.transitions.length; i++) {\n    var target = p.transitions[i].target;\n    var c = new ATNConfig({\n      state: target,\n      alt: i + 1,\n      context: initialContext\n    }, null);\n    var closureBusy = new Set();\n    this.closure(c, configs, closureBusy, true, fullCtx, false);\n  }\n\n  return configs;\n}; //\n// This method transforms the start state computed by\n// {@link //computeStartState} to the special start state used by a\n// precedence DFA for a particular precedence value. The transformation\n// process applies the following changes to the start state's configuration\n// set.\n//\n// <ol>\n// <li>Evaluate the precedence predicates for each configuration using\n// {@link SemanticContext//evalPrecedence}.</li>\n// <li>Remove all configurations which predict an alternative greater than\n// 1, for which another configuration that predicts alternative 1 is in the\n// same ATN state with the same prediction context. This transformation is\n// valid for the following reasons:\n// <ul>\n// <li>The closure block cannot contain any epsilon transitions which bypass\n// the body of the closure, so all states reachable via alternative 1 are\n// part of the precedence alternatives of the transformed left-recursive\n// rule.</li>\n// <li>The \"primary\" portion of a left recursive rule cannot contain an\n// epsilon transition, so the only way an alternative other than 1 can exist\n// in a state that is also reachable via alternative 1 is by nesting calls\n// to the left-recursive rule, with the outer calls not being at the\n// preferred precedence level.</li>\n// </ul>\n// </li>\n// </ol>\n//\n// <p>\n// The prediction context must be considered by this filter to address\n// situations like the following.\n// </p>\n// <code>\n// <pre>\n// grammar TA;\n// prog: statement* EOF;\n// statement: letterA | statement letterA 'b' ;\n// letterA: 'a';\n// </pre>\n// </code>\n// <p>\n// If the above grammar, the ATN state immediately before the token\n// reference {@code 'a'} in {@code letterA} is reachable from the left edge\n// of both the primary and closure blocks of the left-recursive rule\n// {@code statement}. The prediction context associated with each of these\n// configurations distinguishes between them, and prevents the alternative\n// which stepped out to {@code prog} (and then back in to {@code statement}\n// from being eliminated by the filter.\n// </p>\n//\n// @param configs The configuration set computed by\n// {@link //computeStartState} as the start state for the DFA.\n// @return The transformed configuration set representing the start state\n// for a precedence DFA at a particular precedence level (determined by\n// calling {@link Parser//getPrecedence}).\n//\n\n\nParserATNSimulator.prototype.applyPrecedenceFilter = function (configs) {\n  var config;\n  var statesFromAlt1 = [];\n  var configSet = new ATNConfigSet(configs.fullCtx);\n\n  for (var i = 0; i < configs.items.length; i++) {\n    config = configs.items[i]; // handle alt 1 first\n\n    if (config.alt !== 1) {\n      continue;\n    }\n\n    var updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n\n    if (updatedContext === null) {\n      // the configuration was eliminated\n      continue;\n    }\n\n    statesFromAlt1[config.state.stateNumber] = config.context;\n\n    if (updatedContext !== config.semanticContext) {\n      configSet.add(new ATNConfig({\n        semanticContext: updatedContext\n      }, config), this.mergeCache);\n    } else {\n      configSet.add(config, this.mergeCache);\n    }\n  }\n\n  for (i = 0; i < configs.items.length; i++) {\n    config = configs.items[i];\n\n    if (config.alt === 1) {\n      // already handled\n      continue;\n    } // In the future, this elimination step could be updated to also\n    // filter the prediction context for alternatives predicting alt>1\n    // (basically a graph subtraction algorithm).\n\n\n    if (!config.precedenceFilterSuppressed) {\n      var context = statesFromAlt1[config.state.stateNumber] || null;\n\n      if (context !== null && context.equals(config.context)) {\n        // eliminated\n        continue;\n      }\n    }\n\n    configSet.add(config, this.mergeCache);\n  }\n\n  return configSet;\n};\n\nParserATNSimulator.prototype.getReachableTarget = function (trans, ttype) {\n  if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n    return trans.target;\n  } else {\n    return null;\n  }\n};\n\nParserATNSimulator.prototype.getPredsForAmbigAlts = function (ambigAlts, configs, nalts) {\n  // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n  // altToPred starts as an array of all null contexts. The entry at index i\n  // corresponds to alternative i. altToPred[i] may have one of three values:\n  //   1. null: no ATNConfig c is found such that c.alt==i\n  //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n  //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n  //      alt i has at least one unpredicated config.\n  //   3. Non-NONE Semantic Context: There exists at least one, and for all\n  //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n  //\n  // From this, it is clear that NONE||anything==NONE.\n  //\n  var altToPred = [];\n\n  for (var i = 0; i < configs.items.length; i++) {\n    var c = configs.items[i];\n\n    if (ambigAlts.contains(c.alt)) {\n      altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n    }\n  }\n\n  var nPredAlts = 0;\n\n  for (i = 1; i < nalts + 1; i++) {\n    var pred = altToPred[i] || null;\n\n    if (pred === null) {\n      altToPred[i] = SemanticContext.NONE;\n    } else if (pred !== SemanticContext.NONE) {\n      nPredAlts += 1;\n    }\n  } // nonambig alts are null in altToPred\n\n\n  if (nPredAlts === 0) {\n    altToPred = null;\n  }\n\n  if (this.debug) {\n    console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n  }\n\n  return altToPred;\n};\n\nParserATNSimulator.prototype.getPredicatePredictions = function (ambigAlts, altToPred) {\n  var pairs = [];\n  var containsPredicate = false;\n\n  for (var i = 1; i < altToPred.length; i++) {\n    var pred = altToPred[i]; // unpredicated is indicated by SemanticContext.NONE\n\n    if (ambigAlts !== null && ambigAlts.contains(i)) {\n      pairs.push(new PredPrediction(pred, i));\n    }\n\n    if (pred !== SemanticContext.NONE) {\n      containsPredicate = true;\n    }\n  }\n\n  if (!containsPredicate) {\n    return null;\n  }\n\n  return pairs;\n}; //\n// This method is used to improve the localization of error messages by\n// choosing an alternative rather than throwing a\n// {@link NoViableAltException} in particular prediction scenarios where the\n// {@link //ERROR} state was reached during ATN simulation.\n//\n// <p>\n// The default implementation of this method uses the following\n// algorithm to identify an ATN configuration which successfully parsed the\n// decision entry rule. Choosing such an alternative ensures that the\n// {@link ParserRuleContext} returned by the calling rule will be complete\n// and valid, and the syntax error will be reported later at a more\n// localized location.</p>\n//\n// <ul>\n// <li>If a syntactically valid path or paths reach the end of the decision rule and\n// they are semantically valid if predicated, return the min associated alt.</li>\n// <li>Else, if a semantically invalid but syntactically valid path exist\n// or paths exist, return the minimum associated alt.\n// </li>\n// <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n// </ul>\n//\n// <p>\n// In some scenarios, the algorithm described above could predict an\n// alternative which will result in a {@link FailedPredicateException} in\n// the parser. Specifically, this could occur if the <em>only</em> configuration\n// capable of successfully parsing to the end of the decision rule is\n// blocked by a semantic predicate. By choosing this alternative within\n// {@link //adaptivePredict} instead of throwing a\n// {@link NoViableAltException}, the resulting\n// {@link FailedPredicateException} in the parser will identify the specific\n// predicate which is preventing the parser from successfully parsing the\n// decision rule, which helps developers identify and correct logic errors\n// in semantic predicates.\n// </p>\n//\n// @param configs The ATN configurations which were valid immediately before\n// the {@link //ERROR} state was reached\n// @param outerContext The is the \\gamma_0 initial parser context from the paper\n// or the parser stack at the instant before prediction commences.\n//\n// @return The value to return from {@link //adaptivePredict}, or\n// {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n// identified and {@link //adaptivePredict} should report an error instead.\n//\n\n\nParserATNSimulator.prototype.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule = function (configs, outerContext) {\n  var cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n  var semValidConfigs = cfgs[0];\n  var semInvalidConfigs = cfgs[1];\n  var alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n\n  if (alt !== ATN.INVALID_ALT_NUMBER) {\n    // semantically/syntactically viable path exists\n    return alt;\n  } // Is there a syntactically valid path with a failed pred?\n\n\n  if (semInvalidConfigs.items.length > 0) {\n    alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n\n    if (alt !== ATN.INVALID_ALT_NUMBER) {\n      // syntactically viable path exists\n      return alt;\n    }\n  }\n\n  return ATN.INVALID_ALT_NUMBER;\n};\n\nParserATNSimulator.prototype.getAltThatFinishedDecisionEntryRule = function (configs) {\n  var alts = [];\n\n  for (var i = 0; i < configs.items.length; i++) {\n    var c = configs.items[i];\n\n    if (c.reachesIntoOuterContext > 0 || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {\n      if (alts.indexOf(c.alt) < 0) {\n        alts.push(c.alt);\n      }\n    }\n  }\n\n  if (alts.length === 0) {\n    return ATN.INVALID_ALT_NUMBER;\n  } else {\n    return Math.min.apply(null, alts);\n  }\n}; // Walk the list of configurations and split them according to\n//  those that have preds evaluating to true/false.  If no pred, assume\n//  true pred and include in succeeded set.  Returns Pair of sets.\n//\n//  Create a new set so as not to alter the incoming parameter.\n//\n//  Assumption: the input stream has been restored to the starting point\n//  prediction, which is where predicates need to evaluate.\n//\n\n\nParserATNSimulator.prototype.splitAccordingToSemanticValidity = function (configs, outerContext) {\n  var succeeded = new ATNConfigSet(configs.fullCtx);\n  var failed = new ATNConfigSet(configs.fullCtx);\n\n  for (var i = 0; i < configs.items.length; i++) {\n    var c = configs.items[i];\n\n    if (c.semanticContext !== SemanticContext.NONE) {\n      var predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n\n      if (predicateEvaluationResult) {\n        succeeded.add(c);\n      } else {\n        failed.add(c);\n      }\n    } else {\n      succeeded.add(c);\n    }\n  }\n\n  return [succeeded, failed];\n}; // Look through a list of predicate/alt pairs, returning alts for the\n//  pairs that win. A {@code NONE} predicate indicates an alt containing an\n//  unpredicated config which behaves as \"always true.\" If !complete\n//  then we stop at the first predicate that evaluates to true. This\n//  includes pairs with null predicates.\n//\n\n\nParserATNSimulator.prototype.evalSemanticContext = function (predPredictions, outerContext, complete) {\n  var predictions = new BitSet();\n\n  for (var i = 0; i < predPredictions.length; i++) {\n    var pair = predPredictions[i];\n\n    if (pair.pred === SemanticContext.NONE) {\n      predictions.add(pair.alt);\n\n      if (!complete) {\n        break;\n      }\n\n      continue;\n    }\n\n    var predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n\n    if (this.debug || this.dfa_debug) {\n      console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n    }\n\n    if (predicateEvaluationResult) {\n      if (this.debug || this.dfa_debug) {\n        console.log(\"PREDICT \" + pair.alt);\n      }\n\n      predictions.add(pair.alt);\n\n      if (!complete) {\n        break;\n      }\n    }\n  }\n\n  return predictions;\n}; // TODO: If we are doing predicates, there is no point in pursuing\n//     closure operations if we reach a DFA state that uniquely predicts\n//     alternative. We will not be caching that DFA state and it is a\n//     waste to pursue the closure. Might have to advance when we do\n//     ambig detection thought :(\n//\n\n\nParserATNSimulator.prototype.closure = function (config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n  var initialDepth = 0;\n  this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);\n};\n\nParserATNSimulator.prototype.closureCheckingStopState = function (config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n  if (this.debug || this.debug_closure) {\n    console.log(\"closure(\" + config.toString(this.parser, true) + \")\"); // console.log(\"configs(\" + configs.toString() + \")\");\n\n    if (config.reachesIntoOuterContext > 50) {\n      throw \"problem\";\n    }\n  }\n\n  if (config.state instanceof RuleStopState) {\n    // We hit rule end. If we have context info, use it\n    // run thru all possible stack tops in ctx\n    if (!config.context.isEmpty()) {\n      for (var i = 0; i < config.context.length; i++) {\n        if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n          if (fullCtx) {\n            configs.add(new ATNConfig({\n              state: config.state,\n              context: PredictionContext.EMPTY\n            }, config), this.mergeCache);\n            continue;\n          } else {\n            // we have no context info, just chase follow links (if greedy)\n            if (this.debug) {\n              console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n            }\n\n            this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n          }\n\n          continue;\n        }\n\n        var returnState = this.atn.states[config.context.getReturnState(i)];\n        var newContext = config.context.getParent(i); // \"pop\" return state\n\n        var parms = {\n          state: returnState,\n          alt: config.alt,\n          context: newContext,\n          semanticContext: config.semanticContext\n        };\n        var c = new ATNConfig(parms, null); // While we have context to pop back from, we may have\n        // gotten that context AFTER having falling off a rule.\n        // Make sure we track that we are now out of context.\n\n        c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n        this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n      }\n\n      return;\n    } else if (fullCtx) {\n      // reached end of start rule\n      configs.add(config, this.mergeCache);\n      return;\n    } else {\n      // else if we have no context info, just chase follow links (if greedy)\n      if (this.debug) {\n        console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n      }\n    }\n  }\n\n  this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n}; // Do the actual work of walking epsilon edges//\n\n\nParserATNSimulator.prototype.closure_ = function (config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n  var p = config.state; // optimization\n\n  if (!p.epsilonOnlyTransitions) {\n    configs.add(config, this.mergeCache); // make sure to not return here, because EOF transitions can act as\n    // both epsilon transitions and non-epsilon transitions.\n  }\n\n  for (var i = 0; i < p.transitions.length; i++) {\n    if (i == 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) continue;\n    var t = p.transitions[i];\n    var continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n    var c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n\n    if (c !== null) {\n      var newDepth = depth;\n\n      if (config.state instanceof RuleStopState) {\n        // target fell off end of rule; mark resulting c as having dipped into outer context\n        // We can't get here if incoming config was rule stop and we had context\n        // track how far we dip into outer context.  Might\n        // come in handy and we avoid evaluating context dependent\n        // preds if this is > 0.\n        if (this._dfa !== null && this._dfa.precedenceDfa) {\n          if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n            c.precedenceFilterSuppressed = true;\n          }\n        }\n\n        c.reachesIntoOuterContext += 1;\n\n        if (closureBusy.add(c) !== c) {\n          // avoid infinite recursion for right-recursive rules\n          continue;\n        }\n\n        configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n\n        newDepth -= 1;\n\n        if (this.debug) {\n          console.log(\"dips into outer ctx: \" + c);\n        }\n      } else {\n        if (!t.isEpsilon && closureBusy.add(c) !== c) {\n          // avoid infinite recursion for EOF* and EOF+\n          continue;\n        }\n\n        if (t instanceof RuleTransition) {\n          // latch when newDepth goes negative - once we step out of the entry context we can't return\n          if (newDepth >= 0) {\n            newDepth += 1;\n          }\n        }\n      }\n\n      this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n    }\n  }\n};\n\nParserATNSimulator.prototype.canDropLoopEntryEdgeInLeftRecursiveRule = function (config) {\n  // return False\n  var p = config.state; // First check to see if we are in StarLoopEntryState generated during\n  // left-recursion elimination. For efficiency, also check if\n  // the context has an empty stack case. If so, it would mean\n  // global FOLLOW so we can't perform optimization\n  // Are we the special loop entry/exit state? or SLL wildcard\n\n  if (p.stateType != ATNState.STAR_LOOP_ENTRY) return false;\n  if (p.stateType != ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config.context.isEmpty() || config.context.hasEmptyPath()) return false; // Require all return states to return back to the same rule that p is in.\n\n  var numCtxs = config.context.length;\n\n  for (var i = 0; i < numCtxs; i++) {\n    // for each stack context\n    var returnState = this.atn.states[config.context.getReturnState(i)];\n    if (returnState.ruleIndex != p.ruleIndex) return false;\n  }\n\n  var decisionStartState = p.transitions[0].target;\n  var blockEndStateNum = decisionStartState.endState.stateNumber;\n  var blockEndState = this.atn.states[blockEndStateNum]; // Verify that the top of each stack context leads to loop entry/exit\n  // state through epsilon edges and w/o leaving rule.\n\n  for (var i = 0; i < numCtxs; i++) {\n    // for each stack context\n    var returnStateNumber = config.context.getReturnState(i);\n    var returnState = this.atn.states[returnStateNumber]; // all states must have single outgoing epsilon edge\n\n    if (returnState.transitions.length != 1 || !returnState.transitions[0].isEpsilon) return false; // Look for prefix op case like 'not expr', (' type ')' expr\n\n    var returnStateTarget = returnState.transitions[0].target;\n    if (returnState.stateType == ATNState.BLOCK_END && returnStateTarget == p) continue; // Look for 'expr op expr' or case where expr's return state is block end\n    // of (...)* internal block; the block end points to loop back\n    // which points to p but we don't need to check that\n\n    if (returnState == blockEndState) continue; // Look for ternary expr ? expr : expr. The return state points at block end,\n    // which points at loop entry state\n\n    if (returnStateTarget == blockEndState) continue; // Look for complex prefix 'between expr and expr' case where 2nd expr's\n    // return state points at block end state of (...)* internal block\n\n    if (returnStateTarget.stateType == ATNState.BLOCK_END && returnStateTarget.transitions.length == 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target == p) continue; // anything else ain't conforming\n\n    return false;\n  }\n\n  return true;\n};\n\nParserATNSimulator.prototype.getRuleName = function (index) {\n  if (this.parser !== null && index >= 0) {\n    return this.parser.ruleNames[index];\n  } else {\n    return \"<rule \" + index + \">\";\n  }\n};\n\nParserATNSimulator.prototype.getEpsilonTarget = function (config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n  switch (t.serializationType) {\n    case Transition.RULE:\n      return this.ruleTransition(config, t);\n\n    case Transition.PRECEDENCE:\n      return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n\n    case Transition.PREDICATE:\n      return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n\n    case Transition.ACTION:\n      return this.actionTransition(config, t);\n\n    case Transition.EPSILON:\n      return new ATNConfig({\n        state: t.target\n      }, config);\n\n    case Transition.ATOM:\n    case Transition.RANGE:\n    case Transition.SET:\n      // EOF transitions act like epsilon transitions after the first EOF\n      // transition is traversed\n      if (treatEofAsEpsilon) {\n        if (t.matches(Token.EOF, 0, 1)) {\n          return new ATNConfig({\n            state: t.target\n          }, config);\n        }\n      }\n\n      return null;\n\n    default:\n      return null;\n  }\n};\n\nParserATNSimulator.prototype.actionTransition = function (config, t) {\n  if (this.debug) {\n    var index = t.actionIndex == -1 ? 65535 : t.actionIndex;\n    console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n  }\n\n  return new ATNConfig({\n    state: t.target\n  }, config);\n};\n\nParserATNSimulator.prototype.precedenceTransition = function (config, pt, collectPredicates, inContext, fullCtx) {\n  if (this.debug) {\n    console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.precedence + \">=_p, ctx dependent=true\");\n\n    if (this.parser !== null) {\n      console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n    }\n  }\n\n  var c = null;\n\n  if (collectPredicates && inContext) {\n    if (fullCtx) {\n      // In full context mode, we can evaluate predicates on-the-fly\n      // during closure, which dramatically reduces the size of\n      // the config sets. It also obviates the need to test predicates\n      // later during conflict resolution.\n      var currentPosition = this._input.index;\n\n      this._input.seek(this._startIndex);\n\n      var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n\n      this._input.seek(currentPosition);\n\n      if (predSucceeds) {\n        c = new ATNConfig({\n          state: pt.target\n        }, config); // no pred context\n      }\n    } else {\n      var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n      c = new ATNConfig({\n        state: pt.target,\n        semanticContext: newSemCtx\n      }, config);\n    }\n  } else {\n    c = new ATNConfig({\n      state: pt.target\n    }, config);\n  }\n\n  if (this.debug) {\n    console.log(\"config from pred transition=\" + c);\n  }\n\n  return c;\n};\n\nParserATNSimulator.prototype.predTransition = function (config, pt, collectPredicates, inContext, fullCtx) {\n  if (this.debug) {\n    console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex + \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n\n    if (this.parser !== null) {\n      console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n    }\n  }\n\n  var c = null;\n\n  if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {\n    if (fullCtx) {\n      // In full context mode, we can evaluate predicates on-the-fly\n      // during closure, which dramatically reduces the size of\n      // the config sets. It also obviates the need to test predicates\n      // later during conflict resolution.\n      var currentPosition = this._input.index;\n\n      this._input.seek(this._startIndex);\n\n      var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n\n      this._input.seek(currentPosition);\n\n      if (predSucceeds) {\n        c = new ATNConfig({\n          state: pt.target\n        }, config); // no pred context\n      }\n    } else {\n      var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n      c = new ATNConfig({\n        state: pt.target,\n        semanticContext: newSemCtx\n      }, config);\n    }\n  } else {\n    c = new ATNConfig({\n      state: pt.target\n    }, config);\n  }\n\n  if (this.debug) {\n    console.log(\"config from pred transition=\" + c);\n  }\n\n  return c;\n};\n\nParserATNSimulator.prototype.ruleTransition = function (config, t) {\n  if (this.debug) {\n    console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n  }\n\n  var returnState = t.followState;\n  var newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n  return new ATNConfig({\n    state: t.target,\n    context: newContext\n  }, config);\n};\n\nParserATNSimulator.prototype.getConflictingAlts = function (configs) {\n  var altsets = PredictionMode.getConflictingAltSubsets(configs);\n  return PredictionMode.getAlts(altsets);\n}; // Sam pointed out a problem with the previous definition, v3, of\n// ambiguous states. If we have another state associated with conflicting\n// alternatives, we should keep going. For example, the following grammar\n//\n// s : (ID | ID ID?) ';' ;\n//\n// When the ATN simulation reaches the state before ';', it has a DFA\n// state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n// 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n// because alternative to has another way to continue, via [6|2|[]].\n// The key is that we have a single state that has config's only associated\n// with a single alternative, 2, and crucially the state transitions\n// among the configurations are all non-epsilon transitions. That means\n// we don't consider any conflicts that include alternative 2. So, we\n// ignore the conflict between alts 1 and 2. We ignore a set of\n// conflicting alts when there is an intersection with an alternative\n// associated with a single alt state in the state&rarr;config-list map.\n//\n// It's also the case that we might have two conflicting configurations but\n// also a 3rd nonconflicting configuration for a different alternative:\n// [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n//\n// a : A | A | A B ;\n//\n// After matching input A, we reach the stop state for rule A, state 1.\n// State 8 is the state right before B. Clearly alternatives 1 and 2\n// conflict and no amount of further lookahead will separate the two.\n// However, alternative 3 will be able to continue and so we do not\n// stop working on this state. In the previous example, we're concerned\n// with states associated with the conflicting alternatives. Here alt\n// 3 is not associated with the conflicting configs, but since we can continue\n// looking for input reasonably, I don't declare the state done. We\n// ignore a set of conflicting alts when we have an alternative\n// that we still need to pursue.\n//\n\n\nParserATNSimulator.prototype.getConflictingAltsOrUniqueAlt = function (configs) {\n  var conflictingAlts = null;\n\n  if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n    conflictingAlts = new BitSet();\n    conflictingAlts.add(configs.uniqueAlt);\n  } else {\n    conflictingAlts = configs.conflictingAlts;\n  }\n\n  return conflictingAlts;\n};\n\nParserATNSimulator.prototype.getTokenName = function (t) {\n  if (t === Token.EOF) {\n    return \"EOF\";\n  }\n\n  if (this.parser !== null && this.parser.literalNames !== null) {\n    if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n      console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n      console.log(\"\" + this.parser.getInputStream().getTokens());\n    } else {\n      var name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n      return name + \"<\" + t + \">\";\n    }\n  }\n\n  return \"\" + t;\n};\n\nParserATNSimulator.prototype.getLookaheadName = function (input) {\n  return this.getTokenName(input.LA(1));\n}; // Used for debugging in adaptivePredict around execATN but I cut\n//  it out for clarity now that alg. works well. We can leave this\n//  \"dead\" code for a bit.\n//\n\n\nParserATNSimulator.prototype.dumpDeadEndConfigs = function (nvae) {\n  console.log(\"dead end configs: \");\n  var decs = nvae.getDeadEndConfigs();\n\n  for (var i = 0; i < decs.length; i++) {\n    var c = decs[i];\n    var trans = \"no edges\";\n\n    if (c.state.transitions.length > 0) {\n      var t = c.state.transitions[0];\n\n      if (t instanceof AtomTransition) {\n        trans = \"Atom \" + this.getTokenName(t.label);\n      } else if (t instanceof SetTransition) {\n        var neg = t instanceof NotSetTransition;\n        trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n      }\n    }\n\n    console.error(c.toString(this.parser, true) + \":\" + trans);\n  }\n};\n\nParserATNSimulator.prototype.noViableAlt = function (input, outerContext, configs, startIndex) {\n  return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n};\n\nParserATNSimulator.prototype.getUniqueAlt = function (configs) {\n  var alt = ATN.INVALID_ALT_NUMBER;\n\n  for (var i = 0; i < configs.items.length; i++) {\n    var c = configs.items[i];\n\n    if (alt === ATN.INVALID_ALT_NUMBER) {\n      alt = c.alt; // found first alt\n    } else if (c.alt !== alt) {\n      return ATN.INVALID_ALT_NUMBER;\n    }\n  }\n\n  return alt;\n}; //\n// Add an edge to the DFA, if possible. This method calls\n// {@link //addDFAState} to ensure the {@code to} state is present in the\n// DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n// range of edges that can be represented in the DFA tables, this method\n// returns without adding the edge to the DFA.\n//\n// <p>If {@code to} is {@code null}, this method returns {@code null}.\n// Otherwise, this method returns the {@link DFAState} returned by calling\n// {@link //addDFAState} for the {@code to} state.</p>\n//\n// @param dfa The DFA\n// @param from The source state for the edge\n// @param t The input symbol\n// @param to The target state for the edge\n//\n// @return If {@code to} is {@code null}, this method returns {@code null};\n// otherwise this method returns the result of calling {@link //addDFAState}\n// on {@code to}\n//\n\n\nParserATNSimulator.prototype.addDFAEdge = function (dfa, from_, t, to) {\n  if (this.debug) {\n    console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n  }\n\n  if (to === null) {\n    return null;\n  }\n\n  to = this.addDFAState(dfa, to); // used existing if possible not incoming\n\n  if (from_ === null || t < -1 || t > this.atn.maxTokenType) {\n    return to;\n  }\n\n  if (from_.edges === null) {\n    from_.edges = [];\n  }\n\n  from_.edges[t + 1] = to; // connect\n\n  if (this.debug) {\n    var literalNames = this.parser === null ? null : this.parser.literalNames;\n    var symbolicNames = this.parser === null ? null : this.parser.symbolicNames;\n    console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n  }\n\n  return to;\n}; //\n// Add state {@code D} to the DFA if it is not already present, and return\n// the actual instance stored in the DFA. If a state equivalent to {@code D}\n// is already in the DFA, the existing state is returned. Otherwise this\n// method returns {@code D} after adding it to the DFA.\n//\n// <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n// does not change the DFA.</p>\n//\n// @param dfa The dfa\n// @param D The DFA state to add\n// @return The state stored in the DFA. This will be either the existing\n// state if {@code D} is already in the DFA, or {@code D} itself if the\n// state was not already present.\n//\n\n\nParserATNSimulator.prototype.addDFAState = function (dfa, D) {\n  if (D == ATNSimulator.ERROR) {\n    return D;\n  }\n\n  var existing = dfa.states.get(D);\n\n  if (existing !== null) {\n    return existing;\n  }\n\n  D.stateNumber = dfa.states.length;\n\n  if (!D.configs.readOnly) {\n    D.configs.optimizeConfigs(this);\n    D.configs.setReadonly(true);\n  }\n\n  dfa.states.add(D);\n\n  if (this.debug) {\n    console.log(\"adding new DFA state: \" + D);\n  }\n\n  return D;\n};\n\nParserATNSimulator.prototype.reportAttemptingFullContext = function (dfa, conflictingAlts, configs, startIndex, stopIndex) {\n  if (this.debug || this.retry_debug) {\n    var interval = new Interval(startIndex, stopIndex + 1);\n    console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n  }\n\n  if (this.parser !== null) {\n    this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n  }\n};\n\nParserATNSimulator.prototype.reportContextSensitivity = function (dfa, prediction, configs, startIndex, stopIndex) {\n  if (this.debug || this.retry_debug) {\n    var interval = new Interval(startIndex, stopIndex + 1);\n    console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n  }\n\n  if (this.parser !== null) {\n    this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n  }\n}; // If context sensitive parsing, we know it's ambiguity not conflict//\n\n\nParserATNSimulator.prototype.reportAmbiguity = function (dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n  if (this.debug || this.retry_debug) {\n    var interval = new Interval(startIndex, stopIndex + 1);\n    console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs + \", input=\" + this.parser.getTokenStream().getText(interval));\n  }\n\n  if (this.parser !== null) {\n    this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n  }\n};\n\nexports.ParserATNSimulator = ParserATNSimulator;","map":null,"metadata":{},"sourceType":"script"}