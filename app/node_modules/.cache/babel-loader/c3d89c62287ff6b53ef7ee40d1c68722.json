{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar smart_1 = require(\"../smart\");\n\nvar Client_1 = require(\"../Client\");\n\nvar BrowserStorage_1 = require(\"../storage/BrowserStorage\");\n/**\n * Browser Adapter\n */\n\n\nvar BrowserAdapter = /*#__PURE__*/function () {\n  /**\n   * @param options Environment-specific options\n   */\n  function BrowserAdapter() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BrowserAdapter);\n\n    /**\n     * Stores the URL instance associated with this adapter\n     */\n    this._url = null;\n    /**\n     * Holds the Storage instance associated with this instance\n     */\n\n    this._storage = null;\n    this.options = Object.assign({\n      // Replaces the browser's current URL\n      // using window.history.replaceState API or by reloading.\n      replaceBrowserHistory: true,\n      // When set to true, this variable will fully utilize\n      // HTML5 sessionStorage API.\n      // This variable can be overridden to false by setting\n      // FHIR.oauth2.settings.fullSessionStorageSupport = false.\n      // When set to false, the sessionStorage will be keyed\n      // by a state variable. This is to allow the embedded IE browser\n      // instances instantiated on a single thread to continue to\n      // function without having sessionStorage data shared\n      // across the embedded IE instances.\n      fullSessionStorageSupport: true,\n      // Do we want to send cookies while making a request to the token\n      // endpoint in order to obtain new access token using existing\n      // refresh token. In rare cases the auth server might require the\n      // client to send cookies along with those requests. In this case\n      // developers will have to change this before initializing the app\n      // like so:\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"include\";`\n      // or\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"same-origin\";`\n      // Can be one of:\n      // \"include\"     - always send cookies\n      // \"same-origin\" - only send cookies if we are on the same domain (default)\n      // \"omit\"        - do not send cookies\n      refreshTokenWithCredentials: \"same-origin\"\n    }, options);\n  }\n  /**\n   * Given a relative path, returns an absolute url using the instance base URL\n   */\n\n\n  _createClass(BrowserAdapter, [{\n    key: \"relative\",\n    value: function relative(path) {\n      return new URL(path, this.getUrl().href).href;\n    }\n    /**\n     * In browsers we need to be able to (dynamically) check if fhir.js is\n     * included in the page. If it is, it should have created a \"fhir\" variable\n     * in the global scope.\n     */\n\n  }, {\n    key: \"fhir\",\n    get: function get() {\n      // @ts-ignore\n      return typeof fhir === \"function\" ? fhir : null;\n    }\n    /**\n     * Given the current environment, this method must return the current url\n     * as URL instance\n     */\n\n  }, {\n    key: \"getUrl\",\n    value: function getUrl() {\n      if (!this._url) {\n        this._url = new URL(location + \"\");\n      }\n\n      return this._url;\n    }\n    /**\n     * Given the current environment, this method must redirect to the given\n     * path\n     */\n\n  }, {\n    key: \"redirect\",\n    value: function redirect(to) {\n      location.href = to;\n    }\n    /**\n     * Returns a BrowserStorage object which is just a wrapper around\n     * sessionStorage\n     */\n\n  }, {\n    key: \"getStorage\",\n    value: function getStorage() {\n      if (!this._storage) {\n        this._storage = new BrowserStorage_1.default();\n      }\n\n      return this._storage;\n    }\n    /**\n     * Returns a reference to the AbortController constructor. In browsers,\n     * AbortController will always be available as global (native or polyfilled)\n     */\n\n  }, {\n    key: \"getAbortController\",\n    value: function getAbortController() {\n      return AbortController;\n    }\n    /**\n     * ASCII string to Base64\n     */\n\n  }, {\n    key: \"atob\",\n    value: function atob(str) {\n      return window.atob(str);\n    }\n    /**\n     * Base64 to ASCII string\n     */\n\n  }, {\n    key: \"btoa\",\n    value: function btoa(str) {\n      return window.btoa(str);\n    }\n    /**\n     * Creates and returns adapter-aware SMART api. Not that while the shape of\n     * the returned object is well known, the arguments to this function are not.\n     * Those who override this method are free to require any environment-specific\n     * arguments. For example in node we will need a request, a response and\n     * optionally a storage or storage factory function.\n     */\n\n  }, {\n    key: \"getSmartApi\",\n    value: function getSmartApi() {\n      var _this = this;\n\n      return {\n        ready: function ready() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return smart_1.ready.apply(smart_1, [_this].concat(args));\n        },\n        authorize: function authorize(options) {\n          return smart_1.authorize(_this, options);\n        },\n        init: function init(options) {\n          return smart_1.init(_this, options);\n        },\n        client: function client(state) {\n          return new Client_1.default(_this, state);\n        },\n        options: this.options\n      };\n    }\n  }]);\n\n  return BrowserAdapter;\n}();\n\nexports.default = BrowserAdapter;","map":null,"metadata":{},"sourceType":"script"}