{"ast":null,"code":"// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\nvar util = require(\"./utilities\");\n\nvar types = require(\"./types\");\n\nconst {\n  FP_Quantity\n} = types;\nvar engine = {};\n\nengine.iifMacro = function (data, cond, ok, fail) {\n  if (util.isTrue(cond(data))) {\n    return ok(data);\n  } else {\n    return fail ? fail(data) : [];\n  }\n};\n\nengine.traceFn = function (x, label) {\n  console.log(\"TRACE:[\" + (label || \"\") + \"]\", JSON.stringify(x, null, \" \"));\n  return x;\n};\n\nvar intRegex = /^[+-]?\\d+$/;\n\nengine.toInteger = function (coll) {\n  if (coll.length !== 1) {\n    return [];\n  }\n\n  var v = util.valData(coll[0]);\n\n  if (v === false) {\n    return 0;\n  }\n\n  if (v === true) {\n    return 1;\n  }\n\n  if (typeof v === \"number\") {\n    if (Number.isInteger(v)) {\n      return v;\n    } else {\n      return [];\n    }\n  }\n\n  if (typeof v === \"string\" && intRegex.test(v)) {\n    return parseInt(v);\n  }\n\n  return [];\n};\n\nconst quantityRegex = /^((\\+|-)?\\d+(\\.\\d+)?)\\s*(('[^']+')|([a-zA-Z]+))?$/,\n      quantityRegexMap = {\n  value: 1,\n  unit: 5,\n  time: 6\n};\n\nengine.toQuantity = function (coll, toUnit) {\n  let result; // Surround UCUM unit code in the toUnit parameter with single quotes\n\n  if (toUnit && !FP_Quantity.mapTimeUnitsToUCUMCode[toUnit]) {\n    toUnit = `'${toUnit}'`;\n  }\n\n  if (coll.length > 1) {\n    throw new Error(\"Could not convert to quantity: input collection contains multiple items\");\n  } else if (coll.length === 1) {\n    const item = coll[0],\n          v = util.valData(item);\n    let quantityRegexRes;\n\n    if (typeof v === \"number\") {\n      result = new FP_Quantity(v, '\\'1\\'');\n    } else if (v instanceof FP_Quantity) {\n      result = v;\n    } else if (typeof v === 'boolean') {\n      result = new FP_Quantity(v ? 1 : 0, '\\'1\\'');\n    } else if (typeof v === \"string\" && (quantityRegexRes = quantityRegex.exec(v))) {\n      const value = quantityRegexRes[quantityRegexMap.value],\n            unit = quantityRegexRes[quantityRegexMap.unit],\n            time = quantityRegexRes[quantityRegexMap.time]; // UCUM unit code in the input string must be surrounded with single quotes\n\n      if (!time || FP_Quantity.mapTimeUnitsToUCUMCode[time]) {\n        result = new FP_Quantity(Number(value), unit || time || '\\'1\\'');\n      }\n    }\n\n    if (result && toUnit && result.unit !== toUnit) {\n      result = FP_Quantity.convUnitTo(result.unit, result.value, toUnit);\n    }\n  }\n\n  return result || [];\n};\n\nvar numRegex = /^[+-]?\\d+(\\.\\d+)?$/;\n\nengine.toDecimal = function (coll) {\n  if (coll.length !== 1) {\n    return [];\n  }\n\n  var v = util.valData(coll[0]);\n\n  if (v === false) {\n    return 0;\n  }\n\n  if (v === true) {\n    return 1.0;\n  }\n\n  if (typeof v === \"number\") {\n    return v;\n  }\n\n  if (typeof v === \"string\" && numRegex.test(v)) {\n    return parseFloat(v);\n  }\n\n  return [];\n};\n\nengine.toString = function (coll) {\n  if (coll.length !== 1) {\n    return [];\n  }\n\n  var v = util.valData(coll[0]);\n  return v.toString();\n};\n/**\n *  Defines a function on engine called to+timeType (e.g., toDateTime, etc.).\n * @param timeType The string name of a class for a time type (e.g. \"FP_DateTime\").\n */\n\n\nfunction defineTimeConverter(timeType) {\n  let timeName = timeType.slice(3); // Remove 'FP_'\n\n  engine['to' + timeName] = function (coll) {\n    var rtn = [];\n    if (coll.length > 1) throw Error('to ' + timeName + ' called for a collection of length ' + coll.length);\n\n    if (coll.length === 1) {\n      var t = types[timeType].checkString(util.valData(coll[0]));\n      if (t) rtn = t;\n    }\n\n    return rtn;\n  };\n}\n\ndefineTimeConverter('FP_DateTime');\ndefineTimeConverter('FP_Time'); // Possible string values convertible to the true boolean value\n\nconst trueStrings = ['true', 't', 'yes', 'y', '1', '1.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {}); // Possible string values convertible to the false boolean value\n\nconst falseStrings = ['false', 'f', 'no', 'n', '0', '0.0'].reduce((acc, val) => {\n  acc[val] = true;\n  return acc;\n}, {});\n\nengine.toBoolean = function (coll) {\n  if (coll.length !== 1) {\n    return [];\n  }\n\n  const v = util.valData(coll[0]);\n\n  switch (typeof v) {\n    case 'boolean':\n      return v;\n\n    case 'number':\n      if (v === 1) {\n        return true;\n      }\n\n      if (v === 0) {\n        return false;\n      }\n\n      break;\n\n    case 'string':\n      // eslint-disable-next-line no-case-declarations\n      const lowerCaseValue = v.toLowerCase();\n\n      if (trueStrings[lowerCaseValue]) {\n        return true;\n      }\n\n      if (falseStrings[lowerCaseValue]) {\n        return false;\n      }\n\n  }\n\n  return [];\n};\n/**\n * Creates function that checks if toFunction returns specified type\n * @param {function(coll: array): <type|[]>} toFunction\n * @param {string|class} type - specifies type, for example: 'string' or FP_Quantity\n * @return {function(coll: array)}\n */\n\n\nengine.createConvertsToFn = function (toFunction, type) {\n  if (typeof type === 'string') {\n    return function (coll) {\n      if (coll.length !== 1) {\n        return [];\n      }\n\n      return typeof toFunction(coll) === type;\n    };\n  }\n\n  return function (coll) {\n    if (coll.length !== 1) {\n      return [];\n    }\n\n    return toFunction(coll) instanceof type;\n  };\n};\n\nconst singletonEvalByType = {\n  \"Integer\": function (coll) {\n    const d = util.valData(coll[0]);\n\n    if (Number.isInteger(d)) {\n      return d;\n    }\n  },\n  \"Boolean\": function (coll) {\n    const d = util.valData(coll[0]);\n\n    if (d === true || d === false) {\n      return d;\n    } else if (coll.length === 1) {\n      return true;\n    }\n  },\n  \"Number\": function (coll) {\n    const d = util.valData(coll[0]);\n\n    if (typeof d === \"number\") {\n      return d;\n    }\n  },\n  \"String\": function (coll) {\n    const d = util.valData(coll[0]);\n\n    if (typeof d === \"string\") {\n      return d;\n    }\n  }\n};\n/**\n * Converts a collection to a singleton of the specified type.\n * The result can be an empty array if input collection is empty.\n * See http://hl7.org/fhirpath/#singleton-evaluation-of-collections for details.\n * @param {Array} coll - collection\n * @param {string} type - 'Integer', 'Boolean', 'Number' or 'String'\n * @throws {Error}  if there is more than one item in input collection,\n *   or an item that is not a specified type\n * @return {*|[]} the value of specified type or empty array\n */\n\nengine.singleton = function (coll, type) {\n  if (coll.length > 1) {\n    throw new Error(\"Unexpected collection\" + JSON.stringify(coll) + \"; expected singleton of type \" + type);\n  } else if (coll.length === 0) {\n    return [];\n  }\n\n  const toSingleton = singletonEvalByType[type];\n\n  if (toSingleton) {\n    const value = toSingleton(coll);\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    throw new Error(`Expected ${type.toLowerCase()}, but got: ${JSON.stringify(coll)}`);\n  }\n\n  throw new Error('Not supported type ' + type);\n};\n\nmodule.exports = engine;","map":null,"metadata":{},"sourceType":"script"}