{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//* A rule invocation record for parsing.\n//\n//  Contains all of the information about the current rule not stored in the\n//  RuleContext. It handles parse tree children list, Any ATN state\n//  tracing, and the default values available for rule indications:\n//  start, stop, rule index, current alt number, current\n//  ATN state.\n//\n//  Subclasses made for each rule and grammar track the parameters,\n//  return values, locals, and labels specific to that rule. These\n//  are the objects that are returned from rules.\n//\n//  Note text is not an actual field of a rule return value; it is computed\n//  from start and stop using the input stream's toString() method.  I\n//  could add a ctor to this so that we can pass in and store the input\n//  stream, but I'm not sure we want to do that.  It would seem to be undefined\n//  to get the .text property anyway if the rule matches tokens from multiple\n//  input streams.\n//\n//  I do not use getters for fields of objects that are used simply to\n//  group values such as this aggregate.  The getters/setters are there to\n//  satisfy the superclass interface.\nvar RuleContext = require('./RuleContext').RuleContext;\n\nvar Tree = require('./tree/Tree');\n\nvar INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nvar TerminalNode = Tree.TerminalNode;\nvar TerminalNodeImpl = Tree.TerminalNodeImpl;\nvar ErrorNodeImpl = Tree.ErrorNodeImpl;\n\nvar Interval = require(\"./IntervalSet\").Interval;\n\nfunction ParserRuleContext(parent, invokingStateNumber) {\n  parent = parent || null;\n  invokingStateNumber = invokingStateNumber || null;\n  RuleContext.call(this, parent, invokingStateNumber);\n  this.ruleIndex = -1; // * If we are debugging or building a parse tree for a visitor,\n  // we need to track all of the tokens and rule invocations associated\n  // with this rule's context. This is empty for parsing w/o tree constr.\n  // operation because we don't the need to track the details about\n  // how we parse this rule.\n  // /\n\n  this.children = null;\n  this.start = null;\n  this.stop = null; // The exception that forced this rule to return. If the rule successfully\n  // completed, this is {@code null}.\n\n  this.exception = null;\n}\n\nParserRuleContext.prototype = Object.create(RuleContext.prototype);\nParserRuleContext.prototype.constructor = ParserRuleContext; // * COPY a ctx (I'm deliberately not using copy constructor)///\n\nParserRuleContext.prototype.copyFrom = function (ctx) {\n  // from RuleContext\n  this.parentCtx = ctx.parentCtx;\n  this.invokingState = ctx.invokingState;\n  this.children = null;\n  this.start = ctx.start;\n  this.stop = ctx.stop; // copy any error nodes to alt label node\n\n  if (ctx.children) {\n    this.children = []; // reset parent pointer for any error nodes\n\n    ctx.children.map(function (child) {\n      if (child instanceof ErrorNodeImpl) {\n        this.children.push(child);\n        child.parentCtx = this;\n      }\n    }, this);\n  }\n}; // Double dispatch methods for listeners\n\n\nParserRuleContext.prototype.enterRule = function (listener) {};\n\nParserRuleContext.prototype.exitRule = function (listener) {}; // * Does not set parent link; other add methods do that///\n\n\nParserRuleContext.prototype.addChild = function (child) {\n  if (this.children === null) {\n    this.children = [];\n  }\n\n  this.children.push(child);\n  return child;\n}; // * Used by enterOuterAlt to toss out a RuleContext previously added as\n// we entered a rule. If we have // label, we will need to remove\n// generic ruleContext object.\n// /\n\n\nParserRuleContext.prototype.removeLastChild = function () {\n  if (this.children !== null) {\n    this.children.pop();\n  }\n};\n\nParserRuleContext.prototype.addTokenNode = function (token) {\n  var node = new TerminalNodeImpl(token);\n  this.addChild(node);\n  node.parentCtx = this;\n  return node;\n};\n\nParserRuleContext.prototype.addErrorNode = function (badToken) {\n  var node = new ErrorNodeImpl(badToken);\n  this.addChild(node);\n  node.parentCtx = this;\n  return node;\n};\n\nParserRuleContext.prototype.getChild = function (i, type) {\n  type = type || null;\n\n  if (this.children === null || i < 0 || i >= this.children.length) {\n    return null;\n  }\n\n  if (type === null) {\n    return this.children[i];\n  } else {\n    for (var j = 0; j < this.children.length; j++) {\n      var child = this.children[j];\n\n      if (child instanceof type) {\n        if (i === 0) {\n          return child;\n        } else {\n          i -= 1;\n        }\n      }\n    }\n\n    return null;\n  }\n};\n\nParserRuleContext.prototype.getToken = function (ttype, i) {\n  if (this.children === null || i < 0 || i >= this.children.length) {\n    return null;\n  }\n\n  for (var j = 0; j < this.children.length; j++) {\n    var child = this.children[j];\n\n    if (child instanceof TerminalNode) {\n      if (child.symbol.type === ttype) {\n        if (i === 0) {\n          return child;\n        } else {\n          i -= 1;\n        }\n      }\n    }\n  }\n\n  return null;\n};\n\nParserRuleContext.prototype.getTokens = function (ttype) {\n  if (this.children === null) {\n    return [];\n  } else {\n    var tokens = [];\n\n    for (var j = 0; j < this.children.length; j++) {\n      var child = this.children[j];\n\n      if (child instanceof TerminalNode) {\n        if (child.symbol.type === ttype) {\n          tokens.push(child);\n        }\n      }\n    }\n\n    return tokens;\n  }\n};\n\nParserRuleContext.prototype.getTypedRuleContext = function (ctxType, i) {\n  return this.getChild(i, ctxType);\n};\n\nParserRuleContext.prototype.getTypedRuleContexts = function (ctxType) {\n  if (this.children === null) {\n    return [];\n  } else {\n    var contexts = [];\n\n    for (var j = 0; j < this.children.length; j++) {\n      var child = this.children[j];\n\n      if (child instanceof ctxType) {\n        contexts.push(child);\n      }\n    }\n\n    return contexts;\n  }\n};\n\nParserRuleContext.prototype.getChildCount = function () {\n  if (this.children === null) {\n    return 0;\n  } else {\n    return this.children.length;\n  }\n};\n\nParserRuleContext.prototype.getSourceInterval = function () {\n  if (this.start === null || this.stop === null) {\n    return INVALID_INTERVAL;\n  } else {\n    return new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n  }\n};\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nfunction InterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {\n  ParserRuleContext.call(parent, invokingStateNumber);\n  this.ruleIndex = ruleIndex;\n  return this;\n}\n\nInterpreterRuleContext.prototype = Object.create(ParserRuleContext.prototype);\nInterpreterRuleContext.prototype.constructor = InterpreterRuleContext;\nexports.ParserRuleContext = ParserRuleContext;","map":null,"metadata":{},"sourceType":"script"}