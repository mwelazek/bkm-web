{"ast":null,"code":"import * as React from 'react';\nimport classNames from 'classnames';\nimport { Label } from './../../atoms/label';\nimport { Spinner } from '../spinner/';\nimport ValidationError from './../../molecules/form/validation-error';\nimport './styles.scss';\nexport default class SafeInputField extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.renderLabel = () => {\n      if (this.props.label !== undefined) {\n        const labelText = React.createElement(React.Fragment, null, this.props.label, this.props.isRequired && this.props.requiredLabel && this.props.showRequiredLabel ? React.createElement(\"em\", null, \" \", this.props.requiredLabel) : '', this.props.isRequired && this.props.requiredLabelHtml && this.props.showRequiredLabel ? React.createElement(\"span\", {\n          dangerouslySetInnerHTML: this.createMarkup(this.props.requiredLabelHtml)\n        }) : '', !this.props.isRequired && this.props.optionalLabel && this.props.showOptionalLabel ? React.createElement(\"em\", null, \" \", this.props.optionalLabel) : '');\n        return React.createElement(Label, {\n          labelText: labelText,\n          htmlFor: this.props.inputName,\n          sublabelText: this.props.subLabel,\n          testId: this.props.labelTestId,\n          helpButton: this.props.helpButton\n        });\n      }\n\n      return null;\n    };\n\n    this.state = {\n      focused: false,\n      isValid: true,\n      value: undefined,\n      validated: false,\n      loading: false,\n      dirtyInput: false\n    };\n    this.inputFieldRef = React.createRef();\n    this.onChange = this.onChange.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.notifyChanged = this.notifyChanged.bind(this);\n    this.notifyValidated = this.notifyValidated.bind(this);\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.onFocus = this.onFocus.bind(this);\n    this.onBlur = this.onBlur.bind(this);\n    this.focus = this.focus.bind(this);\n    this.isTypeNumber = this.isTypeNumber.bind(this);\n    this.validate = this.validate.bind(this);\n    this.validateNumber = this.validateNumber.bind(this);\n    this.validateField = this.validateField.bind(this);\n    this.isValidIfRequired = this.isValidIfRequired.bind(this);\n    this.isValid = this.isValid.bind(this);\n    this.renderErrorMessage = this.renderErrorMessage.bind(this);\n    this.renderLabel = this.renderLabel.bind(this);\n    this.getInputClasses = this.getInputClasses.bind(this);\n  }\n\n  componentDidMount() {\n    const {\n      value\n    } = this.props;\n    this.setState({\n      value\n    }, () => {\n      if (value === '' || value === null || value === undefined) {\n        return;\n      } else {\n        if (!this.validate(value)) {\n          this.setState({\n            isValid: false,\n            validated: true\n          });\n        } else if (this.props.onChangeValidator && !this.props.onChangeValidator(value)) {\n          this.setState({\n            isValid: false,\n            validated: true\n          });\n        } else if (this.props.onBlurValidator) {\n          this.props.onBlurValidator(value).then(isValid => {\n            this.setState({\n              isValid,\n              validated: true\n            });\n          });\n        }\n      }\n    });\n  }\n\n  componentDidUpdate(_prevProps, prevState) {\n    if (prevState.isValid !== this.state.isValid) {\n      this.notifyValidated();\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (this.props.validateOnExternalUpdate && this.state.value !== nextProps.value) {\n      this.handleChange(nextProps.value);\n    } else {\n      if (!this.state.focused) {\n        this.setState({\n          value: nextProps.value\n        });\n      }\n    }\n  }\n\n  onChange(e) {\n    const value = e.target.value;\n    this.handleChange(value, formattedValue => this.notifyChanged(e, formattedValue));\n  }\n\n  handleChange(value, notify) {\n    let formattedValue = value;\n\n    if (this.props.onChangeFormatter) {\n      formattedValue = this.props.onChangeFormatter(value);\n    }\n\n    if (formattedValue !== this.state.value) {\n      this.setState({\n        value: formattedValue,\n        dirtyInput: true\n      });\n\n      if (this.inputFieldRef.current) {\n        this.inputFieldRef.current.value = formattedValue;\n      }\n\n      if (!this.validate(formattedValue)) {\n        this.setState({\n          isValid: false\n        });\n      } else if (this.props.onChangeValidator && this.state.validated) {\n        this.setState({\n          isValid: this.props.onChangeValidator(value)\n        });\n      } else {\n        this.setState({\n          isValid: true\n        });\n      }\n\n      if (notify) {\n        notify(formattedValue);\n      }\n\n      if (!formattedValue || this.isValueOverMaxLength(formattedValue)) {\n        this.setState({\n          validated: !formattedValue ? false : true\n        });\n      }\n    }\n  }\n\n  notifyChanged(e, formattedValue) {\n    if (this.props.onChange) {\n      this.props.onChange(e, this.props.id, formattedValue);\n    }\n  }\n\n  notifyValidated() {\n    if (this.props.onValidated) {\n      this.props.onValidated(this.state.isValid);\n    }\n  }\n\n  onMouseDown() {\n    if (this.props.type !== 'number') {\n      return;\n    }\n\n    if (this.state.focused) {\n      return;\n    }\n\n    this.focus();\n  }\n\n  onFocus(e) {\n    this.setState({\n      focused: true\n    });\n\n    if (this.props.onFocus) {\n      this.props.onFocus(e, this.props.id);\n    }\n  }\n\n  onBlur(e) {\n    e.persist();\n    const value = e.target.value;\n    this.setState({\n      focused: false\n    });\n    let state = null;\n\n    if (this.state.dirtyInput) {\n      if (!this.validate(value)) {\n        state = {\n          isValid: false,\n          validated: true,\n          dirtyInput: false\n        };\n      } else if (typeof value === 'string' && this.props.minLength && value && value.length < this.props.minLength) {\n        state = {\n          isValid: false,\n          validated: true,\n          dirtyInput: false\n        };\n      } else if (value !== '' && this.props.onChangeValidator && !this.props.onChangeValidator(value)) {\n        state = {\n          isValid: false,\n          validated: true,\n          dirtyInput: false\n        };\n      } else if (value !== '' && this.props.onBlurValidator) {\n        state = {\n          loading: true,\n          onBlurValidationPromise: this.props.onBlurValidator(value)\n        };\n      }\n    }\n\n    if (state) {\n      this.setState(state, () => {\n        if (this.props.onBlurValidator && this.state.onBlurValidationPromise) {\n          this.state.onBlurValidationPromise.then(isValid => {\n            this.setState({\n              isValid,\n              validated: true,\n              loading: false,\n              dirtyInput: false,\n              onBlurValidationPromise: undefined\n            });\n          });\n        }\n\n        if (this.props.onBlur) {\n          this.props.onBlur(e);\n        }\n      });\n    } else {\n      if (this.props.onBlur) {\n        this.props.onBlur(e);\n      }\n    }\n  }\n\n  focus() {\n    if (this.inputFieldRef.current) this.inputFieldRef.current.focus();\n  }\n\n  isTypeNumber() {\n    return this.props.type === 'number' || this.props.type === 'tel';\n  }\n\n  validate(value) {\n    if (this.isTypeNumber() && !this.validateNumber(value)) {\n      return false;\n    }\n\n    if (typeof value === 'string' && !this.state.isValid && this.props.minLength && value && value.length < this.props.minLength) {\n      return false;\n    }\n\n    if (this.isValueOverMaxLength(value)) {\n      return false;\n    }\n\n    if (this.props.pattern && value) {\n      const regexp = new RegExp(this.props.pattern);\n\n      if (!regexp.test(value.toString())) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  isValueOverMaxLength(value) {\n    return typeof value === 'string' && this.props.maxLength && value && value.length > this.props.maxLength;\n  }\n\n  validateNumber(value) {\n    const {\n      min,\n      max\n    } = this.props;\n\n    if (!value) {\n      return true;\n    }\n\n    if (min !== null && min !== undefined && value < min) {\n      return false;\n    }\n\n    if (max !== null && max !== undefined && value > max) {\n      return false;\n    }\n\n    return true;\n  }\n\n  validateField() {\n    return new Promise(resolve => {\n      if (this.props.onSubmitValidator) {\n        this.setState({\n          isValid: this.props.onSubmitValidator(this.state.value),\n          validated: true\n        });\n        resolve();\n      } else if (!this.isValidIfRequired()) {\n        this.setState({\n          isValid: false,\n          validated: true\n        });\n        resolve();\n      } else if (this.state.onBlurValidationPromise) {\n        this.state.onBlurValidationPromise.then(() => {\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  isValidIfRequired() {\n    if (this.props.isRequired) {\n      return this.state.value !== null && this.state.value !== undefined && this.state.value.toString().trim() !== '';\n    }\n\n    return true;\n  }\n\n  isValid() {\n    return this.state.isValid;\n  }\n\n  renderErrorMessage() {\n    if (this.props.isValidationHidden || !this.state.validated) {\n      return null;\n    }\n\n    if (this.props.validationErrorRenderer && !this.state.isValid) {\n      return this.props.validationErrorRenderer;\n    }\n\n    let error;\n\n    if (!this.state.isValid) {\n      if (this.props.isRequired && !this.isValidIfRequired() && this.props.requiredErrorMessage) {\n        error = typeof this.props.requiredErrorMessage === 'string' ? this.props.requiredErrorMessage : this.props.requiredErrorMessage(this.state.value);\n      } else if (this.props.errorMessage) {\n        error = typeof this.props.errorMessage === 'string' ? this.props.errorMessage : this.props.errorMessage(this.state.value);\n      } else {\n        error = 'Ugyldig verdi';\n      }\n\n      if (this.isValueOverMaxLength(this.state.value)) {\n        error = this.props.stringOverMaxLengthError ? this.props.stringOverMaxLengthError : 'Du har skrevet for mange tegn. Gjør teksten kortere.';\n      }\n    }\n\n    if (!error) {\n      return null;\n    }\n\n    return React.createElement(ValidationError, {\n      isValid: this.state.isValid,\n      error: error,\n      testId: this.props.validationTestId\n    });\n  }\n\n  createMarkup(htmlString) {\n    return {\n      __html: htmlString\n    };\n  }\n\n  getInputClasses() {\n    if (this.props.maxLength) {\n      const max = this.props.maxLength > 40 ? 40 : this.props.maxLength;\n      return `atom_input--${max}`;\n    } else if (this.props.max && (this.props.type === 'number' || this.props.type === 'tel')) {\n      const length = this.props.max.toString().length;\n      return `atom_input--${length}`;\n    } else {\n      return '';\n    }\n  }\n\n  render() {\n    const {\n      className,\n      disabled,\n      size,\n      blurSpinnerAlignment,\n      keepDefaultSize,\n      isRequired,\n      id,\n      inputName,\n      tabIndex,\n      min,\n      max,\n      minLength,\n      type,\n      wrapperClasses,\n      isValidationHidden,\n      placeholder,\n      onKeyDown,\n      ariaLabel,\n      ariaLabelledby,\n      ariaRequired,\n      inputProps,\n      readOnly,\n      helpElement,\n      autocomplete,\n      inputTestId\n    } = this.props;\n    const {\n      value,\n      isValid,\n      validated,\n      loading\n    } = this.state;\n    const inputValue = typeof value === 'string' ? value : value ? value.toString() : '';\n    const inputClasses = classNames('hn-safe-input', 'atom_input', className, {\n      'safeInputFieldError atom_input--state_validationerror': validated && !isValid,\n      'atom_input--xsmall': size === 'xSmall',\n      'atom_input--small': size === 'small',\n      'atom_input--medium': size === 'medium',\n      'atom_input--large': size === 'large',\n      'atom_input--xlarge': size === 'xLarge',\n      atom_input: size === 'fullSize',\n      'atom_input--loading': loading,\n      'atom_input--spinnerright': blurSpinnerAlignment === 'right',\n      'atom_input--disabled': disabled\n    }, keepDefaultSize ? '' : this.getInputClasses());\n    const classes = classNames('safeInputField', wrapperClasses, {\n      mol_validation: !isValidationHidden,\n      'mol_validation--active': !isValidationHidden && validated && !isValid\n    });\n    let required = false;\n\n    if (isRequired) {\n      required = isRequired;\n    }\n\n    const ariaInvalid = {};\n\n    if (validated) {\n      ariaInvalid['aria-invalid'] = validated && !isValid;\n    }\n\n    return React.createElement(\"div\", {\n      className: classes,\n      id: `${id}-wrapper`\n    }, this.renderErrorMessage(), this.renderLabel(), helpElement ? helpElement : null, React.createElement(\"input\", Object.assign({\n      ref: this.inputFieldRef,\n      id: inputName,\n      name: inputName,\n      type: type ? type : 'text',\n      value: inputValue,\n      placeholder: placeholder,\n      className: inputClasses,\n      min: min,\n      max: max,\n      minLength: minLength,\n      autoComplete: autocomplete || 'off',\n      tabIndex: tabIndex,\n      \"data-testid\": inputTestId,\n      onChange: this.onChange,\n      onBlur: this.onBlur,\n      onFocus: this.onFocus,\n      onMouseDown: this.onMouseDown,\n      onKeyDown: onKeyDown,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledby,\n      \"aria-required\": ariaRequired || required,\n      required: required,\n      disabled: disabled,\n      readOnly: readOnly\n    }, inputProps, ariaInvalid)), loading ? React.createElement(Spinner, {\n      circular: true,\n      inline: true,\n      local: true,\n      className: \"atom_input__spinner\"\n    }) : null, this.props.children);\n  }\n\n}\nSafeInputField.hnFormComponent = true;\nSafeInputField.defaultProps = {\n  id: undefined,\n  onBlur: undefined,\n  value: undefined,\n  showRequiredLabel: true,\n  readOnly: false,\n  size: 'medium',\n  blurSpinnerAlignment: 'left',\n  isValidationHidden: false\n};","map":null,"metadata":{},"sourceType":"module"}