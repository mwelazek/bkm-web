{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport moment from 'moment';\nimport 'react-dates/initialize';\nimport { LanguageLocales } from '@helsenorge/core-utils/constants/languages';\nimport { isMobileUA } from '@helsenorge/core-utils/user-agents-utils';\nimport ValidationError from '../form/validation-error';\nimport { DEFAULT_DATE_PLACEHOLDER_NB, DEFAULT_DATE_PLACEHOLDER_EN, DEFAULT_STARTDATE_PLACEHOLDER, DEFAULT_ENDDATE_PLACEHOLDER } from './../../../constants/datetime';\nimport { renderDesktopDatePicker } from './date-range-picker-desktop';\nimport { DateRangePickerLabel } from './date-range-picker-label';\nimport { renderMobileDatePicker } from './date-range-picker-mobile';\nimport { START_DATE_ID, END_DATE_ID, Phrases, ErrorPhrases, getCSSClasses, getDateNOString, notifyValidated, getDefaultVisibleMonth } from './date-range-picker-utils';\nimport { validateSingleDate, validateRangeDate, isPrevMonthValid, isNextMonthValid } from './date-range-picker-validation';\nimport 'react-dates/lib/css/_datepicker.css';\nimport toolkitstyles from './styles.module.scss';\nexport class DateRangePicker extends React.Component {\n  constructor(props) {\n    var _a, _b, _c;\n\n    super(props);\n\n    this.onSingleDateChange = singleDate => {\n      this.setState({\n        singleDate\n      });\n      this.props.onDateChange && this.props.onDateChange(singleDate, this.props.id);\n    };\n\n    this.onStartDateChange = startDate => {\n      this.setState({\n        startDate\n      });\n      this.props.onDateChange && this.props.onDateChange({\n        start: startDate,\n        end: this.state.endDate\n      }, this.props.id);\n    };\n\n    this.onEndDateChange = endDate => {\n      this.setState({\n        endDate\n      });\n      this.props.onDateChange && this.props.onDateChange({\n        start: this.state.startDate,\n        end: endDate\n      }, this.props.id);\n    };\n\n    this.onRangeDatesChange = _ref => {\n      let {\n        startDate,\n        endDate\n      } = _ref;\n      this.setState({\n        startDate,\n        endDate\n      });\n      this.props.onDateChange && this.props.onDateChange({\n        start: startDate,\n        end: endDate\n      }, this.props.id);\n    };\n\n    this.singleDateValidator = date => {\n      const {\n        id,\n        isRequired,\n        errorResources,\n        minimumDate,\n        maximumDate,\n        dateValidator,\n        onValidated,\n        onError\n      } = this.props;\n      const v = validateSingleDate(this.airbnbSingleDatepickerRef, date, id, isRequired, errorResources, minimumDate, maximumDate, dateValidator);\n      return new Promise(resolve => {\n        this.setState({\n          validated: true,\n          isSingleDateValid: v.isSingleDateValid,\n          errorString: v.errorString\n        }, () => {\n          notifyValidated(id, date, v.isSingleDateValid, v.errorString, onValidated, onError);\n          resolve();\n        });\n      });\n    };\n\n    this.rangeDateValidator = (startDate, endDate) => {\n      const {\n        id,\n        isRequired,\n        errorResources,\n        minimumDate,\n        maximumDate,\n        minimumPeriod,\n        dateValidator,\n        onValidated,\n        onError\n      } = this.props;\n      const v = validateRangeDate(this.airbnbDateRangepickerRef, startDate, endDate, id, isRequired, errorResources, minimumDate, maximumDate, minimumPeriod, dateValidator);\n      return new Promise(resolve => {\n        this.setState({\n          validated: true,\n          isRangeDateValid: v.isRangeDateValid,\n          errorString: v.errorString\n        }, () => {\n          notifyValidated(id, {\n            start: startDate,\n            end: endDate\n          }, v.isRangeDateValid, v.errorString, onValidated, onError);\n          resolve();\n        });\n      });\n    };\n\n    this.onSingleDateFocusChange = _ref2 => {\n      let {\n        focused\n      } = _ref2;\n\n      if (!focused) {\n        setTimeout(() => {\n          this.validateField();\n        }, 0);\n      }\n\n      if (focused !== this.state.isSingleDateFocused) {\n        this.setState({\n          isSingleDateFocused: focused\n        });\n      }\n    };\n\n    this.onRangeDatesFocusChange = focusedInput => {\n      setTimeout(() => {\n        if (this.state.focusedInput === null) {\n          this.validateField();\n          this.setState({\n            isFocusReset: true\n          });\n        }\n      }, 0);\n      this.setState({\n        focusedInput\n      });\n\n      if (this.state.isFocusReset) {\n        this.setState({\n          isFocusReset: false\n        });\n      }\n    };\n\n    this.onCalenderIconClick = () => {\n      if (this.state.isSingleDateFocused) {\n        this.setState({\n          isSingleDateFocused: false\n        });\n      } else if (this.state.focusedInput) {\n        this.setState({\n          focusedInput: null\n        });\n      }\n\n      this.setState({\n        isFocusReset: true\n      });\n    };\n\n    this.getErrorString = () => this.state.errorString;\n\n    this.onBlurHandler = () => {\n      this.validateField();\n      this.setState({\n        isFocusReset: true\n      });\n    };\n\n    this.disableMonthSelectorHandler = date => {\n      const disabledNext = !isNextMonthValid(date, this.props.maximumDate);\n      this.setState({\n        isNextMonthDisabled: disabledNext\n      });\n      const disabledPrev = !isPrevMonthValid(date, this.props.minimumDate);\n      this.setState({\n        isPrevMonthDisabled: disabledPrev\n      });\n    };\n\n    this.onChangeVisibleMonthHandler = date => {\n      this.setState({\n        visibleMonth: date\n      });\n    };\n\n    const momentLocale = moment();\n\n    if (props.locale === LanguageLocales.ENGLISH) {\n      require('moment/locale/en-gb');\n\n      momentLocale.locale('en-gb');\n    } else {\n      require('moment/locale/nb');\n\n      momentLocale.locale('nb');\n    }\n\n    this.airbnbSingleDatepickerRef = React.createRef();\n    this.airbnbDateRangepickerRef = React.createRef();\n    this.state = {\n      isMobile: isMobileUA(),\n      momentLocale: momentLocale.localeData(),\n      placeholder: props.placeholder ? props.placeholder : props.locale === LanguageLocales.ENGLISH ? DEFAULT_DATE_PLACEHOLDER_EN : DEFAULT_DATE_PLACEHOLDER_NB,\n      singleDate: (_a = props.singleDateValue) !== null && _a !== void 0 ? _a : null,\n      isSingleDateFocused: null,\n      isSingleDateValid: true,\n      startDate: (_b = props.startDateValue) !== null && _b !== void 0 ? _b : null,\n      endDate: (_c = props.endDateValue) !== null && _c !== void 0 ? _c : null,\n      isRangeDateValid: true,\n      validated: false,\n      focusedInput: null,\n      visibleMonth: getDefaultVisibleMonth(props)\n    };\n  }\n\n  componentDidMount() {\n    this.disableMonthSelectorHandler(this.state.visibleMonth);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    var _a, _b, _c;\n\n    if (prevProps.type === 'single') {\n      const prevPropSingleDateValue = getDateNOString(prevProps.singleDateValue);\n      const prevStateSingleDate = getDateNOString(prevState.singleDate);\n      const currentSingleDateValue = getDateNOString(this.props.singleDateValue);\n\n      if (prevPropSingleDateValue !== currentSingleDateValue && prevStateSingleDate !== currentSingleDateValue) {\n        this.setState({\n          singleDate: (_a = this.props.singleDateValue) !== null && _a !== void 0 ? _a : null,\n          visibleMonth: getDefaultVisibleMonth(this.props)\n        }, () => {\n          if (!this.state.isSingleDateFocused) {\n            this.singleDateValidator(this.state.singleDate);\n          }\n        });\n      }\n    } else {\n      const prevPropStartDateValue = getDateNOString(prevProps.startDateValue);\n      const prevStateStartDate = getDateNOString(prevState.startDate);\n      const currentStartDateValue = getDateNOString(this.props.startDateValue);\n      const prevPropEndDateValue = getDateNOString(prevProps.endDateValue);\n      const prevStateEndDate = getDateNOString(prevState.endDate);\n      const currentEndDateValue = getDateNOString(this.props.endDateValue);\n\n      if (prevPropStartDateValue !== currentStartDateValue && prevStateStartDate !== currentStartDateValue) {\n        this.setState({\n          startDate: (_b = this.props.startDateValue) !== null && _b !== void 0 ? _b : null\n        }, () => {\n          if (this.state.focusedInput === null) {\n            this.rangeDateValidator(this.state.startDate, this.state.endDate);\n          }\n        });\n      }\n\n      if (prevPropEndDateValue !== currentEndDateValue && prevStateEndDate !== currentEndDateValue) {\n        this.setState({\n          endDate: (_c = this.props.endDateValue) !== null && _c !== void 0 ? _c : null\n        }, () => {\n          if (this.state.focusedInput === null) {\n            this.rangeDateValidator(this.state.startDate, this.state.endDate);\n          }\n        });\n      }\n    }\n\n    if (prevState.visibleMonth !== this.state.visibleMonth || prevProps.maximumDate && this.props.maximumDate && !prevProps.maximumDate.isSame(this.props.maximumDate, 'month') || prevProps.minimumDate && this.props.minimumDate && !prevProps.minimumDate.isSame(this.props.minimumDate, 'month')) {\n      this.disableMonthSelectorHandler(this.state.visibleMonth);\n    }\n  }\n\n  validateField() {\n    return this.props.type === 'single' ? this.singleDateValidator(this.state.singleDate) : this.rangeDateValidator(this.state.startDate, this.state.endDate);\n  }\n\n  isValid() {\n    return this.props.type === 'single' ? this.state.isSingleDateValid : this.state.isRangeDateValid;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      locale,\n      className,\n      label,\n      isLabelHidden,\n      requiredLabel,\n      optionalLabel,\n      subLabel,\n      helpButton,\n      helpElement,\n      isValidationHidden,\n      validationErrorRenderer\n    } = _a,\n          partialPropsForDesktop = __rest(_a, [\"locale\", \"className\", \"label\", \"isLabelHidden\", \"requiredLabel\", \"optionalLabel\", \"subLabel\", \"helpButton\", \"helpElement\", \"isValidationHidden\", \"validationErrorRenderer\"]);\n\n    const {\n      isSingleDateValid,\n      isRangeDateValid,\n      errorString\n    } = this.state;\n    const {\n      id,\n      type,\n      isRequired\n    } = partialPropsForDesktop;\n    const hasErrors = type === 'single' ? !isSingleDateValid : type === 'range' ? !isRangeDateValid : false;\n    const classes = getCSSClasses(toolkitstyles.datepicker, toolkitstyles['datepicker--haserror'], !isValidationHidden, hasErrors, className);\n    moment.locale(locale);\n    return React.createElement(\"div\", {\n      id: `${id}-wrapper`,\n      className: classes\n    }, React.createElement(\"fieldset\", null, hasErrors && validationErrorRenderer, !isValidationHidden && hasErrors && React.createElement(ValidationError, {\n      isValid: !hasErrors,\n      error: errorString ? errorString : 'Error'\n    }), label && React.createElement(DateRangePickerLabel, {\n      label: label,\n      locale: locale,\n      isLabelHidden: isLabelHidden,\n      isRequired: isRequired,\n      requiredLabel: requiredLabel,\n      optionalLabel: optionalLabel,\n      helpButton: helpButton,\n      subLabel: subLabel\n    }), helpElement !== null && helpElement !== void 0 ? helpElement : null, this.state.isMobile ? renderMobileDatePicker(this.props, this.state, this.onSingleDateChange, this.onStartDateChange, this.onEndDateChange, this.onBlurHandler) : renderDesktopDatePicker(partialPropsForDesktop, this.state, this.airbnbSingleDatepickerRef, this.airbnbDateRangepickerRef, this.onSingleDateChange, this.onSingleDateFocusChange, this.onRangeDatesChange, this.onRangeDatesFocusChange, this.onCalenderIconClick, this.onChangeVisibleMonthHandler)));\n  }\n\n}\nDateRangePicker.defaultProps = {\n  id: 'daterangepicker',\n  resources: Phrases,\n  errorResources: ErrorPhrases,\n  startDateId: START_DATE_ID,\n  startDatePlaceholderText: DEFAULT_STARTDATE_PLACEHOLDER,\n  endDateId: END_DATE_ID,\n  endDatePlaceholderText: DEFAULT_ENDDATE_PLACEHOLDER,\n  showDefaultInputIcon: true,\n  isValidationHidden: false,\n  isRequired: false,\n  isDisabled: false,\n  numberOfMonths: 1\n};\nexport default DateRangePicker;","map":null,"metadata":{},"sourceType":"module"}