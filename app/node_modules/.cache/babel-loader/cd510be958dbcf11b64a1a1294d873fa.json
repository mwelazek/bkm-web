{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar antlr4 = require(\"./antlr4-index\");\n\nvar Lexer = require(\"./generated/FHIRPathLexer\").FHIRPathLexer;\n\nvar Parser = require(\"./generated/FHIRPathParser\").FHIRPathParser;\n\nvar Listener = require(\"./generated/FHIRPathListener\").FHIRPathListener;\n\nvar ErrorListener = function ErrorListener(errors) {\n  antlr4.error.ErrorListener.call(this);\n  this.errors = errors;\n  return this;\n};\n\nErrorListener.prototype = Object.create(antlr4.error.ErrorListener.prototype);\nErrorListener.prototype.constructor = ErrorListener;\n\nErrorListener.prototype.syntaxError = function (rec, sym, line, col, msg, e) {\n  this.errors.push([rec, sym, line, col, msg, e]);\n};\n\nvar parse = function parse(path) {\n  var chars = new antlr4.InputStream(path);\n  var lexer = new Lexer(chars);\n  var tokens = new antlr4.CommonTokenStream(lexer);\n  var parser = new Parser(tokens);\n  parser.buildParseTrees = true;\n  var errors = [];\n  var listener = new ErrorListener(errors);\n  lexer.removeErrorListeners();\n  lexer.addErrorListener(listener);\n  parser.removeErrorListeners();\n  parser.addErrorListener(listener);\n  var tree = parser.entireExpression();\n\n  function PathListener() {\n    Listener.call(this); // inherit default listener\n\n    return this;\n  } // inherit default listener\n\n\n  PathListener.prototype = Object.create(Listener.prototype);\n  PathListener.prototype.constructor = PathListener;\n  var ast = {};\n  var node;\n  var parentStack = [ast];\n\n  var _loop = function _loop() {\n    var p = _Object$keys[_i];\n\n    if (p.startsWith(\"enter\")) {\n      PathListener.prototype[p] = function (ctx) {\n        var parentNode = parentStack[parentStack.length - 1];\n        var nodeType = p.slice(5); // remove \"enter\"\n\n        node = {\n          type: nodeType\n        };\n        node.text = ctx.getText();\n        if (!parentNode.children) parentNode.children = [];\n        parentNode.children.push(node);\n        parentStack.push(node); // Also collect this node's terminal nodes, if any.  Terminal nodes are\n        // not walked with the rest of the tree, but include things like \"+\" and\n        // \"-\", which we need.\n\n        node.terminalNodeText = [];\n\n        var _iterator = _createForOfIteratorHelper(ctx.children),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var c = _step.value;\n            // Test for node type \"TerminalNodeImpl\".  Minimized code no longer\n            // has the original function names, so we can't rely on\n            // c.constructor.name.  It appears the TerminalNodeImpl is the only\n            // node with a \"symbol\" property, so test for that.\n            if (c.symbol) node.terminalNodeText.push(c.getText());\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      };\n    } else if (p.startsWith(\"exit\")) {\n      PathListener.prototype[p] = function () {\n        parentStack.pop();\n      };\n    }\n  };\n\n  for (var _i = 0, _Object$keys = Object.keys(Listener.prototype); _i < _Object$keys.length; _i++) {\n    _loop();\n  }\n\n  var printer = new PathListener();\n  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);\n\n  if (errors.length > 0) {\n    var errMsgs = [];\n\n    for (var i = 0, len = errors.length; i < len; ++i) {\n      var err = errors[i];\n      var msg = \"line: \" + err[2] + \"; column: \" + err[3] + \"; message: \" + err[4];\n      errMsgs.push(msg);\n    }\n\n    var e = new Error(errMsgs.join(\"\\n\"));\n    e.errors = errors;\n    throw e;\n  }\n\n  return ast;\n};\n\nmodule.exports = {\n  parse: parse\n};","map":null,"metadata":{},"sourceType":"script"}