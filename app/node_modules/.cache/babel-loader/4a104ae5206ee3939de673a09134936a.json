{"ast":null,"code":"// Contains the FHIRPath Aggregate functions.\n// (Section 7 of the FHIRPath 2.0.0 (N1) specification).\nlet engine = {};\n\nconst math = require(\"./math\");\n\nconst equality = require(\"./equality\");\n\nconst util = require('./utilities');\n\nengine.aggregateMacro = function (data, expr, initialValue) {\n  return data.reduce((total, x, i) => {\n    this.$index = i;\n    return this.$total = expr(x);\n  }, this.$total = initialValue);\n};\n\nengine.countFn = function (x) {\n  if (x && x.length) {\n    return x.length;\n  } else {\n    return 0;\n  }\n}; // Shortcut for \"value.aggregate($this+$total, 0)\"\n\n\nengine.sumFn = function (data) {\n  return engine.aggregateMacro.apply(this, [data, $this => {\n    return math.plus(util.arraify($this), util.arraify(this.$total));\n  }, 0]);\n}; // Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))\"\n\n\nengine.minFn = function (data) {\n  return engine.aggregateMacro.apply(this, [data, curr => {\n    const $this = util.arraify(curr);\n    const $total = util.arraify(this.$total);\n    return util.isEmpty($total) ? $this : equality.lt($this, $total) ? $this : $total;\n  }]);\n}; // Shortcut for \"value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))\"\n\n\nengine.maxFn = function (data) {\n  return engine.aggregateMacro.apply(this, [data, curr => {\n    const $this = util.arraify(curr);\n    const $total = util.arraify(this.$total);\n    return util.isEmpty($total) ? $this : equality.gt($this, $total) ? $this : $total;\n  }]);\n}; // Shortcut for \"value.sum()/value.count()\"\n\n\nengine.avgFn = function (data) {\n  return math.div(engine.sumFn(data), engine.countFn(data));\n};\n\nmodule.exports = engine;","map":null,"metadata":{},"sourceType":"script"}