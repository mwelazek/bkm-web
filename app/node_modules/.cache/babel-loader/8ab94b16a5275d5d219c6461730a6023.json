{"ast":null,"code":"// Generated from FHIRPath.g4 by ANTLR 4.7.1\n// jshint ignore: start\nvar antlr4 = require('../antlr4-index');\n\nvar FHIRPathListener = require('./FHIRPathListener').FHIRPathListener;\n\nvar grammarFileName = \"FHIRPath.g4\";\nvar serializedATN = [\"\\x03\\u608B\\uA72A\\u8133\\uB9ED\\u417C\\u3BE7\\u7786\\u5964\", \"\\x03A\\x9C\\x04\\x02\\t\\x02\\x04\\x03\\t\\x03\\x04\\x04\\t\", \"\\x04\\x04\\x05\\t\\x05\\x04\\x06\\t\\x06\\x04\\x07\\t\\x07\\x04\", \"\\b\\t\\b\\x04\\t\\t\\t\\x04\\n\\t\\n\\x04\\x0B\\t\\x0B\\x04\\f\\t\\f\\x04\", \"\\r\\t\\r\\x04\\x0E\\t\\x0E\\x04\\x0F\\t\\x0F\\x04\\x10\\t\\x10\\x03\", \"\\x02\\x03\\x02\\x03\\x02\\x03\\x03\\x03\\x03\\x03\\x03\\x03\", \"\\x03\\x05\\x03(\\n\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\", \"\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\", \"\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\", \"\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\", \"\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\", \"\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\", \"\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x03\\x07\\x03P\", \"\\n\\x03\\f\\x03\\x0E\\x03S\\x0B\\x03\\x03\\x04\\x03\\x04\\x03\", \"\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x05\\x04\\\\\", \"\\n\\x04\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\\x03\\x05\", \"\\x03\\x05\\x03\\x05\\x03\\x05\\x05\\x05f\\n\\x05\\x03\\x06\", \"\\x03\\x06\\x03\\x06\\x05\\x06k\\n\\x06\\x03\\x07\\x03\\x07\", \"\\x03\\x07\\x03\\x07\\x03\\x07\\x05\\x07r\\n\\x07\\x03\\b\\x03\", \"\\b\\x03\\b\\x05\\bw\\n\\b\\x03\\b\\x03\\b\\x03\\t\\x03\\t\\x03\\t\\x07\", \"\\t~\\n\\t\\f\\t\\x0E\\t\\x81\\x0B\\t\\x03\\n\\x03\\n\\x05\\n\\x85\\n\\n\", \"\\x03\\x0B\\x03\\x0B\\x03\\x0B\\x05\\x0B\\x8A\\n\\x0B\\x03\", \"\\f\\x03\\f\\x03\\r\\x03\\r\\x03\\x0E\\x03\\x0E\\x03\\x0F\\x03\", \"\\x0F\\x03\\x0F\\x07\\x0F\\x95\\n\\x0F\\f\\x0F\\x0E\\x0F\\x98\", \"\\x0B\\x0F\\x03\\x10\\x03\\x10\\x03\\x10\\x02\\x03\\x04\\x11\", \"\\x02\\x04\\x06\\b\\n\\f\\x0E\\x10\\x12\\x14\\x16\\x18\\x1A\\x1C\", \"\\x1E\\x02\\x0E\\x03\\x02\\x06\\x07\\x03\\x02\\b\\x0B\\x04\", \"\\x02\\x06\\x07\\f\\f\\x03\\x02\\x0E\\x11\\x03\\x02\\x14\\x17\", \"\\x03\\x02\\x18\\x19\\x03\\x02\\x1B\\x1C\\x03\\x02\\x12\\x13\", \"\\x03\\x02\\\"#\\x03\\x02)0\\x03\\x0218\\x05\\x02\\x12\\x13\", \"\\x18\\x19;<\\x02\\xAD\\x02 \\x03\\x02\\x02\\x02\\x04'\\x03\", \"\\x02\\x02\\x02\\x06[\\x03\\x02\\x02\\x02\\be\\x03\\x02\\x02\", \"\\x02\\ng\\x03\\x02\\x02\\x02\\fq\\x03\\x02\\x02\\x02\\x0Es\", \"\\x03\\x02\\x02\\x02\\x10z\\x03\\x02\\x02\\x02\\x12\\x82\", \"\\x03\\x02\\x02\\x02\\x14\\x89\\x03\\x02\\x02\\x02\\x16\\x8B\", \"\\x03\\x02\\x02\\x02\\x18\\x8D\\x03\\x02\\x02\\x02\\x1A\\x8F\", \"\\x03\\x02\\x02\\x02\\x1C\\x91\\x03\\x02\\x02\\x02\\x1E\\x99\", \"\\x03\\x02\\x02\\x02 !\\x05\\x04\\x03\\x02!\\\"\\x07\\x02\\x02\", \"\\x03\\\"\\x03\\x03\\x02\\x02\\x02#$\\b\\x03\\x01\\x02$(\\x05\", \"\\x06\\x04\\x02%&\\t\\x02\\x02\\x02&(\\x05\\x04\\x03\\r'#\\x03\", \"\\x02\\x02\\x02'%\\x03\\x02\\x02\\x02(Q\\x03\\x02\\x02\\x02\", \")*\\f\\f\\x02\\x02*+\\t\\x03\\x02\\x02+P\\x05\\x04\\x03\\r,-\\f\\x0B\", \"\\x02\\x02-.\\t\\x04\\x02\\x02.P\\x05\\x04\\x03\\f/0\\f\\n\\x02\", \"\\x0201\\x07\\r\\x02\\x021P\\x05\\x04\\x03\\x0B23\\f\\t\\x02\\x02\", \"34\\t\\x05\\x02\\x024P\\x05\\x04\\x03\\n56\\f\\x07\\x02\\x026\", \"7\\t\\x06\\x02\\x027P\\x05\\x04\\x03\\b89\\f\\x06\\x02\\x029:\", \"\\t\\x07\\x02\\x02:P\\x05\\x04\\x03\\x07;<\\f\\x05\\x02\\x02\", \"<=\\x07\\x1A\\x02\\x02=P\\x05\\x04\\x03\\x06>?\\f\\x04\\x02\", \"\\x02?@\\t\\b\\x02\\x02@P\\x05\\x04\\x03\\x05AB\\f\\x03\\x02\\x02\", \"BC\\x07\\x1D\\x02\\x02CP\\x05\\x04\\x03\\x04DE\\f\\x0F\\x02\", \"\\x02EF\\x07\\x03\\x02\\x02FP\\x05\\f\\x07\\x02GH\\f\\x0E\\x02\", \"\\x02HI\\x07\\x04\\x02\\x02IJ\\x05\\x04\\x03\\x02JK\\x07\\x05\", \"\\x02\\x02KP\\x03\\x02\\x02\\x02LM\\f\\b\\x02\\x02MN\\t\\t\\x02\", \"\\x02NP\\x05\\x1A\\x0E\\x02O)\\x03\\x02\\x02\\x02O,\\x03\\x02\", \"\\x02\\x02O/\\x03\\x02\\x02\\x02O2\\x03\\x02\\x02\\x02O5\\x03\", \"\\x02\\x02\\x02O8\\x03\\x02\\x02\\x02O;\\x03\\x02\\x02\\x02\", \"O>\\x03\\x02\\x02\\x02OA\\x03\\x02\\x02\\x02OD\\x03\\x02\\x02\", \"\\x02OG\\x03\\x02\\x02\\x02OL\\x03\\x02\\x02\\x02PS\\x03\\x02\", \"\\x02\\x02QO\\x03\\x02\\x02\\x02QR\\x03\\x02\\x02\\x02R\\x05\", \"\\x03\\x02\\x02\\x02SQ\\x03\\x02\\x02\\x02T\\\\\\x05\\f\\x07\", \"\\x02U\\\\\\x05\\b\\x05\\x02V\\\\\\x05\\n\\x06\\x02WX\\x07\\x1E\\x02\", \"\\x02XY\\x05\\x04\\x03\\x02YZ\\x07\\x1F\\x02\\x02Z\\\\\\x03\", \"\\x02\\x02\\x02[T\\x03\\x02\\x02\\x02[U\\x03\\x02\\x02\\x02\", \"[V\\x03\\x02\\x02\\x02[W\\x03\\x02\\x02\\x02\\\\\\x07\\x03\\x02\", \"\\x02\\x02]^\\x07 \\x02\\x02^f\\x07!\\x02\\x02_f\\t\\n\\x02\\x02\", \"`f\\x07=\\x02\\x02af\\x07>\\x02\\x02bf\\x079\\x02\\x02cf\\x07\", \":\\x02\\x02df\\x05\\x12\\n\\x02e]\\x03\\x02\\x02\\x02e_\\x03\", \"\\x02\\x02\\x02e`\\x03\\x02\\x02\\x02ea\\x03\\x02\\x02\\x02\", \"eb\\x03\\x02\\x02\\x02ec\\x03\\x02\\x02\\x02ed\\x03\\x02\\x02\", \"\\x02f\\t\\x03\\x02\\x02\\x02gj\\x07$\\x02\\x02hk\\x05\\x1E\", \"\\x10\\x02ik\\x07=\\x02\\x02jh\\x03\\x02\\x02\\x02ji\\x03\", \"\\x02\\x02\\x02k\\x0B\\x03\\x02\\x02\\x02lr\\x05\\x1E\\x10\", \"\\x02mr\\x05\\x0E\\b\\x02nr\\x07%\\x02\\x02or\\x07&\\x02\\x02\", \"pr\\x07'\\x02\\x02ql\\x03\\x02\\x02\\x02qm\\x03\\x02\\x02\", \"\\x02qn\\x03\\x02\\x02\\x02qo\\x03\\x02\\x02\\x02qp\\x03\\x02\", \"\\x02\\x02r\\r\\x03\\x02\\x02\\x02st\\x05\\x1E\\x10\\x02tv\", \"\\x07\\x1E\\x02\\x02uw\\x05\\x10\\t\\x02vu\\x03\\x02\\x02\\x02\", \"vw\\x03\\x02\\x02\\x02wx\\x03\\x02\\x02\\x02xy\\x07\\x1F\\x02\", \"\\x02y\\x0F\\x03\\x02\\x02\\x02z\\x7F\\x05\\x04\\x03\\x02\", \"{|\\x07(\\x02\\x02|~\\x05\\x04\\x03\\x02}{\\x03\\x02\\x02\", \"\\x02~\\x81\\x03\\x02\\x02\\x02\\x7F}\\x03\\x02\\x02\\x02\", \"\\x7F\\x80\\x03\\x02\\x02\\x02\\x80\\x11\\x03\\x02\\x02\\x02\", \"\\x81\\x7F\\x03\\x02\\x02\\x02\\x82\\x84\\x07>\\x02\\x02\", \"\\x83\\x85\\x05\\x14\\x0B\\x02\\x84\\x83\\x03\\x02\\x02\\x02\", \"\\x84\\x85\\x03\\x02\\x02\\x02\\x85\\x13\\x03\\x02\\x02\\x02\", \"\\x86\\x8A\\x05\\x16\\f\\x02\\x87\\x8A\\x05\\x18\\r\\x02\\x88\", \"\\x8A\\x07=\\x02\\x02\\x89\\x86\\x03\\x02\\x02\\x02\\x89\", \"\\x87\\x03\\x02\\x02\\x02\\x89\\x88\\x03\\x02\\x02\\x02\\x8A\", \"\\x15\\x03\\x02\\x02\\x02\\x8B\\x8C\\t\\x0B\\x02\\x02\\x8C\", \"\\x17\\x03\\x02\\x02\\x02\\x8D\\x8E\\t\\f\\x02\\x02\\x8E\\x19\", \"\\x03\\x02\\x02\\x02\\x8F\\x90\\x05\\x1C\\x0F\\x02\\x90\\x1B\", \"\\x03\\x02\\x02\\x02\\x91\\x96\\x05\\x1E\\x10\\x02\\x92\\x93\", \"\\x07\\x03\\x02\\x02\\x93\\x95\\x05\\x1E\\x10\\x02\\x94\\x92\", \"\\x03\\x02\\x02\\x02\\x95\\x98\\x03\\x02\\x02\\x02\\x96\\x94\", \"\\x03\\x02\\x02\\x02\\x96\\x97\\x03\\x02\\x02\\x02\\x97\\x1D\", \"\\x03\\x02\\x02\\x02\\x98\\x96\\x03\\x02\\x02\\x02\\x99\\x9A\", \"\\t\\r\\x02\\x02\\x9A\\x1F\\x03\\x02\\x02\\x02\\x0E'OQ[ejqv\", \"\\x7F\\x84\\x89\\x96\"].join(\"\");\nvar atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\nvar decisionsToDFA = atn.decisionToState.map(function (ds, index) {\n  return new antlr4.dfa.DFA(ds, index);\n});\nvar sharedContextCache = new antlr4.PredictionContextCache();\nvar literalNames = [null, \"'.'\", \"'['\", \"']'\", \"'+'\", \"'-'\", \"'*'\", \"'/'\", \"'div'\", \"'mod'\", \"'&'\", \"'|'\", \"'<='\", \"'<'\", \"'>'\", \"'>='\", \"'is'\", \"'as'\", \"'='\", \"'~'\", \"'!='\", \"'!~'\", \"'in'\", \"'contains'\", \"'and'\", \"'or'\", \"'xor'\", \"'implies'\", \"'('\", \"')'\", \"'{'\", \"'}'\", \"'true'\", \"'false'\", \"'%'\", \"'$this'\", \"'$index'\", \"'$total'\", \"','\", \"'year'\", \"'month'\", \"'week'\", \"'day'\", \"'hour'\", \"'minute'\", \"'second'\", \"'millisecond'\", \"'years'\", \"'months'\", \"'weeks'\", \"'days'\", \"'hours'\", \"'minutes'\", \"'seconds'\", \"'milliseconds'\"];\nvar symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, \"DATETIME\", \"TIME\", \"IDENTIFIER\", \"DELIMITEDIDENTIFIER\", \"STRING\", \"NUMBER\", \"WS\", \"COMMENT\", \"LINE_COMMENT\"];\nvar ruleNames = [\"entireExpression\", \"expression\", \"term\", \"literal\", \"externalConstant\", \"invocation\", \"functn\", \"paramList\", \"quantity\", \"unit\", \"dateTimePrecision\", \"pluralDateTimePrecision\", \"typeSpecifier\", \"qualifiedIdentifier\", \"identifier\"];\n\nfunction FHIRPathParser(input) {\n  antlr4.Parser.call(this, input);\n  this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\n  this.ruleNames = ruleNames;\n  this.literalNames = literalNames;\n  this.symbolicNames = symbolicNames;\n  return this;\n}\n\nFHIRPathParser.prototype = Object.create(antlr4.Parser.prototype);\nFHIRPathParser.prototype.constructor = FHIRPathParser;\nObject.defineProperty(FHIRPathParser.prototype, \"atn\", {\n  get: function get() {\n    return atn;\n  }\n});\nFHIRPathParser.EOF = antlr4.Token.EOF;\nFHIRPathParser.T__0 = 1;\nFHIRPathParser.T__1 = 2;\nFHIRPathParser.T__2 = 3;\nFHIRPathParser.T__3 = 4;\nFHIRPathParser.T__4 = 5;\nFHIRPathParser.T__5 = 6;\nFHIRPathParser.T__6 = 7;\nFHIRPathParser.T__7 = 8;\nFHIRPathParser.T__8 = 9;\nFHIRPathParser.T__9 = 10;\nFHIRPathParser.T__10 = 11;\nFHIRPathParser.T__11 = 12;\nFHIRPathParser.T__12 = 13;\nFHIRPathParser.T__13 = 14;\nFHIRPathParser.T__14 = 15;\nFHIRPathParser.T__15 = 16;\nFHIRPathParser.T__16 = 17;\nFHIRPathParser.T__17 = 18;\nFHIRPathParser.T__18 = 19;\nFHIRPathParser.T__19 = 20;\nFHIRPathParser.T__20 = 21;\nFHIRPathParser.T__21 = 22;\nFHIRPathParser.T__22 = 23;\nFHIRPathParser.T__23 = 24;\nFHIRPathParser.T__24 = 25;\nFHIRPathParser.T__25 = 26;\nFHIRPathParser.T__26 = 27;\nFHIRPathParser.T__27 = 28;\nFHIRPathParser.T__28 = 29;\nFHIRPathParser.T__29 = 30;\nFHIRPathParser.T__30 = 31;\nFHIRPathParser.T__31 = 32;\nFHIRPathParser.T__32 = 33;\nFHIRPathParser.T__33 = 34;\nFHIRPathParser.T__34 = 35;\nFHIRPathParser.T__35 = 36;\nFHIRPathParser.T__36 = 37;\nFHIRPathParser.T__37 = 38;\nFHIRPathParser.T__38 = 39;\nFHIRPathParser.T__39 = 40;\nFHIRPathParser.T__40 = 41;\nFHIRPathParser.T__41 = 42;\nFHIRPathParser.T__42 = 43;\nFHIRPathParser.T__43 = 44;\nFHIRPathParser.T__44 = 45;\nFHIRPathParser.T__45 = 46;\nFHIRPathParser.T__46 = 47;\nFHIRPathParser.T__47 = 48;\nFHIRPathParser.T__48 = 49;\nFHIRPathParser.T__49 = 50;\nFHIRPathParser.T__50 = 51;\nFHIRPathParser.T__51 = 52;\nFHIRPathParser.T__52 = 53;\nFHIRPathParser.T__53 = 54;\nFHIRPathParser.DATETIME = 55;\nFHIRPathParser.TIME = 56;\nFHIRPathParser.IDENTIFIER = 57;\nFHIRPathParser.DELIMITEDIDENTIFIER = 58;\nFHIRPathParser.STRING = 59;\nFHIRPathParser.NUMBER = 60;\nFHIRPathParser.WS = 61;\nFHIRPathParser.COMMENT = 62;\nFHIRPathParser.LINE_COMMENT = 63;\nFHIRPathParser.RULE_entireExpression = 0;\nFHIRPathParser.RULE_expression = 1;\nFHIRPathParser.RULE_term = 2;\nFHIRPathParser.RULE_literal = 3;\nFHIRPathParser.RULE_externalConstant = 4;\nFHIRPathParser.RULE_invocation = 5;\nFHIRPathParser.RULE_functn = 6;\nFHIRPathParser.RULE_paramList = 7;\nFHIRPathParser.RULE_quantity = 8;\nFHIRPathParser.RULE_unit = 9;\nFHIRPathParser.RULE_dateTimePrecision = 10;\nFHIRPathParser.RULE_pluralDateTimePrecision = 11;\nFHIRPathParser.RULE_typeSpecifier = 12;\nFHIRPathParser.RULE_qualifiedIdentifier = 13;\nFHIRPathParser.RULE_identifier = 14;\n\nfunction EntireExpressionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_entireExpression;\n  return this;\n}\n\nEntireExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nEntireExpressionContext.prototype.constructor = EntireExpressionContext;\n\nEntireExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nEntireExpressionContext.prototype.EOF = function () {\n  return this.getToken(FHIRPathParser.EOF, 0);\n};\n\nEntireExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterEntireExpression(this);\n  }\n};\n\nEntireExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitEntireExpression(this);\n  }\n};\n\nFHIRPathParser.EntireExpressionContext = EntireExpressionContext;\n\nFHIRPathParser.prototype.entireExpression = function () {\n  var localctx = new EntireExpressionContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 30;\n    this.expression(0);\n    this.state = 31;\n    this.match(FHIRPathParser.EOF);\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction ExpressionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_expression;\n  return this;\n}\n\nExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nExpressionContext.prototype.constructor = ExpressionContext;\n\nExpressionContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction IndexerExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nIndexerExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nIndexerExpressionContext.prototype.constructor = IndexerExpressionContext;\nFHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;\n\nIndexerExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nIndexerExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterIndexerExpression(this);\n  }\n};\n\nIndexerExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitIndexerExpression(this);\n  }\n};\n\nfunction PolarityExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nPolarityExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nPolarityExpressionContext.prototype.constructor = PolarityExpressionContext;\nFHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;\n\nPolarityExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nPolarityExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterPolarityExpression(this);\n  }\n};\n\nPolarityExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitPolarityExpression(this);\n  }\n};\n\nfunction AdditiveExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nAdditiveExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nAdditiveExpressionContext.prototype.constructor = AdditiveExpressionContext;\nFHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;\n\nAdditiveExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nAdditiveExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterAdditiveExpression(this);\n  }\n};\n\nAdditiveExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitAdditiveExpression(this);\n  }\n};\n\nfunction MultiplicativeExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nMultiplicativeExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nMultiplicativeExpressionContext.prototype.constructor = MultiplicativeExpressionContext;\nFHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;\n\nMultiplicativeExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nMultiplicativeExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterMultiplicativeExpression(this);\n  }\n};\n\nMultiplicativeExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitMultiplicativeExpression(this);\n  }\n};\n\nfunction UnionExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nUnionExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nUnionExpressionContext.prototype.constructor = UnionExpressionContext;\nFHIRPathParser.UnionExpressionContext = UnionExpressionContext;\n\nUnionExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nUnionExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterUnionExpression(this);\n  }\n};\n\nUnionExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitUnionExpression(this);\n  }\n};\n\nfunction OrExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nOrExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nOrExpressionContext.prototype.constructor = OrExpressionContext;\nFHIRPathParser.OrExpressionContext = OrExpressionContext;\n\nOrExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nOrExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterOrExpression(this);\n  }\n};\n\nOrExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitOrExpression(this);\n  }\n};\n\nfunction AndExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nAndExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nAndExpressionContext.prototype.constructor = AndExpressionContext;\nFHIRPathParser.AndExpressionContext = AndExpressionContext;\n\nAndExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nAndExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterAndExpression(this);\n  }\n};\n\nAndExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitAndExpression(this);\n  }\n};\n\nfunction MembershipExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nMembershipExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nMembershipExpressionContext.prototype.constructor = MembershipExpressionContext;\nFHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;\n\nMembershipExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nMembershipExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterMembershipExpression(this);\n  }\n};\n\nMembershipExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitMembershipExpression(this);\n  }\n};\n\nfunction InequalityExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nInequalityExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nInequalityExpressionContext.prototype.constructor = InequalityExpressionContext;\nFHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;\n\nInequalityExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nInequalityExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterInequalityExpression(this);\n  }\n};\n\nInequalityExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitInequalityExpression(this);\n  }\n};\n\nfunction InvocationExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nInvocationExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nInvocationExpressionContext.prototype.constructor = InvocationExpressionContext;\nFHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;\n\nInvocationExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nInvocationExpressionContext.prototype.invocation = function () {\n  return this.getTypedRuleContext(InvocationContext, 0);\n};\n\nInvocationExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterInvocationExpression(this);\n  }\n};\n\nInvocationExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitInvocationExpression(this);\n  }\n};\n\nfunction EqualityExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nEqualityExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nEqualityExpressionContext.prototype.constructor = EqualityExpressionContext;\nFHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;\n\nEqualityExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nEqualityExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterEqualityExpression(this);\n  }\n};\n\nEqualityExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitEqualityExpression(this);\n  }\n};\n\nfunction ImpliesExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nImpliesExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nImpliesExpressionContext.prototype.constructor = ImpliesExpressionContext;\nFHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;\n\nImpliesExpressionContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nImpliesExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterImpliesExpression(this);\n  }\n};\n\nImpliesExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitImpliesExpression(this);\n  }\n};\n\nfunction TermExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTermExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nTermExpressionContext.prototype.constructor = TermExpressionContext;\nFHIRPathParser.TermExpressionContext = TermExpressionContext;\n\nTermExpressionContext.prototype.term = function () {\n  return this.getTypedRuleContext(TermContext, 0);\n};\n\nTermExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTermExpression(this);\n  }\n};\n\nTermExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTermExpression(this);\n  }\n};\n\nfunction TypeExpressionContext(parser, ctx) {\n  ExpressionContext.call(this, parser);\n  ExpressionContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTypeExpressionContext.prototype = Object.create(ExpressionContext.prototype);\nTypeExpressionContext.prototype.constructor = TypeExpressionContext;\nFHIRPathParser.TypeExpressionContext = TypeExpressionContext;\n\nTypeExpressionContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nTypeExpressionContext.prototype.typeSpecifier = function () {\n  return this.getTypedRuleContext(TypeSpecifierContext, 0);\n};\n\nTypeExpressionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTypeExpression(this);\n  }\n};\n\nTypeExpressionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTypeExpression(this);\n  }\n};\n\nFHIRPathParser.prototype.expression = function (_p) {\n  if (_p === undefined) {\n    _p = 0;\n  }\n\n  var _parentctx = this._ctx;\n  var _parentState = this.state;\n  var localctx = new ExpressionContext(this, this._ctx, _parentState);\n  var _prevctx = localctx;\n  var _startState = 2;\n  this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 37;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__15:\n      case FHIRPathParser.T__16:\n      case FHIRPathParser.T__21:\n      case FHIRPathParser.T__22:\n      case FHIRPathParser.T__27:\n      case FHIRPathParser.T__29:\n      case FHIRPathParser.T__31:\n      case FHIRPathParser.T__32:\n      case FHIRPathParser.T__33:\n      case FHIRPathParser.T__34:\n      case FHIRPathParser.T__35:\n      case FHIRPathParser.T__36:\n      case FHIRPathParser.DATETIME:\n      case FHIRPathParser.TIME:\n      case FHIRPathParser.IDENTIFIER:\n      case FHIRPathParser.DELIMITEDIDENTIFIER:\n      case FHIRPathParser.STRING:\n      case FHIRPathParser.NUMBER:\n        localctx = new TermExpressionContext(this, localctx);\n        this._ctx = localctx;\n        _prevctx = localctx;\n        this.state = 34;\n        this.term();\n        break;\n\n      case FHIRPathParser.T__3:\n      case FHIRPathParser.T__4:\n        localctx = new PolarityExpressionContext(this, localctx);\n        this._ctx = localctx;\n        _prevctx = localctx;\n        this.state = 35;\n        _la = this._input.LA(1);\n\n        if (!(_la === FHIRPathParser.T__3 || _la === FHIRPathParser.T__4)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          this._errHandler.reportMatch(this);\n\n          this.consume();\n        }\n\n        this.state = 36;\n        this.expression(11);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n\n    this._ctx.stop = this._input.LT(-1);\n    this.state = 79;\n\n    this._errHandler.sync(this);\n\n    var _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);\n\n    while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n      if (_alt === 1) {\n        if (this._parseListeners !== null) {\n          this.triggerExitRuleEvent();\n        }\n\n        _prevctx = localctx;\n        this.state = 77;\n\n        this._errHandler.sync(this);\n\n        var la_ = this._interp.adaptivePredict(this._input, 1, this._ctx);\n\n        switch (la_) {\n          case 1:\n            localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 39;\n\n            if (!this.precpred(this._ctx, 10)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 10)\");\n            }\n\n            this.state = 40;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__5 | 1 << FHIRPathParser.T__6 | 1 << FHIRPathParser.T__7 | 1 << FHIRPathParser.T__8)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 41;\n            this.expression(11);\n            break;\n\n          case 2:\n            localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 42;\n\n            if (!this.precpred(this._ctx, 9)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 9)\");\n            }\n\n            this.state = 43;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__9)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 44;\n            this.expression(10);\n            break;\n\n          case 3:\n            localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 45;\n\n            if (!this.precpred(this._ctx, 8)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 8)\");\n            }\n\n            this.state = 46;\n            this.match(FHIRPathParser.T__10);\n            this.state = 47;\n            this.expression(9);\n            break;\n\n          case 4:\n            localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 48;\n\n            if (!this.precpred(this._ctx, 7)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 7)\");\n            }\n\n            this.state = 49;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__11 | 1 << FHIRPathParser.T__12 | 1 << FHIRPathParser.T__13 | 1 << FHIRPathParser.T__14)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 50;\n            this.expression(8);\n            break;\n\n          case 5:\n            localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 51;\n\n            if (!this.precpred(this._ctx, 5)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 5)\");\n            }\n\n            this.state = 52;\n            _la = this._input.LA(1);\n\n            if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__17 | 1 << FHIRPathParser.T__18 | 1 << FHIRPathParser.T__19 | 1 << FHIRPathParser.T__20)) !== 0)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 53;\n            this.expression(6);\n            break;\n\n          case 6:\n            localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 54;\n\n            if (!this.precpred(this._ctx, 4)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 4)\");\n            }\n\n            this.state = 55;\n            _la = this._input.LA(1);\n\n            if (!(_la === FHIRPathParser.T__21 || _la === FHIRPathParser.T__22)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 56;\n            this.expression(5);\n            break;\n\n          case 7:\n            localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 57;\n\n            if (!this.precpred(this._ctx, 3)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 3)\");\n            }\n\n            this.state = 58;\n            this.match(FHIRPathParser.T__23);\n            this.state = 59;\n            this.expression(4);\n            break;\n\n          case 8:\n            localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 60;\n\n            if (!this.precpred(this._ctx, 2)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n            }\n\n            this.state = 61;\n            _la = this._input.LA(1);\n\n            if (!(_la === FHIRPathParser.T__24 || _la === FHIRPathParser.T__25)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 62;\n            this.expression(3);\n            break;\n\n          case 9:\n            localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 63;\n\n            if (!this.precpred(this._ctx, 1)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n            }\n\n            this.state = 64;\n            this.match(FHIRPathParser.T__26);\n            this.state = 65;\n            this.expression(2);\n            break;\n\n          case 10:\n            localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 66;\n\n            if (!this.precpred(this._ctx, 13)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 13)\");\n            }\n\n            this.state = 67;\n            this.match(FHIRPathParser.T__0);\n            this.state = 68;\n            this.invocation();\n            break;\n\n          case 11:\n            localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 69;\n\n            if (!this.precpred(this._ctx, 12)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 12)\");\n            }\n\n            this.state = 70;\n            this.match(FHIRPathParser.T__1);\n            this.state = 71;\n            this.expression(0);\n            this.state = 72;\n            this.match(FHIRPathParser.T__2);\n            break;\n\n          case 12:\n            localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));\n            this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);\n            this.state = 74;\n\n            if (!this.precpred(this._ctx, 6)) {\n              throw new antlr4.error.FailedPredicateException(this, \"this.precpred(this._ctx, 6)\");\n            }\n\n            this.state = 75;\n            _la = this._input.LA(1);\n\n            if (!(_la === FHIRPathParser.T__15 || _la === FHIRPathParser.T__16)) {\n              this._errHandler.recoverInline(this);\n            } else {\n              this._errHandler.reportMatch(this);\n\n              this.consume();\n            }\n\n            this.state = 76;\n            this.typeSpecifier();\n            break;\n        }\n      }\n\n      this.state = 81;\n\n      this._errHandler.sync(this);\n\n      _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);\n    }\n  } catch (error) {\n    if (error instanceof antlr4.error.RecognitionException) {\n      localctx.exception = error;\n\n      this._errHandler.reportError(this, error);\n\n      this._errHandler.recover(this, error);\n    } else {\n      throw error;\n    }\n  } finally {\n    this.unrollRecursionContexts(_parentctx);\n  }\n\n  return localctx;\n};\n\nfunction TermContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_term;\n  return this;\n}\n\nTermContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nTermContext.prototype.constructor = TermContext;\n\nTermContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction ExternalConstantTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nExternalConstantTermContext.prototype = Object.create(TermContext.prototype);\nExternalConstantTermContext.prototype.constructor = ExternalConstantTermContext;\nFHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;\n\nExternalConstantTermContext.prototype.externalConstant = function () {\n  return this.getTypedRuleContext(ExternalConstantContext, 0);\n};\n\nExternalConstantTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterExternalConstantTerm(this);\n  }\n};\n\nExternalConstantTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitExternalConstantTerm(this);\n  }\n};\n\nfunction LiteralTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nLiteralTermContext.prototype = Object.create(TermContext.prototype);\nLiteralTermContext.prototype.constructor = LiteralTermContext;\nFHIRPathParser.LiteralTermContext = LiteralTermContext;\n\nLiteralTermContext.prototype.literal = function () {\n  return this.getTypedRuleContext(LiteralContext, 0);\n};\n\nLiteralTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterLiteralTerm(this);\n  }\n};\n\nLiteralTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitLiteralTerm(this);\n  }\n};\n\nfunction ParenthesizedTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nParenthesizedTermContext.prototype = Object.create(TermContext.prototype);\nParenthesizedTermContext.prototype.constructor = ParenthesizedTermContext;\nFHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;\n\nParenthesizedTermContext.prototype.expression = function () {\n  return this.getTypedRuleContext(ExpressionContext, 0);\n};\n\nParenthesizedTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterParenthesizedTerm(this);\n  }\n};\n\nParenthesizedTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitParenthesizedTerm(this);\n  }\n};\n\nfunction InvocationTermContext(parser, ctx) {\n  TermContext.call(this, parser);\n  TermContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nInvocationTermContext.prototype = Object.create(TermContext.prototype);\nInvocationTermContext.prototype.constructor = InvocationTermContext;\nFHIRPathParser.InvocationTermContext = InvocationTermContext;\n\nInvocationTermContext.prototype.invocation = function () {\n  return this.getTypedRuleContext(InvocationContext, 0);\n};\n\nInvocationTermContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterInvocationTerm(this);\n  }\n};\n\nInvocationTermContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitInvocationTerm(this);\n  }\n};\n\nFHIRPathParser.TermContext = TermContext;\n\nFHIRPathParser.prototype.term = function () {\n  var localctx = new TermContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 4, FHIRPathParser.RULE_term);\n\n  try {\n    this.state = 89;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__15:\n      case FHIRPathParser.T__16:\n      case FHIRPathParser.T__21:\n      case FHIRPathParser.T__22:\n      case FHIRPathParser.T__34:\n      case FHIRPathParser.T__35:\n      case FHIRPathParser.T__36:\n      case FHIRPathParser.IDENTIFIER:\n      case FHIRPathParser.DELIMITEDIDENTIFIER:\n        localctx = new InvocationTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 1);\n        this.state = 82;\n        this.invocation();\n        break;\n\n      case FHIRPathParser.T__29:\n      case FHIRPathParser.T__31:\n      case FHIRPathParser.T__32:\n      case FHIRPathParser.DATETIME:\n      case FHIRPathParser.TIME:\n      case FHIRPathParser.STRING:\n      case FHIRPathParser.NUMBER:\n        localctx = new LiteralTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 2);\n        this.state = 83;\n        this.literal();\n        break;\n\n      case FHIRPathParser.T__33:\n        localctx = new ExternalConstantTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 3);\n        this.state = 84;\n        this.externalConstant();\n        break;\n\n      case FHIRPathParser.T__27:\n        localctx = new ParenthesizedTermContext(this, localctx);\n        this.enterOuterAlt(localctx, 4);\n        this.state = 85;\n        this.match(FHIRPathParser.T__27);\n        this.state = 86;\n        this.expression(0);\n        this.state = 87;\n        this.match(FHIRPathParser.T__28);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction LiteralContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_literal;\n  return this;\n}\n\nLiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nLiteralContext.prototype.constructor = LiteralContext;\n\nLiteralContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction TimeLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTimeLiteralContext.prototype = Object.create(LiteralContext.prototype);\nTimeLiteralContext.prototype.constructor = TimeLiteralContext;\nFHIRPathParser.TimeLiteralContext = TimeLiteralContext;\n\nTimeLiteralContext.prototype.TIME = function () {\n  return this.getToken(FHIRPathParser.TIME, 0);\n};\n\nTimeLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTimeLiteral(this);\n  }\n};\n\nTimeLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTimeLiteral(this);\n  }\n};\n\nfunction NullLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nNullLiteralContext.prototype = Object.create(LiteralContext.prototype);\nNullLiteralContext.prototype.constructor = NullLiteralContext;\nFHIRPathParser.NullLiteralContext = NullLiteralContext;\n\nNullLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterNullLiteral(this);\n  }\n};\n\nNullLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitNullLiteral(this);\n  }\n};\n\nfunction DateTimeLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nDateTimeLiteralContext.prototype = Object.create(LiteralContext.prototype);\nDateTimeLiteralContext.prototype.constructor = DateTimeLiteralContext;\nFHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;\n\nDateTimeLiteralContext.prototype.DATETIME = function () {\n  return this.getToken(FHIRPathParser.DATETIME, 0);\n};\n\nDateTimeLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterDateTimeLiteral(this);\n  }\n};\n\nDateTimeLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitDateTimeLiteral(this);\n  }\n};\n\nfunction StringLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nStringLiteralContext.prototype = Object.create(LiteralContext.prototype);\nStringLiteralContext.prototype.constructor = StringLiteralContext;\nFHIRPathParser.StringLiteralContext = StringLiteralContext;\n\nStringLiteralContext.prototype.STRING = function () {\n  return this.getToken(FHIRPathParser.STRING, 0);\n};\n\nStringLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterStringLiteral(this);\n  }\n};\n\nStringLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitStringLiteral(this);\n  }\n};\n\nfunction BooleanLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nBooleanLiteralContext.prototype = Object.create(LiteralContext.prototype);\nBooleanLiteralContext.prototype.constructor = BooleanLiteralContext;\nFHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;\n\nBooleanLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterBooleanLiteral(this);\n  }\n};\n\nBooleanLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitBooleanLiteral(this);\n  }\n};\n\nfunction NumberLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nNumberLiteralContext.prototype = Object.create(LiteralContext.prototype);\nNumberLiteralContext.prototype.constructor = NumberLiteralContext;\nFHIRPathParser.NumberLiteralContext = NumberLiteralContext;\n\nNumberLiteralContext.prototype.NUMBER = function () {\n  return this.getToken(FHIRPathParser.NUMBER, 0);\n};\n\nNumberLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterNumberLiteral(this);\n  }\n};\n\nNumberLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitNumberLiteral(this);\n  }\n};\n\nfunction QuantityLiteralContext(parser, ctx) {\n  LiteralContext.call(this, parser);\n  LiteralContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nQuantityLiteralContext.prototype = Object.create(LiteralContext.prototype);\nQuantityLiteralContext.prototype.constructor = QuantityLiteralContext;\nFHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;\n\nQuantityLiteralContext.prototype.quantity = function () {\n  return this.getTypedRuleContext(QuantityContext, 0);\n};\n\nQuantityLiteralContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterQuantityLiteral(this);\n  }\n};\n\nQuantityLiteralContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitQuantityLiteral(this);\n  }\n};\n\nFHIRPathParser.LiteralContext = LiteralContext;\n\nFHIRPathParser.prototype.literal = function () {\n  var localctx = new LiteralContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);\n  var _la = 0; // Token type\n\n  try {\n    this.state = 99;\n\n    this._errHandler.sync(this);\n\n    var la_ = this._interp.adaptivePredict(this._input, 4, this._ctx);\n\n    switch (la_) {\n      case 1:\n        localctx = new NullLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 1);\n        this.state = 91;\n        this.match(FHIRPathParser.T__29);\n        this.state = 92;\n        this.match(FHIRPathParser.T__30);\n        break;\n\n      case 2:\n        localctx = new BooleanLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 2);\n        this.state = 93;\n        _la = this._input.LA(1);\n\n        if (!(_la === FHIRPathParser.T__31 || _la === FHIRPathParser.T__32)) {\n          this._errHandler.recoverInline(this);\n        } else {\n          this._errHandler.reportMatch(this);\n\n          this.consume();\n        }\n\n        break;\n\n      case 3:\n        localctx = new StringLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 3);\n        this.state = 94;\n        this.match(FHIRPathParser.STRING);\n        break;\n\n      case 4:\n        localctx = new NumberLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 4);\n        this.state = 95;\n        this.match(FHIRPathParser.NUMBER);\n        break;\n\n      case 5:\n        localctx = new DateTimeLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 5);\n        this.state = 96;\n        this.match(FHIRPathParser.DATETIME);\n        break;\n\n      case 6:\n        localctx = new TimeLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 6);\n        this.state = 97;\n        this.match(FHIRPathParser.TIME);\n        break;\n\n      case 7:\n        localctx = new QuantityLiteralContext(this, localctx);\n        this.enterOuterAlt(localctx, 7);\n        this.state = 98;\n        this.quantity();\n        break;\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction ExternalConstantContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_externalConstant;\n  return this;\n}\n\nExternalConstantContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nExternalConstantContext.prototype.constructor = ExternalConstantContext;\n\nExternalConstantContext.prototype.identifier = function () {\n  return this.getTypedRuleContext(IdentifierContext, 0);\n};\n\nExternalConstantContext.prototype.STRING = function () {\n  return this.getToken(FHIRPathParser.STRING, 0);\n};\n\nExternalConstantContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterExternalConstant(this);\n  }\n};\n\nExternalConstantContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitExternalConstant(this);\n  }\n};\n\nFHIRPathParser.ExternalConstantContext = ExternalConstantContext;\n\nFHIRPathParser.prototype.externalConstant = function () {\n  var localctx = new ExternalConstantContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 101;\n    this.match(FHIRPathParser.T__33);\n    this.state = 104;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__15:\n      case FHIRPathParser.T__16:\n      case FHIRPathParser.T__21:\n      case FHIRPathParser.T__22:\n      case FHIRPathParser.IDENTIFIER:\n      case FHIRPathParser.DELIMITEDIDENTIFIER:\n        this.state = 102;\n        this.identifier();\n        break;\n\n      case FHIRPathParser.STRING:\n        this.state = 103;\n        this.match(FHIRPathParser.STRING);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction InvocationContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_invocation;\n  return this;\n}\n\nInvocationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nInvocationContext.prototype.constructor = InvocationContext;\n\nInvocationContext.prototype.copyFrom = function (ctx) {\n  antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n};\n\nfunction TotalInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nTotalInvocationContext.prototype = Object.create(InvocationContext.prototype);\nTotalInvocationContext.prototype.constructor = TotalInvocationContext;\nFHIRPathParser.TotalInvocationContext = TotalInvocationContext;\n\nTotalInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTotalInvocation(this);\n  }\n};\n\nTotalInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTotalInvocation(this);\n  }\n};\n\nfunction ThisInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nThisInvocationContext.prototype = Object.create(InvocationContext.prototype);\nThisInvocationContext.prototype.constructor = ThisInvocationContext;\nFHIRPathParser.ThisInvocationContext = ThisInvocationContext;\n\nThisInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterThisInvocation(this);\n  }\n};\n\nThisInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitThisInvocation(this);\n  }\n};\n\nfunction IndexInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nIndexInvocationContext.prototype = Object.create(InvocationContext.prototype);\nIndexInvocationContext.prototype.constructor = IndexInvocationContext;\nFHIRPathParser.IndexInvocationContext = IndexInvocationContext;\n\nIndexInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterIndexInvocation(this);\n  }\n};\n\nIndexInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitIndexInvocation(this);\n  }\n};\n\nfunction FunctionInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nFunctionInvocationContext.prototype = Object.create(InvocationContext.prototype);\nFunctionInvocationContext.prototype.constructor = FunctionInvocationContext;\nFHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;\n\nFunctionInvocationContext.prototype.functn = function () {\n  return this.getTypedRuleContext(FunctnContext, 0);\n};\n\nFunctionInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterFunctionInvocation(this);\n  }\n};\n\nFunctionInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitFunctionInvocation(this);\n  }\n};\n\nfunction MemberInvocationContext(parser, ctx) {\n  InvocationContext.call(this, parser);\n  InvocationContext.prototype.copyFrom.call(this, ctx);\n  return this;\n}\n\nMemberInvocationContext.prototype = Object.create(InvocationContext.prototype);\nMemberInvocationContext.prototype.constructor = MemberInvocationContext;\nFHIRPathParser.MemberInvocationContext = MemberInvocationContext;\n\nMemberInvocationContext.prototype.identifier = function () {\n  return this.getTypedRuleContext(IdentifierContext, 0);\n};\n\nMemberInvocationContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterMemberInvocation(this);\n  }\n};\n\nMemberInvocationContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitMemberInvocation(this);\n  }\n};\n\nFHIRPathParser.InvocationContext = InvocationContext;\n\nFHIRPathParser.prototype.invocation = function () {\n  var localctx = new InvocationContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);\n\n  try {\n    this.state = 111;\n\n    this._errHandler.sync(this);\n\n    var la_ = this._interp.adaptivePredict(this._input, 6, this._ctx);\n\n    switch (la_) {\n      case 1:\n        localctx = new MemberInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 1);\n        this.state = 106;\n        this.identifier();\n        break;\n\n      case 2:\n        localctx = new FunctionInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 2);\n        this.state = 107;\n        this.functn();\n        break;\n\n      case 3:\n        localctx = new ThisInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 3);\n        this.state = 108;\n        this.match(FHIRPathParser.T__34);\n        break;\n\n      case 4:\n        localctx = new IndexInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 4);\n        this.state = 109;\n        this.match(FHIRPathParser.T__35);\n        break;\n\n      case 5:\n        localctx = new TotalInvocationContext(this, localctx);\n        this.enterOuterAlt(localctx, 5);\n        this.state = 110;\n        this.match(FHIRPathParser.T__36);\n        break;\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction FunctnContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_functn;\n  return this;\n}\n\nFunctnContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nFunctnContext.prototype.constructor = FunctnContext;\n\nFunctnContext.prototype.identifier = function () {\n  return this.getTypedRuleContext(IdentifierContext, 0);\n};\n\nFunctnContext.prototype.paramList = function () {\n  return this.getTypedRuleContext(ParamListContext, 0);\n};\n\nFunctnContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterFunctn(this);\n  }\n};\n\nFunctnContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitFunctn(this);\n  }\n};\n\nFHIRPathParser.FunctnContext = FunctnContext;\n\nFHIRPathParser.prototype.functn = function () {\n  var localctx = new FunctnContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 113;\n    this.identifier();\n    this.state = 114;\n    this.match(FHIRPathParser.T__27);\n    this.state = 116;\n\n    this._errHandler.sync(this);\n\n    _la = this._input.LA(1);\n\n    if ((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22 | 1 << FHIRPathParser.T__27 | 1 << FHIRPathParser.T__29)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << FHIRPathParser.T__31 - 32 | 1 << FHIRPathParser.T__32 - 32 | 1 << FHIRPathParser.T__33 - 32 | 1 << FHIRPathParser.T__34 - 32 | 1 << FHIRPathParser.T__35 - 32 | 1 << FHIRPathParser.T__36 - 32 | 1 << FHIRPathParser.DATETIME - 32 | 1 << FHIRPathParser.TIME - 32 | 1 << FHIRPathParser.IDENTIFIER - 32 | 1 << FHIRPathParser.DELIMITEDIDENTIFIER - 32 | 1 << FHIRPathParser.STRING - 32 | 1 << FHIRPathParser.NUMBER - 32)) !== 0) {\n      this.state = 115;\n      this.paramList();\n    }\n\n    this.state = 118;\n    this.match(FHIRPathParser.T__28);\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction ParamListContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_paramList;\n  return this;\n}\n\nParamListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nParamListContext.prototype.constructor = ParamListContext;\n\nParamListContext.prototype.expression = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(ExpressionContext);\n  } else {\n    return this.getTypedRuleContext(ExpressionContext, i);\n  }\n};\n\nParamListContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterParamList(this);\n  }\n};\n\nParamListContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitParamList(this);\n  }\n};\n\nFHIRPathParser.ParamListContext = ParamListContext;\n\nFHIRPathParser.prototype.paramList = function () {\n  var localctx = new ParamListContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 120;\n    this.expression(0);\n    this.state = 125;\n\n    this._errHandler.sync(this);\n\n    _la = this._input.LA(1);\n\n    while (_la === FHIRPathParser.T__37) {\n      this.state = 121;\n      this.match(FHIRPathParser.T__37);\n      this.state = 122;\n      this.expression(0);\n      this.state = 127;\n\n      this._errHandler.sync(this);\n\n      _la = this._input.LA(1);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction QuantityContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_quantity;\n  return this;\n}\n\nQuantityContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nQuantityContext.prototype.constructor = QuantityContext;\n\nQuantityContext.prototype.NUMBER = function () {\n  return this.getToken(FHIRPathParser.NUMBER, 0);\n};\n\nQuantityContext.prototype.unit = function () {\n  return this.getTypedRuleContext(UnitContext, 0);\n};\n\nQuantityContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterQuantity(this);\n  }\n};\n\nQuantityContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitQuantity(this);\n  }\n};\n\nFHIRPathParser.QuantityContext = QuantityContext;\n\nFHIRPathParser.prototype.quantity = function () {\n  var localctx = new QuantityContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 128;\n    this.match(FHIRPathParser.NUMBER);\n    this.state = 130;\n\n    this._errHandler.sync(this);\n\n    var la_ = this._interp.adaptivePredict(this._input, 9, this._ctx);\n\n    if (la_ === 1) {\n      this.state = 129;\n      this.unit();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction UnitContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_unit;\n  return this;\n}\n\nUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nUnitContext.prototype.constructor = UnitContext;\n\nUnitContext.prototype.dateTimePrecision = function () {\n  return this.getTypedRuleContext(DateTimePrecisionContext, 0);\n};\n\nUnitContext.prototype.pluralDateTimePrecision = function () {\n  return this.getTypedRuleContext(PluralDateTimePrecisionContext, 0);\n};\n\nUnitContext.prototype.STRING = function () {\n  return this.getToken(FHIRPathParser.STRING, 0);\n};\n\nUnitContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterUnit(this);\n  }\n};\n\nUnitContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitUnit(this);\n  }\n};\n\nFHIRPathParser.UnitContext = UnitContext;\n\nFHIRPathParser.prototype.unit = function () {\n  var localctx = new UnitContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);\n\n  try {\n    this.state = 135;\n\n    this._errHandler.sync(this);\n\n    switch (this._input.LA(1)) {\n      case FHIRPathParser.T__38:\n      case FHIRPathParser.T__39:\n      case FHIRPathParser.T__40:\n      case FHIRPathParser.T__41:\n      case FHIRPathParser.T__42:\n      case FHIRPathParser.T__43:\n      case FHIRPathParser.T__44:\n      case FHIRPathParser.T__45:\n        this.enterOuterAlt(localctx, 1);\n        this.state = 132;\n        this.dateTimePrecision();\n        break;\n\n      case FHIRPathParser.T__46:\n      case FHIRPathParser.T__47:\n      case FHIRPathParser.T__48:\n      case FHIRPathParser.T__49:\n      case FHIRPathParser.T__50:\n      case FHIRPathParser.T__51:\n      case FHIRPathParser.T__52:\n      case FHIRPathParser.T__53:\n        this.enterOuterAlt(localctx, 2);\n        this.state = 133;\n        this.pluralDateTimePrecision();\n        break;\n\n      case FHIRPathParser.STRING:\n        this.enterOuterAlt(localctx, 3);\n        this.state = 134;\n        this.match(FHIRPathParser.STRING);\n        break;\n\n      default:\n        throw new antlr4.error.NoViableAltException(this);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction DateTimePrecisionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;\n  return this;\n}\n\nDateTimePrecisionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nDateTimePrecisionContext.prototype.constructor = DateTimePrecisionContext;\n\nDateTimePrecisionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterDateTimePrecision(this);\n  }\n};\n\nDateTimePrecisionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitDateTimePrecision(this);\n  }\n};\n\nFHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext;\n\nFHIRPathParser.prototype.dateTimePrecision = function () {\n  var localctx = new DateTimePrecisionContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 137;\n    _la = this._input.LA(1);\n\n    if (!((_la - 39 & ~0x1f) == 0 && (1 << _la - 39 & (1 << FHIRPathParser.T__38 - 39 | 1 << FHIRPathParser.T__39 - 39 | 1 << FHIRPathParser.T__40 - 39 | 1 << FHIRPathParser.T__41 - 39 | 1 << FHIRPathParser.T__42 - 39 | 1 << FHIRPathParser.T__43 - 39 | 1 << FHIRPathParser.T__44 - 39 | 1 << FHIRPathParser.T__45 - 39)) !== 0)) {\n      this._errHandler.recoverInline(this);\n    } else {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction PluralDateTimePrecisionContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;\n  return this;\n}\n\nPluralDateTimePrecisionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nPluralDateTimePrecisionContext.prototype.constructor = PluralDateTimePrecisionContext;\n\nPluralDateTimePrecisionContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterPluralDateTimePrecision(this);\n  }\n};\n\nPluralDateTimePrecisionContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitPluralDateTimePrecision(this);\n  }\n};\n\nFHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext;\n\nFHIRPathParser.prototype.pluralDateTimePrecision = function () {\n  var localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 139;\n    _la = this._input.LA(1);\n\n    if (!((_la - 47 & ~0x1f) == 0 && (1 << _la - 47 & (1 << FHIRPathParser.T__46 - 47 | 1 << FHIRPathParser.T__47 - 47 | 1 << FHIRPathParser.T__48 - 47 | 1 << FHIRPathParser.T__49 - 47 | 1 << FHIRPathParser.T__50 - 47 | 1 << FHIRPathParser.T__51 - 47 | 1 << FHIRPathParser.T__52 - 47 | 1 << FHIRPathParser.T__53 - 47)) !== 0)) {\n      this._errHandler.recoverInline(this);\n    } else {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction TypeSpecifierContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;\n  return this;\n}\n\nTypeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nTypeSpecifierContext.prototype.constructor = TypeSpecifierContext;\n\nTypeSpecifierContext.prototype.qualifiedIdentifier = function () {\n  return this.getTypedRuleContext(QualifiedIdentifierContext, 0);\n};\n\nTypeSpecifierContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterTypeSpecifier(this);\n  }\n};\n\nTypeSpecifierContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitTypeSpecifier(this);\n  }\n};\n\nFHIRPathParser.TypeSpecifierContext = TypeSpecifierContext;\n\nFHIRPathParser.prototype.typeSpecifier = function () {\n  var localctx = new TypeSpecifierContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 141;\n    this.qualifiedIdentifier();\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction QualifiedIdentifierContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;\n  return this;\n}\n\nQualifiedIdentifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nQualifiedIdentifierContext.prototype.constructor = QualifiedIdentifierContext;\n\nQualifiedIdentifierContext.prototype.identifier = function (i) {\n  if (i === undefined) {\n    i = null;\n  }\n\n  if (i === null) {\n    return this.getTypedRuleContexts(IdentifierContext);\n  } else {\n    return this.getTypedRuleContext(IdentifierContext, i);\n  }\n};\n\nQualifiedIdentifierContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterQualifiedIdentifier(this);\n  }\n};\n\nQualifiedIdentifierContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitQualifiedIdentifier(this);\n  }\n};\n\nFHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext;\n\nFHIRPathParser.prototype.qualifiedIdentifier = function () {\n  var localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 143;\n    this.identifier();\n    this.state = 148;\n\n    this._errHandler.sync(this);\n\n    var _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);\n\n    while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {\n      if (_alt === 1) {\n        this.state = 144;\n        this.match(FHIRPathParser.T__0);\n        this.state = 145;\n        this.identifier();\n      }\n\n      this.state = 150;\n\n      this._errHandler.sync(this);\n\n      _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nfunction IdentifierContext(parser, parent, invokingState) {\n  if (parent === undefined) {\n    parent = null;\n  }\n\n  if (invokingState === undefined || invokingState === null) {\n    invokingState = -1;\n  }\n\n  antlr4.ParserRuleContext.call(this, parent, invokingState);\n  this.parser = parser;\n  this.ruleIndex = FHIRPathParser.RULE_identifier;\n  return this;\n}\n\nIdentifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);\nIdentifierContext.prototype.constructor = IdentifierContext;\n\nIdentifierContext.prototype.IDENTIFIER = function () {\n  return this.getToken(FHIRPathParser.IDENTIFIER, 0);\n};\n\nIdentifierContext.prototype.DELIMITEDIDENTIFIER = function () {\n  return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);\n};\n\nIdentifierContext.prototype.enterRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.enterIdentifier(this);\n  }\n};\n\nIdentifierContext.prototype.exitRule = function (listener) {\n  if (listener instanceof FHIRPathListener) {\n    listener.exitIdentifier(this);\n  }\n};\n\nFHIRPathParser.IdentifierContext = IdentifierContext;\n\nFHIRPathParser.prototype.identifier = function () {\n  var localctx = new IdentifierContext(this, this._ctx, this.state);\n  this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);\n  var _la = 0; // Token type\n\n  try {\n    this.enterOuterAlt(localctx, 1);\n    this.state = 151;\n    _la = this._input.LA(1);\n\n    if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22)) !== 0 || _la === FHIRPathParser.IDENTIFIER || _la === FHIRPathParser.DELIMITEDIDENTIFIER)) {\n      this._errHandler.recoverInline(this);\n    } else {\n      this._errHandler.reportMatch(this);\n\n      this.consume();\n    }\n  } catch (re) {\n    if (re instanceof antlr4.error.RecognitionException) {\n      localctx.exception = re;\n\n      this._errHandler.reportError(this, re);\n\n      this._errHandler.recover(this, re);\n    } else {\n      throw re;\n    }\n  } finally {\n    this.exitRule();\n  }\n\n  return localctx;\n};\n\nFHIRPathParser.prototype.sempred = function (localctx, ruleIndex, predIndex) {\n  switch (ruleIndex) {\n    case 1:\n      return this.expression_sempred(localctx, predIndex);\n\n    default:\n      throw \"No predicate with index:\" + ruleIndex;\n  }\n};\n\nFHIRPathParser.prototype.expression_sempred = function (localctx, predIndex) {\n  switch (predIndex) {\n    case 0:\n      return this.precpred(this._ctx, 10);\n\n    case 1:\n      return this.precpred(this._ctx, 9);\n\n    case 2:\n      return this.precpred(this._ctx, 8);\n\n    case 3:\n      return this.precpred(this._ctx, 7);\n\n    case 4:\n      return this.precpred(this._ctx, 5);\n\n    case 5:\n      return this.precpred(this._ctx, 4);\n\n    case 6:\n      return this.precpred(this._ctx, 3);\n\n    case 7:\n      return this.precpred(this._ctx, 2);\n\n    case 8:\n      return this.precpred(this._ctx, 1);\n\n    case 9:\n      return this.precpred(this._ctx, 13);\n\n    case 10:\n      return this.precpred(this._ctx, 12);\n\n    case 11:\n      return this.precpred(this._ctx, 6);\n\n    default:\n      throw \"No predicate with index:\" + predIndex;\n  }\n};\n\nexports.FHIRPathParser = FHIRPathParser;","map":null,"metadata":{},"sourceType":"script"}