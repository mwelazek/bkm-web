{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nfunction arrayToString(a) {\n  return \"[\" + a.join(\", \") + \"]\";\n}\n\nString.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));\n\nString.prototype.hashCode = function () {\n  var remainder,\n      bytes,\n      h1,\n      h1b,\n      c1,\n      c1b,\n      c2,\n      c2b,\n      k1,\n      i,\n      key = this.toString();\n  remainder = key.length & 3; // key.length % 4\n\n  bytes = key.length - remainder;\n  h1 = String.prototype.seed;\n  c1 = 0xcc9e2d51;\n  c2 = 0x1b873593;\n  i = 0;\n\n  while (i < bytes) {\n    k1 = key.charCodeAt(i) & 0xff | (key.charCodeAt(++i) & 0xff) << 8 | (key.charCodeAt(++i) & 0xff) << 16 | (key.charCodeAt(++i) & 0xff) << 24;\n    ++i;\n    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n    k1 = k1 << 15 | k1 >>> 17;\n    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n    h1 ^= k1;\n    h1 = h1 << 13 | h1 >>> 19;\n    h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;\n    h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);\n  }\n\n  k1 = 0;\n\n  switch (remainder) {\n    case 3:\n      k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n\n    case 2:\n      k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n\n    case 1:\n      k1 ^= key.charCodeAt(i) & 0xff;\n      k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;\n      h1 ^= k1;\n  }\n\n  h1 ^= key.length;\n  h1 ^= h1 >>> 16;\n  h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;\n  h1 ^= h1 >>> 16;\n  return h1 >>> 0;\n};\n\nfunction standardEqualsFunction(a, b) {\n  return a.equals(b);\n}\n\nfunction standardHashCodeFunction(a) {\n  return a.hashCode();\n}\n\nfunction Set(hashFunction, equalsFunction) {\n  this.data = {};\n  this.hashFunction = hashFunction || standardHashCodeFunction;\n  this.equalsFunction = equalsFunction || standardEqualsFunction;\n  return this;\n}\n\nObject.defineProperty(Set.prototype, \"length\", {\n  get: function () {\n    var l = 0;\n\n    for (var key in this.data) {\n      if (key.indexOf(\"hash_\") === 0) {\n        l = l + this.data[key].length;\n      }\n    }\n\n    return l;\n  }\n});\n\nSet.prototype.add = function (value) {\n  var hash = this.hashFunction(value);\n  var key = \"hash_\" + hash;\n\n  if (key in this.data) {\n    var values = this.data[key];\n\n    for (var i = 0; i < values.length; i++) {\n      if (this.equalsFunction(value, values[i])) {\n        return values[i];\n      }\n    }\n\n    values.push(value);\n    return value;\n  } else {\n    this.data[key] = [value];\n    return value;\n  }\n};\n\nSet.prototype.contains = function (value) {\n  return this.get(value) != null;\n};\n\nSet.prototype.get = function (value) {\n  var hash = this.hashFunction(value);\n  var key = \"hash_\" + hash;\n\n  if (key in this.data) {\n    var values = this.data[key];\n\n    for (var i = 0; i < values.length; i++) {\n      if (this.equalsFunction(value, values[i])) {\n        return values[i];\n      }\n    }\n  }\n\n  return null;\n};\n\nSet.prototype.values = function () {\n  var l = [];\n\n  for (var key in this.data) {\n    if (key.indexOf(\"hash_\") === 0) {\n      l = l.concat(this.data[key]);\n    }\n  }\n\n  return l;\n};\n\nSet.prototype.toString = function () {\n  return arrayToString(this.values());\n};\n\nfunction BitSet() {\n  this.data = [];\n  return this;\n}\n\nBitSet.prototype.add = function (value) {\n  this.data[value] = true;\n};\n\nBitSet.prototype.or = function (set) {\n  var bits = this;\n  Object.keys(set.data).map(function (alt) {\n    bits.add(alt);\n  });\n};\n\nBitSet.prototype.remove = function (value) {\n  delete this.data[value];\n};\n\nBitSet.prototype.contains = function (value) {\n  return this.data[value] === true;\n};\n\nBitSet.prototype.values = function () {\n  return Object.keys(this.data);\n};\n\nBitSet.prototype.minValue = function () {\n  return Math.min.apply(null, this.values());\n};\n\nBitSet.prototype.hashCode = function () {\n  var hash = new Hash();\n  hash.update(this.values());\n  return hash.finish();\n};\n\nBitSet.prototype.equals = function (other) {\n  if (!(other instanceof BitSet)) {\n    return false;\n  }\n\n  return this.hashCode() === other.hashCode();\n};\n\nObject.defineProperty(BitSet.prototype, \"length\", {\n  get: function () {\n    return this.values().length;\n  }\n});\n\nBitSet.prototype.toString = function () {\n  return \"{\" + this.values().join(\", \") + \"}\";\n};\n\nfunction Map(hashFunction, equalsFunction) {\n  this.data = {};\n  this.hashFunction = hashFunction || standardHashCodeFunction;\n  this.equalsFunction = equalsFunction || standardEqualsFunction;\n  return this;\n}\n\nObject.defineProperty(Map.prototype, \"length\", {\n  get: function () {\n    var l = 0;\n\n    for (var hashKey in this.data) {\n      if (hashKey.indexOf(\"hash_\") === 0) {\n        l = l + this.data[hashKey].length;\n      }\n    }\n\n    return l;\n  }\n});\n\nMap.prototype.put = function (key, value) {\n  var hashKey = \"hash_\" + this.hashFunction(key);\n\n  if (hashKey in this.data) {\n    var entries = this.data[hashKey];\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (this.equalsFunction(key, entry.key)) {\n        var oldValue = entry.value;\n        entry.value = value;\n        return oldValue;\n      }\n    }\n\n    entries.push({\n      key: key,\n      value: value\n    });\n    return value;\n  } else {\n    this.data[hashKey] = [{\n      key: key,\n      value: value\n    }];\n    return value;\n  }\n};\n\nMap.prototype.containsKey = function (key) {\n  var hashKey = \"hash_\" + this.hashFunction(key);\n\n  if (hashKey in this.data) {\n    var entries = this.data[hashKey];\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n      if (this.equalsFunction(key, entry.key)) return true;\n    }\n  }\n\n  return false;\n};\n\nMap.prototype.get = function (key) {\n  var hashKey = \"hash_\" + this.hashFunction(key);\n\n  if (hashKey in this.data) {\n    var entries = this.data[hashKey];\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n      if (this.equalsFunction(key, entry.key)) return entry.value;\n    }\n  }\n\n  return null;\n};\n\nMap.prototype.entries = function () {\n  var l = [];\n\n  for (var key in this.data) {\n    if (key.indexOf(\"hash_\") === 0) {\n      l = l.concat(this.data[key]);\n    }\n  }\n\n  return l;\n};\n\nMap.prototype.getKeys = function () {\n  return this.entries().map(function (e) {\n    return e.key;\n  });\n};\n\nMap.prototype.getValues = function () {\n  return this.entries().map(function (e) {\n    return e.value;\n  });\n};\n\nMap.prototype.toString = function () {\n  var ss = this.entries().map(function (entry) {\n    return '{' + entry.key + ':' + entry.value + '}';\n  });\n  return '[' + ss.join(\", \") + ']';\n};\n\nfunction AltDict() {\n  this.data = {};\n  return this;\n}\n\nAltDict.prototype.get = function (key) {\n  key = \"k-\" + key;\n\n  if (key in this.data) {\n    return this.data[key];\n  } else {\n    return null;\n  }\n};\n\nAltDict.prototype.put = function (key, value) {\n  key = \"k-\" + key;\n  this.data[key] = value;\n};\n\nAltDict.prototype.values = function () {\n  var data = this.data;\n  var keys = Object.keys(this.data);\n  return keys.map(function (key) {\n    return data[key];\n  });\n};\n\nfunction DoubleDict(defaultMapCtor) {\n  this.defaultMapCtor = defaultMapCtor || Map;\n  this.cacheMap = new this.defaultMapCtor();\n  return this;\n}\n\nfunction Hash() {\n  this.count = 0;\n  this.hash = 0;\n  return this;\n}\n\nHash.prototype.update = function () {\n  for (var i = 0; i < arguments.length; i++) {\n    var value = arguments[i];\n    if (value == null) continue;\n    if (Array.isArray(value)) this.update.apply(this, value);else {\n      var k = 0;\n\n      switch (typeof value) {\n        case 'undefined':\n        case 'function':\n          continue;\n\n        case 'number':\n        case 'boolean':\n          k = value;\n          break;\n\n        case 'string':\n          k = value.hashCode();\n          break;\n\n        default:\n          if (value.updateHashCode) value.updateHashCode(this);else console.log(\"No updateHashCode for \" + value.toString());\n          continue;\n      }\n\n      k = k * 0xCC9E2D51;\n      k = k << 15 | k >>> 32 - 15;\n      k = k * 0x1B873593;\n      this.count = this.count + 1;\n      var hash = this.hash ^ k;\n      hash = hash << 13 | hash >>> 32 - 13;\n      hash = hash * 5 + 0xE6546B64;\n      this.hash = hash;\n    }\n  }\n};\n\nHash.prototype.finish = function () {\n  var hash = this.hash ^ this.count * 4;\n  hash = hash ^ hash >>> 16;\n  hash = hash * 0x85EBCA6B;\n  hash = hash ^ hash >>> 13;\n  hash = hash * 0xC2B2AE35;\n  hash = hash ^ hash >>> 16;\n  return hash;\n};\n\nfunction hashStuff() {\n  var hash = new Hash();\n  hash.update.apply(hash, arguments);\n  return hash.finish();\n}\n\nDoubleDict.prototype.get = function (a, b) {\n  var d = this.cacheMap.get(a) || null;\n  return d === null ? null : d.get(b) || null;\n};\n\nDoubleDict.prototype.set = function (a, b, o) {\n  var d = this.cacheMap.get(a) || null;\n\n  if (d === null) {\n    d = new this.defaultMapCtor();\n    this.cacheMap.put(a, d);\n  }\n\n  d.put(b, o);\n};\n\nfunction escapeWhitespace(s, escapeSpaces) {\n  s = s.replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\");\n\n  if (escapeSpaces) {\n    s = s.replace(/ /g, \"\\u00B7\");\n  }\n\n  return s;\n}\n\nfunction titleCase(str) {\n  return str.replace(/\\w\\S*/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1);\n  });\n}\n\n;\n\nfunction equalArrays(a, b) {\n  if (!Array.isArray(a) || !Array.isArray(b)) return false;\n  if (a == b) return true;\n  if (a.length != b.length) return false;\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] == b[i]) continue;\n    if (!a[i].equals(b[i])) return false;\n  }\n\n  return true;\n}\n\n;\nexports.Hash = Hash;\nexports.Set = Set;\nexports.Map = Map;\nexports.BitSet = BitSet;\nexports.AltDict = AltDict;\nexports.DoubleDict = DoubleDict;\nexports.hashStuff = hashStuff;\nexports.escapeWhitespace = escapeWhitespace;\nexports.arrayToString = arrayToString;\nexports.titleCase = titleCase;\nexports.equalArrays = equalArrays;","map":null,"metadata":{},"sourceType":"script"}