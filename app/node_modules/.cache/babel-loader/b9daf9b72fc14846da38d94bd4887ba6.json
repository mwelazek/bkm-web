{"ast":null,"code":"// Originally copied from node-deep-equal\n// (https://github.com/substack/node-deep-equal), with modifications.\n// For the license for node-deep-equal, see the bottom of this file.\nvar types = require('./types');\n\nvar FP_Type = types.FP_Type;\n\nvar util = require('./utilities');\n\nvar numbers = require('./numbers');\n\nvar pSlice = Array.prototype.slice;\nvar objectKeys = Object.keys;\n\nvar isArguments = function isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nfunction isString(myVar) {\n  return typeof myVar === 'string' || myVar instanceof String;\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction normalizeStr(x) {\n  return x.toUpperCase().replace(/\\s+/, ' ');\n}\n\nvar deepEqual = function deepEqual(actual, expected, opts) {\n  actual = util.valData(actual);\n  expected = util.valData(expected);\n  if (!opts) opts = {}; // 7.1. All identical values are equivalent, as determined by ===.\n\n  if (actual === expected) {\n    return true;\n  }\n\n  if (opts.fuzzy) {\n    if (isString(actual) && isString(expected)) {\n      return normalizeStr(actual) == normalizeStr(expected);\n    }\n\n    if (isNumber(actual) && isNumber(expected)) {\n      return numbers.isEquivalent(actual, expected);\n    }\n  } else {\n    // !opts.fuzzy\n    // If these are numbers, they need to be rounded to the maximum supported\n    // precision to remove floating point arithmetic errors (e.g. 0.1+0.1+0.1 should\n    // equal 0.3) before comparing.\n    if (typeof actual === 'number' && typeof expected === 'number') {\n      return numbers.isEqual(actual, expected);\n    }\n  }\n\n  if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime(); // 7.3. Other pairs that do not both pass typeof value == 'object',\n    // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n  } else {\n    var actualIsFPT = actual instanceof FP_Type;\n    var expectedIsFPT = expected instanceof FP_Type;\n\n    if (actualIsFPT && expectedIsFPT) {\n      // if both are FP_Type\n      var rtn = opts.fuzzy ? actual.equivalentTo(expected) : actual.equals(expected); // May return undefined\n\n      return rtn;\n    } else if (actualIsFPT || expectedIsFPT) {\n      // if only one is an FP_Type\n      // See if the other is convertible.\n      var fpt, nonFPT;\n\n      if (actualIsFPT) {\n        fpt = actual;\n        nonFPT = expected;\n      } else {\n        fpt = expected;\n        nonFPT = actual;\n      }\n\n      var _rtn = typeof nonFPT === 'string';\n\n      if (_rtn) {\n        var d = fpt.constructor.checkString(nonFPT);\n\n        if (d) {\n          _rtn = opts.fuzzy ? actual.equivalentTo(d) : fpt.equals(d); // May return undefined\n        } else _rtn = false; // not a date string\n\n      }\n\n      return _rtn;\n    } // 7.4. For all other Object pairs, including Array objects, equivalence is\n    // determined by having the same number of owned properties (as verified\n    // with Object.prototype.hasOwnProperty.call), the same set of keys\n    // (although not necessarily the same order), equivalent values for every\n    // corresponding key, and an identical 'prototype' property. Note: this\n    // accounts for both named and indexed properties on Arrays.\n\n\n    return objEquiv(actual, expected, opts);\n  }\n};\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false; // an identical 'prototype' property.\n\n  if (a.prototype !== b.prototype) return false; //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n\n  if (isArguments(a) || isArguments(b)) {\n    a = isArguments(a) ? pSlice.call(a) : a;\n    b = isArguments(b) ? pSlice.call(b) : b;\n    return deepEqual(a, b, opts);\n  }\n\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {\n    //happens when one is a string literal and the other isn't\n    return false;\n  } // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n\n\n  if (ka.length != kb.length) return false; //the same set of keys (although not necessarily the same order),\n\n  ka.sort();\n  kb.sort(); //~~~cheap key test\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  } //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  // If the length of the array is one, return the value of deepEqual (which can\n  // be \"undefined\".\n\n\n  if (ka.length === 1) {\n    key = ka[0];\n    return deepEqual(a[key], b[key], opts);\n  }\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n\n  return typeof a === typeof b;\n}\n\nmodule.exports = deepEqual; // The license for node-deep-equal, on which the above code is based, is as\n// follows:\n//\n// This software is released under the MIT license:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","map":null,"metadata":{},"sourceType":"script"}