{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PrefixTables = exports.PrefixTablesFactory = void 0;\n/**\n * The tables of defined prefixes is defined in this file.\n */\n\n/**\n * This class implements the table of multiplier prefixes.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\n\nclass PrefixTablesFactory {\n  /**\n   * Constructor.  This creates the empty PrefixTable hashes once.\n   * There is one hash whose key is the prefix code and one whose\n   * key is the prefix value.\n   *\n   * Implementation of this as a singleton is based on the UnitTables\n   * implementation.  See that class for details.\n   */\n  constructor() {\n    this.byCode_ = {};\n    this.byValue_ = {};\n  }\n  /**\n   * Provides the number of prefix objects in each table\n   * @returns count of the number of prefix objects in each table\n   */\n\n\n  prefixCount() {\n    return Object.keys(this.byCode_).length;\n  }\n  /**\n   * This is used to get all prefix objects by value.  Currently it is used\n   * to create a csv file with all prefixes and units.\n   * @returns csv string containing all prefix objects, ordered by value.\n   */\n\n\n  allPrefixesByValue() {\n    let prefixBuff = '';\n    let pList = Object.keys(this.byValue_); //pList.sort() ;\n\n    let pLen = pList.length;\n\n    for (let p = 0; p < pLen; p++) {\n      let pfx = this.getPrefixByValue(pList[p]);\n      prefixBuff += pfx.code_ + ',' + pfx.name_ + ',,' + pfx.value_ + '\\r\\n';\n    }\n\n    return prefixBuff;\n  }\n  /**\n   * This is used to get all prefix objects.  Currently it is used\n   * to get the objects to write to the json ucum definitions file\n   * that is used to provide prefix and unit definition objects for\n   * conversions and validations.\n   *\n   * @returns an array containing all prefix objects, ordered by code.\n   */\n\n\n  allPrefixesByCode() {\n    let prefixList = [];\n    let pList = Object.keys(this.byCode_);\n    pList.sort();\n    let pLen = pList.length;\n\n    for (let p = 0; p < pLen; p++) {\n      prefixList.push(this.getPrefixByCode(pList[p]));\n    }\n\n    return prefixList;\n  }\n  /**\n   * Adds a prefix object to the tables\n   *\n   * @param prefixObj the object to be added to the tables\n   */\n\n\n  add(prefixObj) {\n    this.byCode_[prefixObj.getCode()] = prefixObj;\n    this.byValue_[prefixObj.getValue()] = prefixObj;\n  }\n  /**\n   * Tests whether a prefix object is found for a specified code.  This\n   * is used to determine whether or not a prefix object has been created\n   * for the code.\n   *\n   * @param code the code to be used to find the prefix object\n   * @return boolean indicating whether or not a prefix object was found\n   *  for the specified code\n   */\n\n\n  isDefined(code) {\n    return this.byCode_[code] !== null && this.byCode_[code] !== undefined;\n  }\n  /**\n   * Obtains a prefix object for a specified code.\n   *\n   * @param code the code to be used to find the prefix object\n   * @return the prefix object found, or null if nothing was found\n   */\n\n\n  getPrefixByCode(code) {\n    return this.byCode_[code];\n  }\n  /**\n   * Obtains a prefix object for a specified value.\n   *\n   * @param value the value to be used to find the prefix object\n   * @return the prefix object found, or null if nothing was found\n   */\n\n\n  getPrefixByValue(value) {\n    return this.byValue_[value];\n  }\n\n} // end PrefixTablesFactory class\n// Create a singleton instance and (to preserve the existing API) an object that\n// provides that instance via getInstance().\n\n\nexports.PrefixTablesFactory = PrefixTablesFactory;\nvar prefixTablesInstance = new PrefixTablesFactory();\nconst PrefixTables = {\n  getInstance: function () {\n    return prefixTablesInstance;\n  }\n};\nexports.PrefixTables = PrefixTables;","map":null,"metadata":{},"sourceType":"script"}