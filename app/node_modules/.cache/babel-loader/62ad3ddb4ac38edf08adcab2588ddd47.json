{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction default_hash(x) {\n  return x;\n}\n/**\n * Takes an array of arrays and optionnally a hash function,\n * and returns the elements that are present in all the arrays.\n * When intersecting arrays of objects, you should use a custom\n * hash function that returns identical values when given objects\n * that should be considered equal in your application.\n * The default hash function is the identity function.\n * When performance is not critical, a handy hash function can be `JSON.stringify`.\n */\n\n\nfunction intersect(arrays) {\n  let hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : default_hash;\n  if (arrays.length === 0) return []; // Put the smallest array in the beginning\n\n  for (let i = 1; i < arrays.length; i++) {\n    if (arrays[i].length < arrays[0].length) {\n      let tmp = arrays[0];\n      arrays[0] = arrays[i];\n      arrays[i] = tmp;\n    }\n  } // Create a map associating each element to its current count\n\n\n  const set = new Map();\n\n  for (const elem of arrays[0]) {\n    set.set(hash(elem), 1);\n  }\n\n  for (let i = 1; i < arrays.length; i++) {\n    let found = 0;\n\n    for (const elem of arrays[i]) {\n      const hashed = hash(elem);\n      const count = set.get(hashed);\n\n      if (count === i) {\n        set.set(hashed, count + 1);\n        found++;\n      }\n    } // Stop early if an array has no element in common with the smallest\n\n\n    if (found === 0) return [];\n  } // Output only the elements that have been seen as many times as there are arrays\n\n\n  return arrays[0].filter(e => {\n    const hashed = hash(e);\n    const count = set.get(hashed);\n    if (count !== undefined) set.set(hashed, 0);\n    return count === arrays.length;\n  });\n}\n\nexports.default = intersect;","map":null,"metadata":{},"sourceType":"script"}