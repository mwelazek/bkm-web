{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n// The basic notion of a tree has a parent, a payload, and a list of children.\n//  It is the most abstract interface for all the trees used by ANTLR.\n///\nvar Token = require('./../Token').Token;\n\nvar Interval = require('./../IntervalSet').Interval;\n\nvar INVALID_INTERVAL = new Interval(-1, -2);\n\nvar Utils = require('../Utils.js');\n\nfunction Tree() {\n  return this;\n}\n\nfunction SyntaxTree() {\n  Tree.call(this);\n  return this;\n}\n\nSyntaxTree.prototype = Object.create(Tree.prototype);\nSyntaxTree.prototype.constructor = SyntaxTree;\n\nfunction ParseTree() {\n  SyntaxTree.call(this);\n  return this;\n}\n\nParseTree.prototype = Object.create(SyntaxTree.prototype);\nParseTree.prototype.constructor = ParseTree;\n\nfunction RuleNode() {\n  ParseTree.call(this);\n  return this;\n}\n\nRuleNode.prototype = Object.create(ParseTree.prototype);\nRuleNode.prototype.constructor = RuleNode;\n\nfunction TerminalNode() {\n  ParseTree.call(this);\n  return this;\n}\n\nTerminalNode.prototype = Object.create(ParseTree.prototype);\nTerminalNode.prototype.constructor = TerminalNode;\n\nfunction ErrorNode() {\n  TerminalNode.call(this);\n  return this;\n}\n\nErrorNode.prototype = Object.create(TerminalNode.prototype);\nErrorNode.prototype.constructor = ErrorNode;\n\nfunction ParseTreeVisitor() {\n  return this;\n}\n\nParseTreeVisitor.prototype.visit = function (ctx) {\n  if (Array.isArray(ctx)) {\n    return ctx.map(function (child) {\n      return child.accept(this);\n    }, this);\n  } else {\n    return ctx.accept(this);\n  }\n};\n\nParseTreeVisitor.prototype.visitChildren = function (ctx) {\n  if (ctx.children) {\n    return this.visit(ctx.children);\n  } else {\n    return null;\n  }\n};\n\nParseTreeVisitor.prototype.visitTerminal = function (node) {};\n\nParseTreeVisitor.prototype.visitErrorNode = function (node) {};\n\nfunction ParseTreeListener() {\n  return this;\n}\n\nParseTreeListener.prototype.visitTerminal = function (node) {};\n\nParseTreeListener.prototype.visitErrorNode = function (node) {};\n\nParseTreeListener.prototype.enterEveryRule = function (node) {};\n\nParseTreeListener.prototype.exitEveryRule = function (node) {};\n\nfunction TerminalNodeImpl(symbol) {\n  TerminalNode.call(this);\n  this.parentCtx = null;\n  this.symbol = symbol;\n  return this;\n}\n\nTerminalNodeImpl.prototype = Object.create(TerminalNode.prototype);\nTerminalNodeImpl.prototype.constructor = TerminalNodeImpl;\n\nTerminalNodeImpl.prototype.getChild = function (i) {\n  return null;\n};\n\nTerminalNodeImpl.prototype.getSymbol = function () {\n  return this.symbol;\n};\n\nTerminalNodeImpl.prototype.getParent = function () {\n  return this.parentCtx;\n};\n\nTerminalNodeImpl.prototype.getPayload = function () {\n  return this.symbol;\n};\n\nTerminalNodeImpl.prototype.getSourceInterval = function () {\n  if (this.symbol === null) {\n    return INVALID_INTERVAL;\n  }\n\n  var tokenIndex = this.symbol.tokenIndex;\n  return new Interval(tokenIndex, tokenIndex);\n};\n\nTerminalNodeImpl.prototype.getChildCount = function () {\n  return 0;\n};\n\nTerminalNodeImpl.prototype.accept = function (visitor) {\n  return visitor.visitTerminal(this);\n};\n\nTerminalNodeImpl.prototype.getText = function () {\n  return this.symbol.text;\n};\n\nTerminalNodeImpl.prototype.toString = function () {\n  if (this.symbol.type === Token.EOF) {\n    return \"<EOF>\";\n  } else {\n    return this.symbol.text;\n  }\n}; // Represents a token that was consumed during resynchronization\n// rather than during a valid match operation. For example,\n// we will create this kind of a node during single token insertion\n// and deletion as well as during \"consume until error recovery set\"\n// upon no viable alternative exceptions.\n\n\nfunction ErrorNodeImpl(token) {\n  TerminalNodeImpl.call(this, token);\n  return this;\n}\n\nErrorNodeImpl.prototype = Object.create(TerminalNodeImpl.prototype);\nErrorNodeImpl.prototype.constructor = ErrorNodeImpl;\n\nErrorNodeImpl.prototype.isErrorNode = function () {\n  return true;\n};\n\nErrorNodeImpl.prototype.accept = function (visitor) {\n  return visitor.visitErrorNode(this);\n};\n\nfunction ParseTreeWalker() {\n  return this;\n}\n\nParseTreeWalker.prototype.walk = function (listener, t) {\n  var errorNode = t instanceof ErrorNode || t.isErrorNode !== undefined && t.isErrorNode();\n\n  if (errorNode) {\n    listener.visitErrorNode(t);\n  } else if (t instanceof TerminalNode) {\n    listener.visitTerminal(t);\n  } else {\n    this.enterRule(listener, t);\n\n    for (var i = 0; i < t.getChildCount(); i++) {\n      var child = t.getChild(i);\n      this.walk(listener, child);\n    }\n\n    this.exitRule(listener, t);\n  }\n}; //\n// The discovery of a rule node, involves sending two events: the generic\n// {@link ParseTreeListener//enterEveryRule} and a\n// {@link RuleContext}-specific event. First we trigger the generic and then\n// the rule specific. We to them in reverse order upon finishing the node.\n//\n\n\nParseTreeWalker.prototype.enterRule = function (listener, r) {\n  var ctx = r.getRuleContext();\n  listener.enterEveryRule(ctx);\n  ctx.enterRule(listener);\n};\n\nParseTreeWalker.prototype.exitRule = function (listener, r) {\n  var ctx = r.getRuleContext();\n  ctx.exitRule(listener);\n  listener.exitEveryRule(ctx);\n};\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\nexports.RuleNode = RuleNode;\nexports.ErrorNode = ErrorNode;\nexports.TerminalNode = TerminalNode;\nexports.ErrorNodeImpl = ErrorNodeImpl;\nexports.TerminalNodeImpl = TerminalNodeImpl;\nexports.ParseTreeListener = ParseTreeListener;\nexports.ParseTreeVisitor = ParseTreeVisitor;\nexports.ParseTreeWalker = ParseTreeWalker;\nexports.INVALID_INTERVAL = INVALID_INTERVAL;","map":null,"metadata":{},"sourceType":"script"}