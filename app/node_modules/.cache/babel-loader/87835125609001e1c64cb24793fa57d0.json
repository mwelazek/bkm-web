{"ast":null,"code":"// This file holds code to hande the FHIRPath Math functions.\nvar util = require(\"./utilities\");\n\nvar deepEqual = require('./deep-equal');\n\nvar types = require('./types');\n\nconst FP_Type = types.FP_Type;\nconst FP_DateTime = types.FP_DateTime;\nconst FP_Time = types.FP_Time;\nvar engine = {};\n\nfunction equality(x, y) {\n  if (util.isEmpty(x) || util.isEmpty(y)) {\n    return [];\n  }\n\n  return deepEqual(x, y);\n}\n\nfunction equivalence(x, y) {\n  if (util.isEmpty(x) && util.isEmpty(y)) {\n    return [true];\n  }\n\n  if (util.isEmpty(x) || util.isEmpty(y)) {\n    return [];\n  }\n\n  return deepEqual(x, y, {\n    fuzzy: true\n  });\n}\n\nengine.equal = function (a, b) {\n  return equality(a, b);\n};\n\nengine.unequal = function (a, b) {\n  var eq = equality(a, b);\n  return eq === undefined ? undefined : !eq;\n};\n\nengine.equival = function (a, b) {\n  return equivalence(a, b);\n};\n\nengine.unequival = function (a, b) {\n  return !equivalence(a, b);\n};\n/**\n *  Checks that the types of a and b are suitable for comparison in an\n *  inequality expression.  It is assumed that a check has already been made\n *  that there is at least one value in a and b.\n * @param a the left side of the inequality expression (which should be an array of\n *  one value).\n * @param b the right side of the inequality expression (which should be an array of\n *  one value).\n * @return the singleton values of the arrays a, and b.  If one was an FP_Type\n *  and the other was convertible, the coverted value will be retureed.\n */\n\n\nfunction typecheck(a, b) {\n  let rtn = null;\n  util.assertAtMostOne(a, \"Singleton was expected\");\n  util.assertAtMostOne(b, \"Singleton was expected\");\n  a = util.valData(a[0]);\n  b = util.valData(b[0]);\n  let lClass = a.constructor;\n  let rClass = b.constructor;\n\n  if (lClass != rClass) {\n    // See if one is an FPDateTime or FTTime while the other is a string.\n    var d;\n\n    if (lClass === String && (rClass === FP_DateTime || rClass === FP_Time)) {\n      d = rClass.checkString(a);\n      if (d) rtn = [d, b];\n    } else if (rClass === String && (lClass === FP_DateTime || lClass === FP_Time)) {\n      d = lClass.checkString(b);\n      if (d) rtn = [a, d];\n    }\n\n    if (!rtn) {\n      util.raiseError('Type of \"' + a + '\" (' + lClass.name + ') did not match type of \"' + b + '\" (' + rClass.name + ')', 'InequalityExpression');\n    }\n  }\n\n  return rtn ? rtn : [a, b];\n}\n\nengine.lt = function (a, b) {\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a, b);\n\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare < 0;\n  }\n\n  return a0 < b0;\n};\n\nengine.gt = function (a, b) {\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a, b);\n\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare > 0;\n  }\n\n  return a0 > b0;\n};\n\nengine.lte = function (a, b) {\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a, b);\n\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare <= 0;\n  }\n\n  return a0 <= b0;\n};\n\nengine.gte = function (a, b) {\n  if (!a.length || !b.length) return [];\n  const [a0, b0] = typecheck(a, b);\n\n  if (a0 instanceof FP_Type) {\n    const compare = a0.compare(b0);\n    return compare === null ? [] : compare >= 0;\n  }\n\n  return a0 >= b0;\n};\n\nmodule.exports = engine;","map":null,"metadata":{},"sourceType":"script"}