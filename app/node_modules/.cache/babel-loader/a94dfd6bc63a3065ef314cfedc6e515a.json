{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\nfunction LexerActionType() {}\n\nLexerActionType.CHANNEL = 0; //The type of a {@link LexerChannelAction} action.\n\nLexerActionType.CUSTOM = 1; //The type of a {@link LexerCustomAction} action.\n\nLexerActionType.MODE = 2; //The type of a {@link LexerModeAction} action.\n\nLexerActionType.MORE = 3; //The type of a {@link LexerMoreAction} action.\n\nLexerActionType.POP_MODE = 4; //The type of a {@link LexerPopModeAction} action.\n\nLexerActionType.PUSH_MODE = 5; //The type of a {@link LexerPushModeAction} action.\n\nLexerActionType.SKIP = 6; //The type of a {@link LexerSkipAction} action.\n\nLexerActionType.TYPE = 7; //The type of a {@link LexerTypeAction} action.\n\nfunction LexerAction(action) {\n  this.actionType = action;\n  this.isPositionDependent = false;\n  return this;\n}\n\nLexerAction.prototype.hashCode = function () {\n  var hash = new Hash();\n  this.updateHashCode(hash);\n  return hash.finish();\n};\n\nLexerAction.prototype.updateHashCode = function (hash) {\n  hash.update(this.actionType);\n};\n\nLexerAction.prototype.equals = function (other) {\n  return this === other;\n}; //\n// Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n//\n// <p>The {@code skip} command does not have any parameters, so this action is\n// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n\n\nfunction LexerSkipAction() {\n  LexerAction.call(this, LexerActionType.SKIP);\n  return this;\n}\n\nLexerSkipAction.prototype = Object.create(LexerAction.prototype);\nLexerSkipAction.prototype.constructor = LexerSkipAction; // Provides a singleton instance of this parameterless lexer action.\n\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n\nLexerSkipAction.prototype.execute = function (lexer) {\n  lexer.skip();\n};\n\nLexerSkipAction.prototype.toString = function () {\n  return \"skip\";\n}; //  Implements the {@code type} lexer action by calling {@link Lexer//setType}\n// with the assigned type.\n\n\nfunction LexerTypeAction(type) {\n  LexerAction.call(this, LexerActionType.TYPE);\n  this.type = type;\n  return this;\n}\n\nLexerTypeAction.prototype = Object.create(LexerAction.prototype);\nLexerTypeAction.prototype.constructor = LexerTypeAction;\n\nLexerTypeAction.prototype.execute = function (lexer) {\n  lexer.type = this.type;\n};\n\nLexerTypeAction.prototype.updateHashCode = function (hash) {\n  hash.update(this.actionType, this.type);\n};\n\nLexerTypeAction.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof LexerTypeAction)) {\n    return false;\n  } else {\n    return this.type === other.type;\n  }\n};\n\nLexerTypeAction.prototype.toString = function () {\n  return \"type(\" + this.type + \")\";\n}; // Implements the {@code pushMode} lexer action by calling\n// {@link Lexer//pushMode} with the assigned mode.\n\n\nfunction LexerPushModeAction(mode) {\n  LexerAction.call(this, LexerActionType.PUSH_MODE);\n  this.mode = mode;\n  return this;\n}\n\nLexerPushModeAction.prototype = Object.create(LexerAction.prototype);\nLexerPushModeAction.prototype.constructor = LexerPushModeAction; // <p>This action is implemented by calling {@link Lexer//pushMode} with the\n// value provided by {@link //getMode}.</p>\n\nLexerPushModeAction.prototype.execute = function (lexer) {\n  lexer.pushMode(this.mode);\n};\n\nLexerPushModeAction.prototype.updateHashCode = function (hash) {\n  hash.update(this.actionType, this.mode);\n};\n\nLexerPushModeAction.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof LexerPushModeAction)) {\n    return false;\n  } else {\n    return this.mode === other.mode;\n  }\n};\n\nLexerPushModeAction.prototype.toString = function () {\n  return \"pushMode(\" + this.mode + \")\";\n}; // Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n//\n// <p>The {@code popMode} command does not have any parameters, so this action is\n// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n\n\nfunction LexerPopModeAction() {\n  LexerAction.call(this, LexerActionType.POP_MODE);\n  return this;\n}\n\nLexerPopModeAction.prototype = Object.create(LexerAction.prototype);\nLexerPopModeAction.prototype.constructor = LexerPopModeAction;\nLexerPopModeAction.INSTANCE = new LexerPopModeAction(); // <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n\nLexerPopModeAction.prototype.execute = function (lexer) {\n  lexer.popMode();\n};\n\nLexerPopModeAction.prototype.toString = function () {\n  return \"popMode\";\n}; // Implements the {@code more} lexer action by calling {@link Lexer//more}.\n//\n// <p>The {@code more} command does not have any parameters, so this action is\n// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n\n\nfunction LexerMoreAction() {\n  LexerAction.call(this, LexerActionType.MORE);\n  return this;\n}\n\nLexerMoreAction.prototype = Object.create(LexerAction.prototype);\nLexerMoreAction.prototype.constructor = LexerMoreAction;\nLexerMoreAction.INSTANCE = new LexerMoreAction(); // <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n\nLexerMoreAction.prototype.execute = function (lexer) {\n  lexer.more();\n};\n\nLexerMoreAction.prototype.toString = function () {\n  return \"more\";\n}; // Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n// the assigned mode.\n\n\nfunction LexerModeAction(mode) {\n  LexerAction.call(this, LexerActionType.MODE);\n  this.mode = mode;\n  return this;\n}\n\nLexerModeAction.prototype = Object.create(LexerAction.prototype);\nLexerModeAction.prototype.constructor = LexerModeAction; // <p>This action is implemented by calling {@link Lexer//mode} with the\n// value provided by {@link //getMode}.</p>\n\nLexerModeAction.prototype.execute = function (lexer) {\n  lexer.mode(this.mode);\n};\n\nLexerModeAction.prototype.updateHashCode = function (hash) {\n  hash.update(this.actionType, this.mode);\n};\n\nLexerModeAction.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof LexerModeAction)) {\n    return false;\n  } else {\n    return this.mode === other.mode;\n  }\n};\n\nLexerModeAction.prototype.toString = function () {\n  return \"mode(\" + this.mode + \")\";\n}; // Executes a custom lexer action by calling {@link Recognizer//action} with the\n// rule and action indexes assigned to the custom action. The implementation of\n// a custom action is added to the generated code for the lexer in an override\n// of {@link Recognizer//action} when the grammar is compiled.\n//\n// <p>This class may represent embedded actions created with the <code>{...}</code>\n// syntax in ANTLR 4, as well as actions created for lexer commands where the\n// command argument could not be evaluated when the grammar was compiled.</p>\n// Constructs a custom lexer action with the specified rule and action\n// indexes.\n//\n// @param ruleIndex The rule index to use for calls to\n// {@link Recognizer//action}.\n// @param actionIndex The action index to use for calls to\n// {@link Recognizer//action}.\n\n\nfunction LexerCustomAction(ruleIndex, actionIndex) {\n  LexerAction.call(this, LexerActionType.CUSTOM);\n  this.ruleIndex = ruleIndex;\n  this.actionIndex = actionIndex;\n  this.isPositionDependent = true;\n  return this;\n}\n\nLexerCustomAction.prototype = Object.create(LexerAction.prototype);\nLexerCustomAction.prototype.constructor = LexerCustomAction; // <p>Custom actions are implemented by calling {@link Lexer//action} with the\n// appropriate rule and action indexes.</p>\n\nLexerCustomAction.prototype.execute = function (lexer) {\n  lexer.action(null, this.ruleIndex, this.actionIndex);\n};\n\nLexerCustomAction.prototype.updateHashCode = function (hash) {\n  hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n};\n\nLexerCustomAction.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof LexerCustomAction)) {\n    return false;\n  } else {\n    return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n  }\n}; // Implements the {@code channel} lexer action by calling\n// {@link Lexer//setChannel} with the assigned channel.\n// Constructs a new {@code channel} action with the specified channel value.\n// @param channel The channel value to pass to {@link Lexer//setChannel}.\n\n\nfunction LexerChannelAction(channel) {\n  LexerAction.call(this, LexerActionType.CHANNEL);\n  this.channel = channel;\n  return this;\n}\n\nLexerChannelAction.prototype = Object.create(LexerAction.prototype);\nLexerChannelAction.prototype.constructor = LexerChannelAction; // <p>This action is implemented by calling {@link Lexer//setChannel} with the\n// value provided by {@link //getChannel}.</p>\n\nLexerChannelAction.prototype.execute = function (lexer) {\n  lexer._channel = this.channel;\n};\n\nLexerChannelAction.prototype.updateHashCode = function (hash) {\n  hash.update(this.actionType, this.channel);\n};\n\nLexerChannelAction.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof LexerChannelAction)) {\n    return false;\n  } else {\n    return this.channel === other.channel;\n  }\n};\n\nLexerChannelAction.prototype.toString = function () {\n  return \"channel(\" + this.channel + \")\";\n}; // This implementation of {@link LexerAction} is used for tracking input offsets\n// for position-dependent actions within a {@link LexerActionExecutor}.\n//\n// <p>This action is not serialized as part of the ATN, and is only required for\n// position-dependent lexer actions which appear at a location other than the\n// end of a rule. For more information about DFA optimizations employed for\n// lexer actions, see {@link LexerActionExecutor//append} and\n// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n// Constructs a new indexed custom action by associating a character offset\n// with a {@link LexerAction}.\n//\n// <p>Note: This class is only required for lexer actions for which\n// {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n//\n// @param offset The offset into the input {@link CharStream}, relative to\n// the token start index, at which the specified lexer action should be\n// executed.\n// @param action The lexer action to execute at a particular offset in the\n// input {@link CharStream}.\n\n\nfunction LexerIndexedCustomAction(offset, action) {\n  LexerAction.call(this, action.actionType);\n  this.offset = offset;\n  this.action = action;\n  this.isPositionDependent = true;\n  return this;\n}\n\nLexerIndexedCustomAction.prototype = Object.create(LexerAction.prototype);\nLexerIndexedCustomAction.prototype.constructor = LexerIndexedCustomAction; // <p>This method calls {@link //execute} on the result of {@link //getAction}\n// using the provided {@code lexer}.</p>\n\nLexerIndexedCustomAction.prototype.execute = function (lexer) {\n  // assume the input stream position was properly set by the calling code\n  this.action.execute(lexer);\n};\n\nLexerIndexedCustomAction.prototype.updateHashCode = function (hash) {\n  hash.update(this.actionType, this.offset, this.action);\n};\n\nLexerIndexedCustomAction.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof LexerIndexedCustomAction)) {\n    return false;\n  } else {\n    return this.offset === other.offset && this.action === other.action;\n  }\n};\n\nexports.LexerActionType = LexerActionType;\nexports.LexerSkipAction = LexerSkipAction;\nexports.LexerChannelAction = LexerChannelAction;\nexports.LexerCustomAction = LexerCustomAction;\nexports.LexerIndexedCustomAction = LexerIndexedCustomAction;\nexports.LexerMoreAction = LexerMoreAction;\nexports.LexerTypeAction = LexerTypeAction;\nexports.LexerPushModeAction = LexerPushModeAction;\nexports.LexerPopModeAction = LexerPopModeAction;\nexports.LexerModeAction = LexerModeAction;","map":null,"metadata":{},"sourceType":"script"}