{"ast":null,"code":"import _classCallCheck from \"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport keyCode from './constants/key-code';\nimport tabbable from 'tabbable';\nimport { getDocumentActiveElement } from './focus-utils';\nimport { getEventTarget } from './web-component/events';\n/* Class som ved init låser fokuset inne i én DOMElement. Bruksområder er f.eks Modalvinduer.\nTar imot en DomNode (HTMLElement eller string) som fokuset skal låses i. */\n\nexport var TrapFocus = /*#__PURE__*/function () {\n  function TrapFocus(domNode) {\n    var isTriggerWithinTrappedArea = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, TrapFocus);\n\n    this.domNode = typeof domNode === 'string' ? document.querySelector(domNode) : domNode;\n    var activeElement = getDocumentActiveElement(domNode);\n    this.previouslyFocusedItem = activeElement ? activeElement : document.activeElement; // Get focusable elements\n\n    this.updateFocusableItems(); // Set focus to element to be able to listen for keypress\n\n    if (!isTriggerWithinTrappedArea && this.focusableItems.length) {\n      this.focusableItems[0].focus();\n    }\n\n    window.addEventListener('keydown', this, false);\n  }\n\n  _createClass(TrapFocus, [{\n    key: \"deactivate\",\n    value: function deactivate() {\n      window.removeEventListener('keydown', this, false);\n      this.focusableItems = [];\n      this.domNode = null;\n\n      if (this.previouslyFocusedItem && this.previouslyFocusedItem.focus) {\n        this.previouslyFocusedItem.focus();\n      }\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(e) {\n      if (e.keyCode !== keyCode.TAB) {\n        return null;\n      }\n\n      e.stopPropagation();\n      e.preventDefault();\n      var target = getEventTarget(e);\n      this.updateFocusableItems();\n      var currentFocusIndex = this.getItemIndex(target); // When the element focused is not in list, sets focus on the first focusable element of the list\n\n      if (currentFocusIndex === -1) {\n        if (this.focusableItems.length > 0 && this.focusableItems[0]) {\n          this.focusableItems[0].focus();\n        }\n\n        return null;\n      }\n\n      if (e.shiftKey) {\n        this.previousFocusableItem(target).focus();\n      } else {\n        this.nextFocusableItem(target).focus();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"updateFocusableItems\",\n    value: function updateFocusableItems() {\n      if (this.domNode) {\n        this.focusableItems = tabbable(this.domNode);\n      }\n    }\n  }, {\n    key: \"previousFocusableRadioButton\",\n    value: function previousFocusableRadioButton(itemWithFocus) {\n      var currentFocusIndex = this.getItemIndex(itemWithFocus); // Previous focusable item should not be a radio button in same group\n\n      for (var i = currentFocusIndex; i >= 0; i--) {\n        var previousElement = this.focusableItems[i];\n\n        if (!this.isRadioButton(previousElement)) {\n          return previousElement;\n        } // Element is a radio button, but not in same group\n\n\n        if (previousElement.name !== itemWithFocus.name) {\n          return this.getSelectedRadioInGroup(previousElement);\n        }\n      } // All the previous items are in the same radio group, start from end\n\n\n      for (var _i = this.focusableItems.length - 1; _i > currentFocusIndex; _i--) {\n        var _previousElement = this.focusableItems[_i];\n\n        if (!this.isRadioButton(_previousElement)) {\n          return _previousElement;\n        } // Element is a radio button, but not in same group\n\n\n        if (_previousElement.name !== itemWithFocus.name) {\n          return this.getSelectedRadioInGroup(_previousElement);\n        }\n      } // Still no element found: we have only radio buttons in the same group\n\n\n      return this.getSelectedRadioInGroup(itemWithFocus);\n    }\n  }, {\n    key: \"previousFocusableItem\",\n    value: function previousFocusableItem(itemWithFocus) {\n      var currentFocusIndex = this.getItemIndex(itemWithFocus);\n\n      if (!this.isRadioButton(itemWithFocus)) {\n        var previousFocusIndex = currentFocusIndex - 1; // Wrap around\n\n        if (previousFocusIndex < 0) {\n          previousFocusIndex = this.focusableItems.length - 1;\n        }\n\n        return this.getSelectedRadioInGroup(this.focusableItems[previousFocusIndex]);\n      }\n\n      return this.previousFocusableRadioButton(itemWithFocus);\n    }\n  }, {\n    key: \"nextFocusableRadioButton\",\n    value: function nextFocusableRadioButton(itemWithFocus) {\n      var currentFocusIndex = this.getItemIndex(itemWithFocus); // Next focusable item should not be a radio button in same group\n\n      for (var i = currentFocusIndex + 1; i < this.focusableItems.length; i++) {\n        var nextElement = this.focusableItems[i];\n\n        if (!this.isRadioButton(nextElement)) {\n          return nextElement;\n        } // Element is a radio button, but not in same group\n\n\n        if (nextElement.name !== itemWithFocus.name) {\n          return this.getSelectedRadioInGroup(nextElement);\n        }\n      } // All the next items are in the same radio group, start from beginning\n\n\n      for (var _i2 = 0; _i2 < currentFocusIndex; _i2++) {\n        var _nextElement = this.focusableItems[_i2];\n\n        if (!this.isRadioButton(_nextElement)) {\n          return _nextElement;\n        } // Element is a radio button, but not in same group\n\n\n        if (_nextElement.name !== itemWithFocus.name) {\n          return this.getSelectedRadioInGroup(_nextElement);\n        }\n      } // Still no element found: we have only radio buttons in the same group\n\n\n      return this.getSelectedRadioInGroup(itemWithFocus);\n    }\n  }, {\n    key: \"nextFocusableItem\",\n    value: function nextFocusableItem(itemWithFocus) {\n      var currentFocusIndex = this.getItemIndex(itemWithFocus);\n\n      if (!this.isRadioButton(itemWithFocus)) {\n        var nextFocusIndex = currentFocusIndex + 1; // Wrap around\n\n        if (nextFocusIndex > this.focusableItems.length - 1) {\n          nextFocusIndex = 0;\n        }\n\n        return this.getSelectedRadioInGroup(this.focusableItems[nextFocusIndex]);\n      }\n\n      return this.nextFocusableRadioButton(itemWithFocus);\n    } // If user tabbed into a radio group, we need to focus the selected radio button in the group\n\n  }, {\n    key: \"getSelectedRadioInGroup\",\n    value: function getSelectedRadioInGroup(item) {\n      if (!this.isRadioButton(item)) {\n        return item;\n      }\n\n      var currentFocusIndex = this.getItemIndex(item);\n      var radioGrouItems = [];\n      var i;\n\n      for (i = currentFocusIndex; i < this.focusableItems.length; i++) {\n        if (this.focusableItems[i].name === item.name) {\n          radioGrouItems.push(this.focusableItems[i]);\n        } else {\n          break; // Element is not in radio group, no need to continue loop\n        }\n      }\n\n      for (i = currentFocusIndex - 1; i >= 0; i--) {\n        if (this.focusableItems[i].name === item.name) {\n          radioGrouItems.push(this.focusableItems[i]);\n        } else {\n          break; // Element is not in radio group, no need to continue loop\n        }\n      }\n\n      var selectedItems = radioGrouItems.filter(function (i) {\n        return i.checked;\n      });\n\n      if (selectedItems.length === 0) {\n        return item; // No element in this group is selected\n      }\n\n      return selectedItems[0];\n    }\n  }, {\n    key: \"getItemIndex\",\n    value: function getItemIndex(item) {\n      return this.focusableItems.indexOf(item);\n    }\n  }, {\n    key: \"isRadioButton\",\n    value: function isRadioButton(element) {\n      return element.type === 'radio';\n    }\n  }]);\n\n  return TrapFocus;\n}();\nexport default TrapFocus;","map":null,"metadata":{},"sourceType":"module"}