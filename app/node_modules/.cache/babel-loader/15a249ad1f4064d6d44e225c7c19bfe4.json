{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncToGenerator = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nrequire(\"core-js/modules/es.array.flat.js\");\n\nrequire(\"core-js/modules/es.array.unscopables.flat.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lib_1 = require(\"./lib\");\n\nvar strings_1 = require(\"./strings\");\n\nvar settings_1 = require(\"./settings\"); // $lab:coverage:off$\n// @ts-ignore\n\n\nvar _ref = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\"),\n    Response = _ref.Response; // $lab:coverage:on$\n\n\nvar debug = lib_1.debug.extend(\"client\");\n/**\n * Adds patient context to requestOptions object to be used with [[Client.request]]\n * @param requestOptions Can be a string URL (relative to the serviceUrl), or an\n * object which will be passed to fetch()\n * @param client Current FHIR client object containing patient context\n * @return requestOptions object contextualized to current patient\n */\n\nfunction contextualize(_x, _x2) {\n  return _contextualize.apply(this, arguments);\n}\n/**\n * Gets single reference by id. Caches the result.\n * @param refId\n * @param cache A map to store the resolved refs\n * @param client The client instance\n * @param [signal] The `AbortSignal` if any\n * @returns The resolved reference\n * @private\n */\n\n\nfunction _contextualize() {\n  _contextualize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(requestOptions, client) {\n    var base, contextualURL, _contextualURL;\n\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _contextualURL = function _contextualURL3() {\n              _contextualURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(_url) {\n                var resourceType, conformance, searchParam;\n                return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                  while (1) {\n                    switch (_context8.prev = _context8.next) {\n                      case 0:\n                        resourceType = _url.pathname.split(\"/\").pop();\n                        lib_1.assert(resourceType, \"Invalid url \\\"\".concat(_url, \"\\\"\"));\n                        lib_1.assert(settings_1.patientCompartment.indexOf(resourceType) > -1, \"Cannot filter \\\"\".concat(resourceType, \"\\\" resources by patient\"));\n                        _context8.next = 5;\n                        return lib_1.fetchConformanceStatement(client.state.serverUrl);\n\n                      case 5:\n                        conformance = _context8.sent;\n                        searchParam = lib_1.getPatientParam(conformance, resourceType);\n\n                        _url.searchParams.set(searchParam, client.patient.id);\n\n                        return _context8.abrupt(\"return\", _url.href);\n\n                      case 9:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }\n                }, _callee8);\n              }));\n              return _contextualURL.apply(this, arguments);\n            };\n\n            contextualURL = function _contextualURL2(_x9) {\n              return _contextualURL.apply(this, arguments);\n            };\n\n            base = lib_1.absolute(\"/\", client.state.serverUrl);\n\n            if (!(typeof requestOptions == \"string\" || requestOptions instanceof URL)) {\n              _context9.next = 8;\n              break;\n            }\n\n            _context9.next = 6;\n            return contextualURL(new URL(requestOptions + \"\", base));\n\n          case 6:\n            _context9.t0 = _context9.sent;\n            return _context9.abrupt(\"return\", {\n              url: _context9.t0\n            });\n\n          case 8:\n            _context9.next = 10;\n            return contextualURL(new URL(requestOptions.url + \"\", base));\n\n          case 10:\n            requestOptions.url = _context9.sent;\n            return _context9.abrupt(\"return\", requestOptions);\n\n          case 12:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _contextualize.apply(this, arguments);\n}\n\nfunction getRef(refId, cache, client, signal) {\n  if (!cache[refId]) {\n    // Note that we set cache[refId] immediately! When the promise is\n    // settled it will be updated. This is to avoid a ref being fetched\n    // twice because some of these requests are executed in parallel.\n    cache[refId] = client.request({\n      url: refId,\n      signal: signal\n    }).then(function (res) {\n      cache[refId] = res;\n      return res;\n    }, function (error) {\n      delete cache[refId];\n      throw error;\n    });\n  }\n\n  return Promise.resolve(cache[refId]);\n}\n/**\n * Resolves a reference in the given resource.\n * @param obj FHIR Resource\n */\n\n\nfunction resolveRef(obj, path, graph, cache, client, signal) {\n  var node = lib_1.getPath(obj, path);\n\n  if (node) {\n    var isArray = Array.isArray(node);\n    return Promise.all(lib_1.makeArray(node).filter(Boolean).map(function (item, i) {\n      var ref = item.reference;\n\n      if (ref) {\n        return getRef(ref, cache, client, signal).then(function (sub) {\n          if (graph) {\n            if (isArray) {\n              if (path.indexOf(\"..\") > -1) {\n                lib_1.setPath(obj, \"\".concat(path.replace(\"..\", \".\".concat(i, \".\"))), sub);\n              } else {\n                lib_1.setPath(obj, \"\".concat(path, \".\").concat(i), sub);\n              }\n            } else {\n              lib_1.setPath(obj, path, sub);\n            }\n          }\n        }).catch(function (ex) {\n          /* ignore missing references */\n          if (ex.status !== 404) {\n            throw ex;\n          }\n        });\n      }\n    }));\n  }\n}\n/**\n * Given a resource and a list of ref paths - resolves them all\n * @param obj FHIR Resource\n * @param fhirOptions The fhir options of the initiating request call\n * @param cache A map to store fetched refs\n * @param client The client instance\n * @private\n */\n\n\nfunction resolveRefs(obj, fhirOptions, cache, client, signal) {\n  // 1. Sanitize paths, remove any invalid ones\n  var paths = lib_1.makeArray(fhirOptions.resolveReferences).filter(Boolean) // No false, 0, null, undefined or \"\"\n  .map(function (path) {\n    return String(path).trim();\n  }).filter(Boolean); // No space-only strings\n  // 2. Remove duplicates\n\n  paths = paths.filter(function (p, i) {\n    var index = paths.indexOf(p, i + 1);\n\n    if (index > -1) {\n      debug(\"Duplicated reference path \\\"%s\\\"\", p);\n      return false;\n    }\n\n    return true;\n  }); // 3. Early exit if no valid paths are found\n\n  if (!paths.length) {\n    return Promise.resolve();\n  } // 4. Group the paths by depth so that child refs are looked up\n  // after their parents!\n\n\n  var groups = {};\n  paths.forEach(function (path) {\n    var len = path.split(\".\").length;\n\n    if (!groups[len]) {\n      groups[len] = [];\n    }\n\n    groups[len].push(path);\n  }); // 5. Execute groups sequentially! Paths within same group are\n  // fetched in parallel!\n\n  var task = Promise.resolve();\n  Object.keys(groups).sort().forEach(function (len) {\n    var group = groups[len];\n    task = task.then(function () {\n      return Promise.all(group.map(function (path) {\n        return resolveRef(obj, path, !!fhirOptions.graph, cache, client, signal);\n      }));\n    });\n  });\n  return task;\n}\n/**\n * This is a FHIR client that is returned to you from the `ready()` call of the\n * **SMART API**. You can also create it yourself if needed:\n *\n * ```js\n * // BROWSER\n * const client = FHIR.client(\"https://r4.smarthealthit.org\");\n *\n * // SERVER\n * const client = smart(req, res).client(\"https://r4.smarthealthit.org\");\n * ```\n */\n\n\nvar Client = /*#__PURE__*/function () {\n  /**\n   * Validates the parameters, creates an instance and tries to connect it to\n   * FhirJS, if one is available globally.\n   */\n  function Client(environment, state) {\n    var _this = this;\n\n    _classCallCheck(this, Client);\n\n    /**\n     * @category Utility\n     */\n    this.units = lib_1.units;\n\n    var _state = typeof state == \"string\" ? {\n      serverUrl: state\n    } : state; // Valid serverUrl is required!\n\n\n    lib_1.assert(_state.serverUrl && _state.serverUrl.match(/https?:\\/\\/.+/), \"A \\\"serverUrl\\\" option is required and must begin with \\\"http(s)\\\"\");\n    this.state = _state;\n    this.environment = environment;\n    this._refreshTask = null;\n    var client = this; // patient api ---------------------------------------------------------\n\n    this.patient = {\n      get id() {\n        return client.getPatientId();\n      },\n\n      read: function read(requestOptions) {\n        var id = _this.patient.id;\n        return id ? _this.request(Object.assign(Object.assign({}, requestOptions), {\n          url: \"Patient/\".concat(id)\n        })) : Promise.reject(new Error(\"Patient is not available\"));\n      },\n      request: function request(requestOptions) {\n        var fhirOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (_this.patient.id) {\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n            var options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return contextualize(requestOptions, _this);\n\n                  case 2:\n                    options = _context.sent;\n                    return _context.abrupt(\"return\", _this.request(options, fhirOptions));\n\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }))();\n        } else {\n          return Promise.reject(new Error(\"Patient is not available\"));\n        }\n      }\n    }; // encounter api -------------------------------------------------------\n\n    this.encounter = {\n      get id() {\n        return client.getEncounterId();\n      },\n\n      read: function read(requestOptions) {\n        var id = _this.encounter.id;\n        return id ? _this.request(Object.assign(Object.assign({}, requestOptions), {\n          url: \"Encounter/\".concat(id)\n        })) : Promise.reject(new Error(\"Encounter is not available\"));\n      }\n    }; // user api ------------------------------------------------------------\n\n    this.user = {\n      get fhirUser() {\n        return client.getFhirUser();\n      },\n\n      get id() {\n        return client.getUserId();\n      },\n\n      get resourceType() {\n        return client.getUserType();\n      },\n\n      read: function read(requestOptions) {\n        var fhirUser = _this.user.fhirUser;\n        return fhirUser ? _this.request(Object.assign(Object.assign({}, requestOptions), {\n          url: fhirUser\n        })) : Promise.reject(new Error(\"User is not available\"));\n      }\n    }; // fhir.js api (attached automatically in browser)\n    // ---------------------------------------------------------------------\n\n    this.connect(environment.fhir);\n  }\n  /**\n   * This method is used to make the \"link\" between the `fhirclient` and the\n   * `fhir.js`, if one is available.\n   * **Note:** This is called by the constructor. If fhir.js is available in\n   * the global scope as `fhir`, it will automatically be linked to any [[Client]]\n   * instance. You should only use this method to connect to `fhir.js` which\n   * is not global.\n   */\n\n\n  _createClass(Client, [{\n    key: \"connect\",\n    value: function connect(fhirJs) {\n      if (typeof fhirJs == \"function\") {\n        var options = {\n          baseUrl: this.state.serverUrl.replace(/\\/$/, \"\")\n        };\n        var accessToken = this.getState(\"tokenResponse.access_token\");\n\n        if (accessToken) {\n          options.auth = {\n            token: accessToken\n          };\n        } else {\n          var _this$state = this.state,\n              username = _this$state.username,\n              password = _this$state.password;\n\n          if (username && password) {\n            options.auth = {\n              user: username,\n              pass: password\n            };\n          }\n        }\n\n        this.api = fhirJs(options);\n        var patientId = this.getState(\"tokenResponse.patient\");\n\n        if (patientId) {\n          this.patient.api = fhirJs(Object.assign(Object.assign({}, options), {\n            patient: patientId\n          }));\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Returns the ID of the selected patient or null. You should have requested\n     * \"launch/patient\" scope. Otherwise this will return null.\n     */\n\n  }, {\n    key: \"getPatientId\",\n    value: function getPatientId() {\n      var tokenResponse = this.state.tokenResponse;\n\n      if (tokenResponse) {\n        // We have been authorized against this server but we don't know\n        // the patient. This should be a scope issue.\n        if (!tokenResponse.patient) {\n          if (!(this.state.scope || \"\").match(/\\blaunch(\\/patient)?\\b/)) {\n            debug(strings_1.default.noScopeForId, \"patient\", \"patient\");\n          } else {\n            // The server should have returned the patient!\n            debug(\"The ID of the selected patient is not available. Please check if your server supports that.\");\n          }\n\n          return null;\n        }\n\n        return tokenResponse.patient;\n      }\n\n      if (this.state.authorizeUri) {\n        debug(strings_1.default.noIfNoAuth, \"the ID of the selected patient\");\n      } else {\n        debug(strings_1.default.noFreeContext, \"selected patient\");\n      }\n\n      return null;\n    }\n    /**\n     * Returns the ID of the selected encounter or null. You should have\n     * requested \"launch/encounter\" scope. Otherwise this will return null.\n     * Note that not all servers support the \"launch/encounter\" scope so this\n     * will be null if they don't.\n     */\n\n  }, {\n    key: \"getEncounterId\",\n    value: function getEncounterId() {\n      var tokenResponse = this.state.tokenResponse;\n\n      if (tokenResponse) {\n        // We have been authorized against this server but we don't know\n        // the encounter. This should be a scope issue.\n        if (!tokenResponse.encounter) {\n          if (!(this.state.scope || \"\").match(/\\blaunch(\\/encounter)?\\b/)) {\n            debug(strings_1.default.noScopeForId, \"encounter\", \"encounter\");\n          } else {\n            // The server should have returned the encounter!\n            debug(\"The ID of the selected encounter is not available. Please check if your server supports that, and that the selected patient has any recorded encounters.\");\n          }\n\n          return null;\n        }\n\n        return tokenResponse.encounter;\n      }\n\n      if (this.state.authorizeUri) {\n        debug(strings_1.default.noIfNoAuth, \"the ID of the selected encounter\");\n      } else {\n        debug(strings_1.default.noFreeContext, \"selected encounter\");\n      }\n\n      return null;\n    }\n    /**\n     * Returns the (decoded) id_token if any. You need to request \"openid\" and\n     * \"profile\" scopes if you need to receive an id_token (if you need to know\n     * who the logged-in user is).\n     */\n\n  }, {\n    key: \"getIdToken\",\n    value: function getIdToken() {\n      var tokenResponse = this.state.tokenResponse;\n\n      if (tokenResponse) {\n        var idToken = tokenResponse.id_token;\n        var scope = this.state.scope || \"\"; // We have been authorized against this server but we don't have\n        // the id_token. This should be a scope issue.\n\n        if (!idToken) {\n          var hasOpenid = scope.match(/\\bopenid\\b/);\n          var hasProfile = scope.match(/\\bprofile\\b/);\n          var hasFhirUser = scope.match(/\\bfhirUser\\b/);\n\n          if (!hasOpenid || !(hasFhirUser || hasProfile)) {\n            debug(\"You are trying to get the id_token but you are not \" + \"using the right scopes. Please add 'openid' and \" + \"'fhirUser' or 'profile' to the scopes you are \" + \"requesting.\");\n          } else {\n            // The server should have returned the id_token!\n            debug(\"The id_token is not available. Please check if your server supports that.\");\n          }\n\n          return null;\n        }\n\n        return lib_1.jwtDecode(idToken, this.environment);\n      }\n\n      if (this.state.authorizeUri) {\n        debug(strings_1.default.noIfNoAuth, \"the id_token\");\n      } else {\n        debug(strings_1.default.noFreeContext, \"id_token\");\n      }\n\n      return null;\n    }\n    /**\n     * Returns the profile of the logged_in user (if any). This is a string\n     * having the following shape `\"{user type}/{user id}\"`. For example:\n     * `\"Practitioner/abc\"` or `\"Patient/xyz\"`.\n     */\n\n  }, {\n    key: \"getFhirUser\",\n    value: function getFhirUser() {\n      var idToken = this.getIdToken();\n\n      if (idToken) {\n        // Epic may return a full url\n        // @see https://github.com/smart-on-fhir/client-js/issues/105\n        if (idToken.fhirUser) {\n          return idToken.fhirUser.split(\"/\").slice(-2).join(\"/\");\n        }\n\n        return idToken.profile;\n      }\n\n      return null;\n    }\n    /**\n     * Returns the user ID or null.\n     */\n\n  }, {\n    key: \"getUserId\",\n    value: function getUserId() {\n      var profile = this.getFhirUser();\n\n      if (profile) {\n        return profile.split(\"/\")[1];\n      }\n\n      return null;\n    }\n    /**\n     * Returns the type of the logged-in user or null. The result can be\n     * \"Practitioner\", \"Patient\" or \"RelatedPerson\".\n     */\n\n  }, {\n    key: \"getUserType\",\n    value: function getUserType() {\n      var profile = this.getFhirUser();\n\n      if (profile) {\n        return profile.split(\"/\")[0];\n      }\n\n      return null;\n    }\n    /**\n     * Builds and returns the value of the `Authorization` header that can be\n     * sent to the FHIR server\n     */\n\n  }, {\n    key: \"getAuthorizationHeader\",\n    value: function getAuthorizationHeader() {\n      var accessToken = this.getState(\"tokenResponse.access_token\");\n\n      if (accessToken) {\n        return \"Bearer \" + accessToken;\n      }\n\n      var _this$state2 = this.state,\n          username = _this$state2.username,\n          password = _this$state2.password;\n\n      if (username && password) {\n        return \"Basic \" + this.environment.btoa(username + \":\" + password);\n      }\n\n      return null;\n    }\n    /**\n     * Used internally to clear the state of the instance and the state in the\n     * associated storage.\n     */\n\n  }, {\n    key: \"_clearState\",\n    value: function () {\n      var _clearState2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var storage, key;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                storage = this.environment.getStorage();\n                _context2.next = 3;\n                return storage.get(settings_1.SMART_KEY);\n\n              case 3:\n                key = _context2.sent;\n\n                if (!key) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 7;\n                return storage.unset(key);\n\n              case 7:\n                _context2.next = 9;\n                return storage.unset(settings_1.SMART_KEY);\n\n              case 9:\n                this.state.tokenResponse = {};\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _clearState() {\n        return _clearState2.apply(this, arguments);\n      }\n\n      return _clearState;\n    }()\n    /**\n     * Creates a new resource in a server-assigned location\n     * @see http://hl7.org/fhir/http.html#create\n     * @param resource A FHIR resource to be created\n     * @param [requestOptions] Any options to be passed to the fetch call.\n     * Note that `method` and `body` will be ignored.\n     * @category Request\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(resource, requestOptions) {\n      return this.request(Object.assign(Object.assign({}, requestOptions), {\n        url: \"\".concat(resource.resourceType),\n        method: \"POST\",\n        body: JSON.stringify(resource),\n        headers: Object.assign({\n          // TODO: Do we need to alternate with \"application/json+fhir\"?\n          \"Content-Type\": \"application/json\"\n        }, (requestOptions || {}).headers)\n      }));\n    }\n    /**\n     * Creates a new current version for an existing resource or creates an\n     * initial version if no resource already exists for the given id.\n     * @see http://hl7.org/fhir/http.html#update\n     * @param resource A FHIR resource to be updated\n     * @param requestOptions Any options to be passed to the fetch call.\n     * Note that `method` and `body` will be ignored.\n     * @category Request\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(resource, requestOptions) {\n      return this.request(Object.assign(Object.assign({}, requestOptions), {\n        url: \"\".concat(resource.resourceType, \"/\").concat(resource.id),\n        method: \"PUT\",\n        body: JSON.stringify(resource),\n        headers: Object.assign({\n          // TODO: Do we need to alternate with \"application/json+fhir\"?\n          \"Content-Type\": \"application/json\"\n        }, (requestOptions || {}).headers)\n      }));\n    }\n    /**\n     * Removes an existing resource.\n     * @see http://hl7.org/fhir/http.html#delete\n     * @param url Relative URI of the FHIR resource to be deleted\n     * (format: `resourceType/id`)\n     * @param requestOptions Any options (except `method` which will be fixed\n     * to `DELETE`) to be passed to the fetch call.\n     * @category Request\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(url) {\n      var requestOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.request(Object.assign(Object.assign({}, requestOptions), {\n        url: url,\n        method: \"DELETE\"\n      }));\n    }\n    /**\n     * Makes a JSON Patch to the given resource\n     * @see http://hl7.org/fhir/http.html#patch\n     * @param url Relative URI of the FHIR resource to be patched\n     * (format: `resourceType/id`)\n     * @param patch A JSON Patch array to send to the server, For details\n     * see https://datatracker.ietf.org/doc/html/rfc6902\n     * @param requestOptions Any options to be passed to the fetch call,\n     * except for `method`, `url` and `body` which cannot be overridden.\n     * @since 2.4.0\n     * @category Request\n     * @typeParam ResolveType This method would typically resolve with the\n     * patched resource or reject with an OperationOutcome. However, this may\n     * depend on the server implementation or even on the request headers.\n     * For that reason, if the default resolve type (which is\n     * [[fhirclient.FHIR.Resource]]) does not work for you, you can pass\n     * in your own resolve type parameter.\n     */\n\n  }, {\n    key: \"patch\",\n    value: function () {\n      var _patch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url, _patch) {\n        var requestOptions,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                requestOptions = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n                lib_1.assertJsonPatch(_patch);\n                return _context3.abrupt(\"return\", this.request(Object.assign(Object.assign({}, requestOptions), {\n                  url: url,\n                  method: \"PATCH\",\n                  body: JSON.stringify(_patch),\n                  headers: Object.assign({\n                    \"prefer\": \"return=presentation\",\n                    \"content-type\": \"application/json-patch+json; charset=UTF-8\"\n                  }, requestOptions.headers)\n                })));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function patch(_x3, _x4) {\n        return _patch2.apply(this, arguments);\n      }\n\n      return patch;\n    }()\n    /**\n     * @param requestOptions Can be a string URL (relative to the serviceUrl),\n     * or an object which will be passed to fetch()\n     * @param fhirOptions Additional options to control the behavior\n     * @param _resolvedRefs DO NOT USE! Used internally.\n     * @category Request\n     */\n\n  }, {\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(requestOptions) {\n        var _this2 = this;\n\n        var fhirOptions,\n            _resolvedRefs,\n            _a,\n            debugRequest,\n            url,\n            options,\n            signal,\n            job,\n            response,\n            _args7 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                fhirOptions = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                _resolvedRefs = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};\n                debugRequest = lib_1.debug.extend(\"client:request\");\n                lib_1.assert(requestOptions, \"request requires an url or request options as argument\"); // url -----------------------------------------------------------------\n\n                if (typeof requestOptions == \"string\" || requestOptions instanceof URL) {\n                  url = String(requestOptions);\n                  requestOptions = {};\n                } else {\n                  url = String(requestOptions.url);\n                }\n\n                url = lib_1.absolute(url, this.state.serverUrl);\n                options = {\n                  graph: fhirOptions.graph !== false,\n                  flat: !!fhirOptions.flat,\n                  pageLimit: (_a = fhirOptions.pageLimit) !== null && _a !== void 0 ? _a : 1,\n                  resolveReferences: fhirOptions.resolveReferences || [],\n                  useRefreshToken: fhirOptions.useRefreshToken !== false,\n                  onPage: typeof fhirOptions.onPage == \"function\" ? fhirOptions.onPage : undefined\n                };\n                signal = requestOptions.signal || undefined; // Refresh the access token if needed\n\n                job = options.useRefreshToken ? this.refreshIfNeeded({\n                  signal: signal\n                }).then(function () {\n                  return requestOptions;\n                }) : Promise.resolve(requestOptions);\n                return _context7.abrupt(\"return\", job // Add the Authorization header now, after the access token might\n                // have been updated\n                .then(function (requestOptions) {\n                  var authHeader = _this2.getAuthorizationHeader();\n\n                  if (authHeader) {\n                    requestOptions.headers = Object.assign(Object.assign({}, requestOptions.headers), {\n                      Authorization: authHeader\n                    });\n                  }\n\n                  return requestOptions;\n                }) // Make the request\n                .then(function (requestOptions) {\n                  debugRequest(\"%s, options: %O, fhirOptions: %O\", url, requestOptions, options);\n                  return lib_1.request(url, requestOptions).then(function (result) {\n                    if (requestOptions.includeResponse) {\n                      response = result.response;\n                      return result.body;\n                    }\n\n                    return result;\n                  });\n                }) // Handle 401 ------------------------------------------------------\n                .catch( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(error) {\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            if (!(error.status == 401)) {\n                              _context4.next = 15;\n                              break;\n                            }\n\n                            if (_this2.getState(\"tokenResponse.access_token\")) {\n                              _context4.next = 4;\n                              break;\n                            }\n\n                            error.message += \"\\nThis app cannot be accessed directly. Please launch it as SMART app!\";\n                            throw error;\n\n                          case 4:\n                            if (options.useRefreshToken) {\n                              _context4.next = 10;\n                              break;\n                            }\n\n                            debugRequest(\"Your session has expired and the useRefreshToken option is set to false. Please re-launch the app.\");\n                            _context4.next = 8;\n                            return _this2._clearState();\n\n                          case 8:\n                            error.message += \"\\n\" + strings_1.default.expired;\n                            throw error;\n\n                          case 10:\n                            // In rare cases we may have a valid access token and a refresh\n                            // token and the request might still fail with 401 just because\n                            // the access token has just been revoked.\n                            // otherwise -> auto-refresh failed. Session expired.\n                            // Need to re-launch. Clear state to start over!\n                            debugRequest(\"Auto-refresh failed! Please re-launch the app.\");\n                            _context4.next = 13;\n                            return _this2._clearState();\n\n                          case 13:\n                            error.message += \"\\n\" + strings_1.default.expired;\n                            throw error;\n\n                          case 15:\n                            throw error;\n\n                          case 16:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function (_x6) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()) // Handle 403 ------------------------------------------------------\n                .catch(function (error) {\n                  if (error.status == 403) {\n                    debugRequest(\"Permission denied! Please make sure that you have requested the proper scopes.\");\n                  }\n\n                  throw error;\n                }).then(function (data) {\n                  // At this point we don't know what `data` actually is!\n                  // We might gen an empty or falsy result. If so return it as is\n                  if (!data) return data; // Handle raw responses\n\n                  // Handle raw responses\n                  if (typeof data == \"string\" || data instanceof Response) return data; // Resolve References ------------------------------------------\n\n                  // Resolve References ------------------------------------------\n                  return function () {\n                    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_data) {\n                      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                        while (1) {\n                          switch (_context5.prev = _context5.next) {\n                            case 0:\n                              if (!(_data.resourceType == \"Bundle\")) {\n                                _context5.next = 5;\n                                break;\n                              }\n\n                              _context5.next = 3;\n                              return Promise.all((_data.entry || []).map(function (item) {\n                                return resolveRefs(item.resource, options, _resolvedRefs, _this2, signal);\n                              }));\n\n                            case 3:\n                              _context5.next = 7;\n                              break;\n\n                            case 5:\n                              _context5.next = 7;\n                              return resolveRefs(_data, options, _resolvedRefs, _this2, signal);\n\n                            case 7:\n                              return _context5.abrupt(\"return\", _data);\n\n                            case 8:\n                            case \"end\":\n                              return _context5.stop();\n                          }\n                        }\n                      }, _callee5);\n                    }));\n\n                    return function (_x7) {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }()(data) // Pagination ----------------------------------------------\n                  .then( /*#__PURE__*/function () {\n                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_data) {\n                      var links, next, nextPage;\n                      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                        while (1) {\n                          switch (_context6.prev = _context6.next) {\n                            case 0:\n                              if (!(_data && _data.resourceType == \"Bundle\")) {\n                                _context6.next = 19;\n                                break;\n                              }\n\n                              links = _data.link || [];\n\n                              if (options.flat) {\n                                _data = (_data.entry || []).map(function (entry) {\n                                  return entry.resource;\n                                });\n                              }\n\n                              if (!options.onPage) {\n                                _context6.next = 6;\n                                break;\n                              }\n\n                              _context6.next = 6;\n                              return options.onPage(_data, Object.assign({}, _resolvedRefs));\n\n                            case 6:\n                              if (! --options.pageLimit) {\n                                _context6.next = 19;\n                                break;\n                              }\n\n                              next = links.find(function (l) {\n                                return l.relation == \"next\";\n                              });\n                              _data = lib_1.makeArray(_data);\n\n                              if (!(next && next.url)) {\n                                _context6.next = 19;\n                                break;\n                              }\n\n                              _context6.next = 12;\n                              return _this2.request({\n                                url: next.url,\n                                // Aborting the main request (even after it is complete)\n                                // must propagate to any child requests and abort them!\n                                // To do so, just pass the same AbortSignal if one is\n                                // provided.\n                                signal: signal\n                              }, options, _resolvedRefs);\n\n                            case 12:\n                              nextPage = _context6.sent;\n\n                              if (!options.onPage) {\n                                _context6.next = 15;\n                                break;\n                              }\n\n                              return _context6.abrupt(\"return\", null);\n\n                            case 15:\n                              if (!options.resolveReferences.length) {\n                                _context6.next = 18;\n                                break;\n                              }\n\n                              Object.assign(_resolvedRefs, nextPage.references);\n                              return _context6.abrupt(\"return\", _data.concat(lib_1.makeArray(nextPage.data || nextPage)));\n\n                            case 18:\n                              return _context6.abrupt(\"return\", _data.concat(lib_1.makeArray(nextPage)));\n\n                            case 19:\n                              return _context6.abrupt(\"return\", _data);\n\n                            case 20:\n                            case \"end\":\n                              return _context6.stop();\n                          }\n                        }\n                      }, _callee6);\n                    }));\n\n                    return function (_x8) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }()) // Finalize ------------------------------------------------\n                  .then(function (_data) {\n                    if (options.graph) {\n                      _resolvedRefs = {};\n                    } else if (!options.onPage && options.resolveReferences.length) {\n                      return {\n                        data: _data,\n                        references: _resolvedRefs\n                      };\n                    }\n\n                    return _data;\n                  }).then(function (_data) {\n                    if (requestOptions.includeResponse) {\n                      return {\n                        body: _data,\n                        response: response\n                      };\n                    }\n\n                    return _data;\n                  });\n                }));\n\n              case 10:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function request(_x5) {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n    /**\n     * Checks if access token and refresh token are present. If they are, and if\n     * the access token is expired or is about to expire in the next 10 seconds,\n     * calls `this.refresh()` to obtain new access token.\n     * @param requestOptions Any options to pass to the fetch call. Most of them\n     * will be overridden, bit it might still be useful for passing additional\n     * request options or an abort signal.\n     * @category Request\n     */\n\n  }, {\n    key: \"refreshIfNeeded\",\n    value: function refreshIfNeeded() {\n      var requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var accessToken = this.getState(\"tokenResponse.access_token\");\n      var refreshToken = this.getState(\"tokenResponse.refresh_token\");\n      var expiresAt = this.state.expiresAt || 0;\n\n      if (accessToken && refreshToken && expiresAt - 10 < Date.now() / 1000) {\n        return this.refresh(requestOptions);\n      }\n\n      return Promise.resolve(this.state);\n    }\n    /**\n     * Use the refresh token to obtain new access token. If the refresh token is\n     * expired (or this fails for any other reason) it will be deleted from the\n     * state, so that we don't enter into loops trying to re-authorize.\n     *\n     * This method is typically called internally from [[Client.request]] if\n     * certain request fails with 401.\n     *\n     * @param requestOptions Any options to pass to the fetch call. Most of them\n     * will be overridden, bit it might still be useful for passing additional\n     * request options or an abort signal.\n     * @category Request\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n\n      var requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _a, _b;\n\n      var debugRefresh = lib_1.debug.extend(\"client:refresh\");\n      debugRefresh(\"Attempting to refresh with refresh_token...\");\n      var refreshToken = (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a.tokenResponse) === null || _b === void 0 ? void 0 : _b.refresh_token;\n      lib_1.assert(refreshToken, \"Unable to refresh. No refresh_token found.\");\n      var tokenUri = this.state.tokenUri;\n      lib_1.assert(tokenUri, \"Unable to refresh. No tokenUri found.\");\n      var scopes = this.getState(\"tokenResponse.scope\") || \"\";\n      var hasOfflineAccess = scopes.search(/\\boffline_access\\b/) > -1;\n      var hasOnlineAccess = scopes.search(/\\bonline_access\\b/) > -1;\n      lib_1.assert(hasOfflineAccess || hasOnlineAccess, \"Unable to refresh. No offline_access or online_access scope found.\"); // This method is typically called internally from `request` if certain\n      // request fails with 401. However, clients will often run multiple\n      // requests in parallel which may result in multiple refresh calls.\n      // To avoid that, we keep a reference to the current refresh task (if any).\n\n      if (!this._refreshTask) {\n        var refreshRequestOptions = Object.assign(Object.assign({\n          credentials: this.environment.options.refreshTokenWithCredentials || \"same-origin\"\n        }, requestOptions), {\n          method: \"POST\",\n          mode: \"cors\",\n          headers: Object.assign(Object.assign({}, requestOptions.headers || {}), {\n            \"content-type\": \"application/x-www-form-urlencoded\"\n          }),\n          body: \"grant_type=refresh_token&refresh_token=\".concat(encodeURIComponent(refreshToken))\n        }); // custom authorization header can be passed on manual calls\n\n        if (!(\"authorization\" in refreshRequestOptions.headers)) {\n          var _this$state3 = this.state,\n              clientSecret = _this$state3.clientSecret,\n              clientId = _this$state3.clientId;\n\n          if (clientSecret) {\n            // @ts-ignore\n            refreshRequestOptions.headers.authorization = \"Basic \" + this.environment.btoa(clientId + \":\" + clientSecret);\n          }\n        }\n\n        this._refreshTask = lib_1.request(tokenUri, refreshRequestOptions).then(function (data) {\n          lib_1.assert(data.access_token, \"No access token received\");\n          debugRefresh(\"Received new access token response %O\", data);\n          Object.assign(_this3.state.tokenResponse, data);\n          _this3.state.expiresAt = lib_1.getAccessTokenExpiration(data, _this3.environment);\n          return _this3.state;\n        }).catch(function (error) {\n          var _a, _b;\n\n          if ((_b = (_a = _this3.state) === null || _a === void 0 ? void 0 : _a.tokenResponse) === null || _b === void 0 ? void 0 : _b.refresh_token) {\n            debugRefresh(\"Deleting the expired or invalid refresh token.\");\n            delete _this3.state.tokenResponse.refresh_token;\n          }\n\n          throw error;\n        }).finally(function () {\n          _this3._refreshTask = null;\n          var key = _this3.state.key;\n\n          if (key) {\n            _this3.environment.getStorage().set(key, _this3.state);\n          } else {\n            debugRefresh(\"No 'key' found in Clint.state. Cannot persist the instance.\");\n          }\n        });\n      }\n\n      return this._refreshTask;\n    } // utils -------------------------------------------------------------------\n\n    /**\n     * Groups the observations by code. Returns a map that will look like:\n     * ```js\n     * const map = client.byCodes(observations, \"code\");\n     * // map = {\n     * //     \"55284-4\": [ observation1, observation2 ],\n     * //     \"6082-2\": [ observation3 ]\n     * // }\n     * ```\n     * @param observations Array of observations\n     * @param property The name of a CodeableConcept property to group by\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n\n  }, {\n    key: \"byCode\",\n    value: function byCode(observations, property) {\n      return lib_1.byCode(observations, property);\n    }\n    /**\n     * First groups the observations by code using `byCode`. Then returns a function\n     * that accepts codes as arguments and will return a flat array of observations\n     * having that codes. Example:\n     * ```js\n     * const filter = client.byCodes(observations, \"category\");\n     * filter(\"laboratory\") // => [ observation1, observation2 ]\n     * filter(\"vital-signs\") // => [ observation3 ]\n     * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n     * ```\n     * @param observations Array of observations\n     * @param property The name of a CodeableConcept property to group by\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n\n  }, {\n    key: \"byCodes\",\n    value: function byCodes(observations, property) {\n      return lib_1.byCodes(observations, property);\n    }\n    /**\n     * Walks through an object (or array) and returns the value found at the\n     * provided path. This function is very simple so it intentionally does not\n     * support any argument polymorphism, meaning that the path can only be a\n     * dot-separated string. If the path is invalid returns undefined.\n     * @param obj The object (or Array) to walk through\n     * @param path The path (eg. \"a.b.4.c\")\n     * @returns {*} Whatever is found in the path or undefined\n     * @todo This should be deprecated and moved elsewhere. One should not have\n     * to obtain an instance of [[Client]] just to use utility functions like this.\n     * @deprecated\n     * @category Utility\n     */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath(obj) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      return lib_1.getPath(obj, path);\n    }\n    /**\n     * Returns a copy of the client state. Accepts a dot-separated path argument\n     * (same as for `getPath`) to allow for selecting specific properties.\n     * Examples:\n     * ```js\n     * client.getState(); // -> the entire state object\n     * client.getState(\"serverUrl\"); // -> the URL we are connected to\n     * client.getState(\"tokenResponse.patient\"); // -> The selected patient ID (if any)\n     * ```\n     * @param path The path (eg. \"a.b.4.c\")\n     * @returns {*} Whatever is found in the path or undefined\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      return lib_1.getPath(Object.assign({}, this.state), path);\n    }\n    /**\n     * Returns a promise that will be resolved with the fhir version as defined\n     * in the CapabilityStatement.\n     */\n\n  }, {\n    key: \"getFhirVersion\",\n    value: function getFhirVersion() {\n      return lib_1.fetchConformanceStatement(this.state.serverUrl).then(function (metadata) {\n        return metadata.fhirVersion;\n      });\n    }\n    /**\n     * Returns a promise that will be resolved with the numeric fhir version\n     * - 2 for DSTU2\n     * - 3 for STU3\n     * - 4 for R4\n     * - 0 if the version is not known\n     */\n\n  }, {\n    key: \"getFhirRelease\",\n    value: function getFhirRelease() {\n      return this.getFhirVersion().then(function (v) {\n        var _a;\n\n        return (_a = settings_1.fhirVersions[v]) !== null && _a !== void 0 ? _a : 0;\n      });\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.default = Client;","map":null,"metadata":{},"sourceType":"script"}