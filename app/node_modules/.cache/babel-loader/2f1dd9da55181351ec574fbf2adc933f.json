{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\n\nvar _classCallCheck = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _templateObject;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnitString = void 0;\n\nvar intUtils_ = _interopRequireWildcard(require(\"./ucumInternalUtils.js\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * This class handles the parsing of a unit string into a unit object\n */\n\n\nvar Ucum = require('./config.js').Ucum;\n\nvar Unit = require('./unit.js').Unit;\n\nvar UnitTables = require('./unitTables.js').UnitTables;\n\nvar PrefixTables = require('./prefixTables.js').PrefixTables;\n\nvar UnitString = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   */\n  function UnitString() {\n    _classCallCheck(this, UnitString);\n\n    // Get instances of the unit and prefix tables and the utilities\n    this.utabs_ = UnitTables.getInstance();\n    this.pfxTabs_ = PrefixTables.getInstance(); // Set emphasis characters to defaults.  These are used to emphasize\n    // certain characters or strings in user messages.  They can be reset in\n    // the useHTMLInMessages method.\n\n    this.openEmph_ = Ucum.openEmph_;\n    this.closeEmph_ = Ucum.closeEmph_; // Set the braces message to blank.  This message is displayed for each\n    // validation request on the web page, but is included separately as\n    // a note on the validation spreadsheet.  The useBraceMsgForEachString\n    // method should be used to set the message to be displayed for each\n    // unit string.\n\n    this.bracesMsg_ = ''; // Set the flags used, with indices, as place holders in unit strings\n    // for parenthetical strings and strings within braces.\n\n    this.parensFlag_ = \"parens_placeholder\"; // in lieu of Jehoshaphat\n\n    this.pFlagLen_ = this.parensFlag_.length;\n    this.braceFlag_ = \"braces_placeholder\"; // in lieu of Nebuchadnezzar\n\n    this.bFlagLen_ = this.braceFlag_.length; // Initialize the message start/end strings, which will be set when\n    // parseString is called.\n\n    this.vcMsgStart_ = null;\n    this.vcMsgEnd_ = null; // Arrays used by multiple methods within this class to hold persistent\n    // data.  Just gets too bulky to pass these guys around.\n    // Messages to be returned to the calling function\n\n    this.retMsg_ = []; // Units for parenthetical unit strings\n\n    this.parensUnits_ = []; // annotation text for annotations found in unit strings\n\n    this.annotations_ = []; // suggestions for unit strings that for which no unit was found\n\n    this.suggestions = [];\n  } // end constructor\n\n  /**\n   * Sets the emphasis strings to the HTML used in the webpage display - or\n   * blanks them out, depending on the use parameter.\n   *\n   * @param use flag indicating whether or not to use the html message format;\n   *  defaults to true\n   */\n\n\n  _createClass(UnitString, [{\n    key: \"useHTMLInMessages\",\n    value: function useHTMLInMessages(use) {\n      if (use === undefined || use) {\n        this.openEmph_ = Ucum.openEmphHTML_;\n        this.closeEmph_ = Ucum.closeEmphHTML_;\n      } else {\n        this.openEmph_ = Ucum.openEmph_;\n        this.closeEmph_ = Ucum.closeEmph_;\n      }\n    } // end useHTMLInMessages\n\n    /**\n     * Sets the braces message to be displayed for each unit string validation\n     * requested, as appropriate.\n     *\n     * @param use flag indicating whether or not to use the braces message;\n     *  defaults to true\n     */\n\n  }, {\n    key: \"useBraceMsgForEachString\",\n    value: function useBraceMsgForEachString(use) {\n      if (use === undefined || use) this.bracesMsg_ = Ucum.bracesMsg_;else this.bracesMsg_ = '';\n    }\n    /**\n     * Parses a unit string, returns a unit, a possibly updated version of\n     * the string passed in, and messages and suggestions where appropriate.\n     *\n     * The string returned may be updated if the input string contained unit\n     * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n     * the string returned, a the returned messages array includes a note\n     * explaining the substitution.\n     *\n     * @param uStr the string defining the unit\n     * @param valConv indicates what type of request this is for - a request to\n     *  validate (pass in 'validate') or a request to convert (pass in 'convert');\n     *  optional, defaults to 'validate'\n     * @param suggest a boolean to indicate whether or not suggestions are\n     *  requested for a string that cannot be resolved to a valid unit;\n     *  true indicates suggestions are wanted; false indicates they are not,\n     *  and is the default if the parameter is not specified;\n     * @returns an array containing:\n     *   the unit object or null if a unit could not be created.  In cases where\n     *     a fix was found for a problem string, .e.g., 2.mg for 2mg, a unit will\n     *     be returned but an error message will also be returned, describing\n     *     the substitution;\n     *   the possibly updated unit string passed in;\n     *   an array of any user messages (informational, error or warning)\n     *     generated (or an empty array); and\n     *   a suggestions array of hash objects (1 or more).  Each hash contains\n     *   three elements:\n     *     'msg' which is a message indicating what unit expression the\n     *       suggestions are for;\n     *     'invalidUnit' which is the unit expression the suggestions are\n     *       for; and\n     *     'units' which is an array of data for each suggested unit found.\n     *        Each array will contain the unit code, the unit name and the\n     *        unit guidance (if any).\n     *   The return array will not contain a suggestions array if a valid unit\n     *   was found or if suggestions were not requested.\n     * @throws an error if nothing was specified.\n     */\n\n  }, {\n    key: \"parseString\",\n    value: function parseString(uStr, valConv, suggest) {\n      uStr = uStr.trim(); // Make sure we have something to work with\n\n      if (uStr === '' || uStr === null) {\n        throw new Error('Please specify a unit expression to be validated.');\n      }\n\n      if (valConv === 'validate') {\n        this.vcMsgStart_ = Ucum.valMsgStart_;\n        this.vcMsgEnd_ = Ucum.valMsgEnd_;\n      } else {\n        this.vcMsgStart_ = Ucum.cnvMsgStart_;\n        this.vcMsgEnd_ = Ucum.cnvMsgEnd_;\n      }\n\n      if (suggest === undefined || suggest === false) {\n        this.suggestions_ = null;\n      } else {\n        this.suggestions_ = [];\n      }\n\n      this.retMsg_ = [];\n      this.parensUnits_ = [];\n      this.annotations_ = [];\n      var origString = uStr;\n      var retObj = []; // Extract any annotations, i.e., text enclosed in braces ({}) from the\n      // string before further processing.  Store each one in this.annotations_\n      // array and put a placeholder in the string for the annotation.  Do\n      // this before other processing in case an annotation contains characters\n      // that will be interpreted as parenthetical markers or operators in\n      // subsequent processing.\n\n      uStr = this._getAnnotations(uStr);\n\n      if (this.retMsg_.length > 0) {\n        retObj[0] = null;\n        retObj[1] = null;\n      } else {\n        // Flag used to block further processing on an unrecoverable error\n        var endProcessing = this.retMsg_.length > 0; // First check for one of the \"special\" units.  If it's one of those, put\n        // in a substitution phrase for it to avoid having it separated on its\n        // embedded operator.  This will only happen, by the way, if it is\n        // preceded by a prefix or followed by an operator and another unit.\n\n        var sUnit = null;\n\n        for (sUnit in Ucum.specUnits_) {\n          while (uStr.indexOf(sUnit) !== -1) {\n            uStr = uStr.replace(sUnit, Ucum.specUnits_[sUnit]);\n          }\n        } // Check for spaces and throw an error if any are found.  The spec\n        // explicitly forbids spaces except in annotations, which is why any\n        // annotations are extracted before this check is made.\n\n\n        if (uStr.indexOf(' ') > -1) {\n          throw new Error('Blank spaces are not allowed in unit expressions.');\n        } // end if blanks were found in the string\n        // assign the array returned to retObj.  It will contain 2 elements:\n        //  the unit returned in position 0; and the origString (possibly\n        //  modified in position 1.  The origString in position 1 will not\n        //  be changed by subsequent processing.\n\n\n        retObj = this._parseTheString(uStr, origString);\n        var finalUnit = retObj[0]; // Do a final check to make sure that finalUnit is a unit and not\n        // just a number.  Something like \"8/{HCP}\" will return a \"unit\" of 8\n        // - which is not a unit.  Hm - evidently it is.  So just create a unit\n        // object for it.\n\n        if (intUtils_.isIntegerUnit(finalUnit) || typeof finalUnit === 'number') {\n          finalUnit = new Unit({\n            'csCode_': origString,\n            'magnitude_': finalUnit,\n            'name_': origString\n          });\n          retObj[0] = finalUnit;\n        } // end final check\n\n      } // end if no annotation errors were found\n\n\n      retObj[2] = this.retMsg_;\n      if (this.suggestions_ && this.suggestions_.length > 0) retObj[3] = this.suggestions_;\n      return retObj;\n    } // end parseString\n\n    /**\n     * Parses a unit string, returns a unit, a possibly updated version of\n     * the string passed in, and messages where appropriate.  This should\n     * only be called from within this class (or by test code).\n     *\n     * The string returned may be updated if the input string contained unit\n     * names, e.g., \"pound\".  The unit code ([lb_av] for pound) is placed in\n     * the string returned, a the returned messages array includes a note\n     * explaining the substitution.\n     *\n     * @param uStr the string defining the unit\n     * @param origString the original unit string passed in\n     *\n     * @returns\n     *  an array containing:\n     *    the unit object (or null if there were problems creating the unit); and\n     *    the possibly updated unit string passed in.\n     *\n     * the this.retMsg_ array will be updated with any user messages\n     *   (informational, error or warning) generated by this or called methods\n     * the this.parensUnits_ array is referenced and possibly populated by\n     *   methods called within this one\n     * the this.annotations_ array is referenced by methods called within\n     *   this one\n     * the this.suggestions_ array may be populated by methods called within\n     *   this one\n     */\n\n  }, {\n    key: \"_parseTheString\",\n    value: function _parseTheString(uStr, origString) {\n      // Unit to be returned\n      var finalUnit = null; // Flag used to block further processing on an unrecoverable error\n\n      var endProcessing = this.retMsg_.length > 0; // Call _processParens to search for and process any/all parenthetical\n      // strings in uStr.  Units created for parenthetical strings will be\n      // stored in the this.parensUnits_ array.\n\n      var parensResp = this._processParens(uStr, origString);\n\n      endProcessing = parensResp[2]; // The array used to hold the units and their operators.\n\n      var uArray = []; // Continue if we didn't hit a problem\n\n      if (!endProcessing) {\n        uStr = parensResp[0];\n        origString = parensResp[1]; // Call _makeUnitsArray to convert the string to an array of unit\n        // descriptors with operators.\n\n        var mkUArray = this._makeUnitsArray(uStr, origString);\n\n        endProcessing = mkUArray[2];\n\n        if (!endProcessing) {\n          uArray = mkUArray[0];\n          origString = mkUArray[1]; // Create a unit object out of each un element\n\n          var uLen = uArray.length;\n\n          for (var u1 = 0; u1 < uLen; u1++) {\n            //for (let u1 = 0; u1 < uLen && !endProcessing; u1++) {\n            var curCode = uArray[u1]['un']; // Determine the type of the \"un\" attribute of the current array element\n            // Check to see if it's a number.  If so write the number version of\n            // the number back to the \"un\" attribute and move on\n\n            if (intUtils_.isIntegerUnit(curCode)) {\n              uArray[u1]['un'] = Number(curCode);\n            } else {\n              // The current unit array element is a string.  Check now to see\n              // if it is or contains a parenthesized unit from this.parensUnits_.\n              // If so, call _getParens to process the string and get the unit.\n              if (curCode.indexOf(this.parensFlag_) >= 0) {\n                var parenUnit = this._getParensUnit(curCode, origString); // if we couldn't process the string, set the end flag and bypass\n                // further processing.\n\n\n                if (!endProcessing) endProcessing = parenUnit[1]; // If we're good, put the unit in the uArray and replace the\n                // curCode, which contains the parentheses placeholders, etc.,\n                // with the unit's code - including any substitutions.\n\n                if (!endProcessing) {\n                  uArray[u1]['un'] = parenUnit[0];\n                }\n              } // end if the curCode contains a parenthesized unit\n              // Else it's not a parenthetical unit and not a number. Call\n              // _makeUnit to create a unit for it.\n              else {\n                var uRet = this._makeUnit(curCode, origString); // If we didn't get a unit, set the endProcessing flag.\n\n\n                if (uRet[0] === null) {\n                  endProcessing = true;\n                } else {\n                  uArray[u1]['un'] = uRet[0];\n                  origString = uRet[1];\n                }\n              } // end if the curCode is not a parenthetical expression\n\n            } // end if the \"un\" array is a not a number\n\n          } // end do for each element in the units array\n\n        } // end if _makeUnitsArray did not return an error\n\n      } // end if _processParens did not find an error that causes a stop\n      // If we're still good, continue\n\n\n      if (!endProcessing) {\n        // Process the units (and numbers) to create one final unit object\n        if ((uArray[0] === null || uArray[0] === ' ' || uArray[0]['un'] === undefined || uArray[0]['un'] === null) && this.retMsg_.length === 0) {\n          // not sure what this might be, but this is a safeguard\n          this.retMsg_.push(\"Unit string (\".concat(origString, \") did not contain \") + \"anything that could be used to create a unit, or else something \" + \"that is not handled yet by this package.  Sorry\");\n          endProcessing = true;\n        }\n      }\n\n      if (!endProcessing) {\n        finalUnit = this._performUnitArithmetic(uArray, origString);\n      }\n\n      return [finalUnit, origString];\n    } // end _parseTheString\n\n    /**\n     * Extracts all annotations from a unit string, replacing them with\n     * placeholders for later evaluation.  The annotations are stored in the\n     * this.annotations_ array.  This should only be called from within this\n     * class (or by test code).\n     *\n     * @param uString the unit string being parsed\n     * @returns the string after the annotations are replaced with placeholders\n     *\n     * the this.retMsg_ array will be updated with any user messages\n     *   (informational, error or warning) generated by this or called methods\n     * the this.annotations_ array is populated by this method\n     */\n\n  }, {\n    key: \"_getAnnotations\",\n    value: function _getAnnotations(uString) {\n      var openBrace = uString.indexOf('{');\n\n      while (openBrace >= 0) {\n        var _closeBrace = uString.indexOf('}');\n\n        if (_closeBrace < 0) {\n          this.retMsg_.push('Missing closing brace for annotation starting at ' + this.openEmph_ + uString.substr(openBrace) + this.closeEmph_);\n          openBrace = -1;\n        } else {\n          var braceStr = uString.substring(openBrace, _closeBrace + 1);\n          var aIdx = this.annotations_.length.toString();\n          uString = uString.replace(braceStr, this.braceFlag_ + aIdx + this.braceFlag_);\n          this.annotations_.push(braceStr);\n          openBrace = uString.indexOf('{');\n        }\n      } // end do while we have an opening brace\n      // check for a stray/unmatched closing brace\n\n\n      var closeBrace = uString.indexOf('}');\n      if (closeBrace >= 0) this.retMsg_.push('Missing opening brace for closing brace found at ' + this.openEmph_ + uString.substring(0, closeBrace + 1) + this.closeEmph_);\n      return uString;\n    } // end _getAnnotations\n\n    /**\n     * Finds and processes any/all parenthesized unit strings. This should only\n     * be called from within this class (or by test code).\n     *\n     * Nested parenthesized strings are processed from the inside out.  The\n     * parseString function is called from within this one for each parenthesized\n     * unit string, and the resulting unit object is stored in this.parensUnits_,\n     * to be processed after all strings are translated to units.\n     *\n     * A placeholder is placed in the unit string returned to indicate that the\n     * unit object should be obtained from the this.parensUnits_ array.  The\n     * placeholder consists of the parenthesis flag (this.parensFlag_) followed\n     * by the index of the unit in this.parensUnits_ followed by this.parensFlag_.\n     *\n     * @param uString the unit string being parsed, where this will be the full\n     *  string the first time this is called and parenthesized strings on any\n     *  subsequent calls\n     * @param origString the original string first passed in to parseString\n     * @returns\n     *  an array containing:\n     *   the string after the parentheses are replaced;\n     *   the original string; and\n     *   a boolean flag indicating whether or not an error occurred that\n     *     should stop processing.\n     *\n     * the this.retMsg_ array will be updated with any user messages\n     *   (informational, error or warning) generated by this or called methods\n     * this this.parensUnits_ array will be populated with units found for\n     *   parenthetical unit strings\n     */\n\n  }, {\n    key: \"_processParens\",\n    value: function _processParens(uString, origString) {\n      // Unit strings array and index\n      var uStrArray = [];\n      var uStrAryPos = 0;\n      var stopProcessing = false;\n      var pu = this.parensUnits_.length; // Count of characters trimmed off the beginning of the unit string (uString)\n      // as units are removed from it; used for error messages to provide\n      // context.\n\n      var trimmedCt = 0; // Break the unit string into pieces that consist of text outside of\n      // parenthetical strings and placeholders for the parenthetical units.\n      // This method is called recursively for parenthetical strings and the units\n      // returned are stored in the this.parensUnits_ array.\n\n      while (uString !== \"\" && !stopProcessing) {\n        var openCt = 0;\n        var closeCt = 0;\n        var openPos = uString.indexOf('('); // If an opening parenthesis was not found, check for an unmatched\n        // close parenthesis.  If one was found report the error and end\n        // processing.\n\n        if (openPos < 0) {\n          var closePos = uString.indexOf(')');\n\n          if (closePos >= 0) {\n            var theMsg = \"Missing open parenthesis for close \" + \"parenthesis at \".concat(uString.substring(0, closePos + trimmedCt)) + \"\".concat(this.openEmph_).concat(uString.substr(closePos, 1)).concat(this.closeEmph_);\n\n            if (closePos < uString.length - 1) {\n              theMsg += \"\".concat(uString.substr(closePos + 1));\n            }\n\n            this.retMsg_.push(theMsg);\n            uStrArray[uStrAryPos] = uString;\n            stopProcessing = true;\n          } // end if a close parenthesis was found\n          // If no parentheses were found in the current unit string, transfer\n          // it to the units array and blank out the string, which will end\n          // the search for parenthetical units.\n          else {\n            uStrArray[uStrAryPos] = uString;\n            uString = \"\";\n          } // end if no close parenthesis was found\n\n        } // end if no open parenthesis was found\n        // Otherwise an open parenthesis was found. Process the string that\n        // includes the parenthetical group\n        else {\n          openCt += 1; // Write the text before the parentheses (if any) to the unit strings array\n\n          var uLen = uString.length;\n\n          if (openPos > 0) {\n            uStrArray[uStrAryPos++] = uString.substr(0, openPos);\n          } // Find the matching closePos, i.e., the one that closes the\n          // parenthetical group that this one opens.  Look also for\n          // another open parenthesis, in case this includes nested parenthetical\n          // strings.  This continues until it finds the same number of close\n          // parentheses as open parentheses, or runs out of string to check.\n          // In the case of nested parentheses this will identify the outer set\n          // of parentheses.\n\n\n          var _closePos = 0;\n          var c = openPos + 1;\n\n          for (; c < uLen && openCt != closeCt; c++) {\n            if (uString[c] === '(') openCt += 1;else if (uString[c] === ')') closeCt += 1;\n          } // Put a placeholder for the group in the unit strings array and recursively\n          // call this method for the parenthetical group.  Put the unit returned\n          // in this.parensUnits_.  Set the unit string to whatever follows\n          // the position of the closing parenthesis for this group, to be\n          // processed by the next iteration of this loop.  If there's nothing\n          // left uString is set to \"\".\n\n\n          if (openCt === closeCt) {\n            _closePos = c;\n            uStrArray[uStrAryPos++] = this.parensFlag_ + pu.toString() + this.parensFlag_;\n\n            var parseResp = this._parseTheString(uString.substring(openPos + 1, _closePos - 1), origString);\n\n            if (parseResp[0] === null) stopProcessing = true;else {\n              origString = parseResp[1];\n              this.parensUnits_[pu++] = parseResp[0];\n              uString = uString.substr(_closePos);\n              trimmedCt = _closePos;\n            }\n          } // end if the number of open and close parentheses matched\n          // If the number of open and close parentheses doesn't match, indicate\n          // an error.\n          else {\n            uStrArray.push(origString.substr(openPos));\n            this.retMsg_.push(\"Missing close parenthesis for open parenthesis at \" + \"\".concat(origString.substring(0, openPos + trimmedCt)) + \"\".concat(this.openEmph_).concat(origString.substr(openPos, 1)) + \"\".concat(this.closeEmph_).concat(origString.substr(openPos + 1)));\n            stopProcessing = true;\n          }\n        } // end if an open parenthesis was found\n\n      } // end do while the input string is not empty\n\n\n      if (stopProcessing) this.parensUnits_ = [];\n      return [uStrArray.join(''), origString, stopProcessing];\n    } // end _processParens\n\n    /**\n     * Breaks the unit string into an array of unit descriptors and operators.\n     * If a unit descriptor consists of a number preceding a unit code, with\n     * no multiplication operator, e.g., 2mg instead of 2.mg, it is handled\n     * as if it were a parenthetical expression.\n     *\n     * This should only be called from within this class (or by test code).\n     *\n     * @param uStr the unit string being parsed\n     * @param origString the original string passed to parseString\n     * @returns\n     *  an array containing:\n     *    the array representing the unit string;\n     *    the original string passed in, possibly updated with corrections; and\n     *    and a flag indicating whether or not processing can continue.\n     *\n     * the this.retMsg_ array will be updated with any user messages\n     *   (informational, error or warning) generated by this or called methods\n     */\n\n  }, {\n    key: \"_makeUnitsArray\",\n    value: function _makeUnitsArray(uStr, origString) {\n      // Separate the string into pieces based on delimiters / (division) and .\n      // (multiplication).  The idea is to get an array of units on which we\n      // can then perform any operations (prefixes, multiplication, division).\n      var uArray1 = uStr.match(/([./]|[^./]+)/g);\n      var endProcessing = false;\n      var uArray = [];\n      var startNumCheck = /(^[0-9]+)(\\[?[a-zA-Z\\_0-9a-zA-Z\\_]+\\]?$)/; // If the first element in the array is the division operator (/), the\n      // string started with '/'.  Add a first element containing 1 to the\n      // array, which will cause the correct computation to be performed (inversion).\n\n      if (uArray1[0] === \"/\") {\n        uArray1.unshift(\"1\");\n      } // If the first element in the array is the multiplication operator (.)\n      // return an error.\n      else if (uArray1[0] === '.') {\n        this.retMsg_.push(\"\".concat(origString, \" is not a valid UCUM code. \") + \"The multiplication operator at the beginning of the expression is \" + \"not valid. A multiplication operator must appear only between \" + \"two codes.\");\n        endProcessing = true;\n      }\n\n      if (!endProcessing) {\n        // Check to see if there is a number preceding a unit code, e.g., 2mg\n        // If so, update the first element to remove the number (2mg -> mg) and\n        // add two elements to the beginning of the array - the number and the\n        // multiplication operator.\n        if (!intUtils_.isNumericString(uArray1[0])) {\n          var numRes = uArray1[0].match(startNumCheck);\n\n          if (numRes && numRes.length === 3 && numRes[1] !== '' && numRes[2] !== '' && numRes[2].indexOf(this.braceFlag_) !== 0) {\n            var dispVal = numRes[2];\n\n            if (!endProcessing && numRes[2].indexOf(this.parensFlag_) !== -1) {\n              var parensback = this._getParensUnit(numRes[2], origString);\n\n              numRes[2] = parensback[0]['csCode_'];\n              dispVal = \"(\".concat(numRes[2], \")\");\n              endProcessing = parensback[1];\n            }\n\n            if (!endProcessing) {\n              this.retMsg_.push(\"\".concat(numRes[1]).concat(dispVal, \" is not a valid UCUM code.\") + \"  \".concat(this.vcMsgStart_).concat(numRes[1], \".\").concat(dispVal).concat(this.vcMsgEnd_));\n              origString = origString.replace(\"\".concat(numRes[1]).concat(dispVal), \"\".concat(numRes[1], \".\").concat(dispVal));\n              uArray1[0] = numRes[2];\n              uArray1.unshift(numRes[1], '.');\n            }\n          }\n        } // end if the first element is not a number (only)\n        // Create an array of unit/operator objects.  The unit is, for now, the\n        // string containing the unit code (e.g., Hz for hertz) including\n        // a possible prefix and exponent.   The operator is the operator to be\n        // applied to that unit and the one preceding it.  So, a.b would give\n        // us two objects.  The first will have a unit of a, and a blank operator\n        // (because it's the first unit).  The second would have a unit of b\n        // and the multiplication operator (.).\n\n\n        if (!endProcessing) {\n          var u1 = uArray1.length;\n          uArray = [{\n            op: \"\",\n            un: uArray1[0]\n          }];\n\n          for (var n = 1; n < u1; n++) {\n            // check to make sure that we don't have two operators together, e.g.,\n            // mg./K.  If so, let the user know the problem.\n            var theOp = uArray1[n++]; // oh wait - check to make sure something is even there, that the\n            // user didn't end the expression with an operator.\n\n            if (!uArray1[n]) {\n              this.retMsg_.push(\"\".concat(origString, \" is not a valid UCUM code. \") + \"It is terminated with the operator \".concat(this.openEmph_) + \"\".concat(theOp).concat(this.closeEmph_, \".\"));\n              n = u1;\n              endProcessing = true;\n            } else if (Ucum.validOps_.indexOf(uArray1[n]) !== -1) {\n              this.retMsg_.push(\"\".concat(origString, \" is not a valid UCUM code. \") + \"A unit code is missing between\".concat(this.openEmph_) + \"\".concat(theOp).concat(this.closeEmph_, \"and\").concat(this.openEmph_) + \"\".concat(uArray1[n]).concat(this.closeEmph_, \"in\").concat(this.openEmph_) + \"\".concat(theOp).concat(uArray1[n]).concat(this.closeEmph_, \".\"));\n              n = u1;\n              endProcessing = true;\n            } else {\n              // Check to see if a number precedes a unit code.\n              // If so, send the element to _processParens, inserting the multiplication\n              // operator where it belongs.  Treating it as parenthetical keeps it from\n              // being interpreted incorrectly because of operator parentheses.  For\n              // example, if the whole string is mg/2kJ we don't want to rewrite it as\n              // mg/2.kJ - because mg/2 would be performed, followed by .kJ.  Instead,\n              // handling 2kJ as a parenthesized unit will make sure mg is divided by\n              // 2.kJ.\n              if (!intUtils_.isNumericString(uArray1[n])) {\n                var numRes2 = uArray1[n].match(startNumCheck);\n\n                if (numRes2 && numRes2.length === 3 && numRes2[1] !== '' && numRes2[2] !== '' && numRes2[2].indexOf(this.braceFlag_) !== 0) {\n                  var invalidString = numRes2[0];\n\n                  if (!endProcessing && numRes2[2].indexOf(this.parensFlag_) !== -1) {\n                    var _parensback = this._getParensUnit(numRes2[2], origString);\n\n                    numRes2[2] = _parensback[0]['csCode_'];\n                    invalidString = \"(\".concat(numRes2[2], \")\");\n                    endProcessing = _parensback[1];\n\n                    if (!endProcessing) {\n                      this.retMsg_.push(\"\".concat(numRes2[1]).concat(invalidString, \" is not a \") + \"valid UCUM code.  \".concat(this.vcMsgStart_).concat(numRes2[1], \".\").concat(invalidString) + \"\".concat(this.vcMsgEnd_));\n                      var parensString = \"(\".concat(numRes2[1], \".\").concat(invalidString, \")\");\n                      origString = origString.replace(\"\".concat(numRes2[1]).concat(invalidString), parensString);\n\n                      var nextParens = this._processParens(parensString, origString);\n\n                      endProcessing = nextParens[2];\n\n                      if (!endProcessing) {\n                        uArray.push({\n                          op: theOp,\n                          un: nextParens[0]\n                        });\n                      } //uArray.push({op: '.', un: numRes2[2]});\n\n                    }\n                  } // end if the string represents a parenthesized unit\n                  else {\n                    var parensStr = '(' + numRes2[1] + '.' + numRes2[2] + ')';\n\n                    var parensResp = this._processParens(parensStr, origString); // if a \"stop processing\" flag was returned, set the n index to end\n                    // the loop and set the endProcessing flag\n\n\n                    if (parensResp[2]) {\n                      n = u1;\n                      endProcessing = true;\n                    } else {\n                      this.retMsg_.push(\"\".concat(numRes2[0], \" is not a \") + \"valid UCUM code.  \".concat(this.vcMsgStart_).concat(numRes2[1], \".\").concat(numRes2[2]) + \"\".concat(this.vcMsgEnd_));\n                      origString = origString.replace(numRes2[0], parensStr);\n                      uArray.push({\n                        op: theOp,\n                        un: parensResp[0]\n                      });\n                    } // end if no error on the processParens call\n\n                  } // end if the string does not represent a parenthesized unit\n\n                } // end if the string is a number followed by a string\n                else {\n                  uArray.push({\n                    op: theOp,\n                    un: uArray1[n]\n                  });\n                }\n              } else {\n                uArray.push({\n                  op: theOp,\n                  un: uArray1[n]\n                });\n              }\n            } // end if there isn't a missing operator or unit code\n\n          } // end do for each element in uArray1\n\n        } // end if a processing error didn't occur in getParensUnit\n\n      } // end if the string did not begin with a '.' with no following digit\n\n\n      return [uArray, origString, endProcessing];\n    } // end _makeUnitsArray\n\n    /**\n     * Takes a unit string containing parentheses flags and returns the unit they\n     * represent.  Any text found before and/or after the parenthetical\n     * expression is checked to see if we can tell what the user meant and\n     * let them know what it should have been.  For example, 2(mg), which\n     * would resolve to 2mg, should be 2.mg.\n     *\n     * This should only be called from within this class (or by test code).\n     *\n     * @param pStr the string being parsed\n     * @param origString the original unit string passed in; passed through\n     *  to _getAnnonText if annotation flags are found in any text preceding\n     *  or following the parenthetical unit\n     * @returns\n     *   an array containing\n     *     the unit object; and\n     *     a flag indicating whether or not processing should be ended.\n     *       True indicates that the string was invalid and no corrections\n     *         (substitutions or suggestions) could be found;\n     *       False indicates that it was either valid or substitutions/suggestions\n     *          were made.\n     *   the this.retMsg_ array will be updated with any user messages\n     *     (informational, error or warning) generated by this or called methods\n     *   this this.parensUnits_ array contains the units that are acquired by\n     *     this method\n     * @throws an error if an invalid parensUnit index was found.  This is\n     *    a processing error.\n     */\n\n  }, {\n    key: \"_getParensUnit\",\n    value: function _getParensUnit(pStr, origString) {\n      var endProcessing = false;\n      var retAry = [];\n      var retUnit = null;\n      var befAnnoText = null;\n      var aftAnnoText = null; // Get the location of the flags.  We're assuming there are only two\n      // because _processParens takes care of nesting.  By the time we get\n      // here we should not be looking a nested parens.  Also get any text\n      // before and after the parentheses.  Once we get the unit we update\n      // the input string with the unit's csCode_, which will wipe out any\n      // before and after text\n\n      var psIdx = pStr.indexOf(this.parensFlag_);\n      var befText = null;\n\n      if (psIdx > 0) {\n        befText = pStr.substr(0, psIdx - 1);\n      }\n\n      var peIdx = pStr.lastIndexOf(this.parensFlag_);\n      var aftText = null;\n\n      if (peIdx + this.pFlagLen_ < pStr.length) {\n        aftText = pStr.substr(peIdx + this.pFlagLen_);\n      } // Get the text between the flags\n\n\n      var pNumText = pStr.substring(psIdx + this.pFlagLen_, peIdx); // Make sure the index is a number, and if it is, get the unit from the\n      // this.parensUnits_ array\n\n      if (intUtils_.isNumericString(pNumText)) {\n        retUnit = this.parensUnits_[Number(pNumText)];\n\n        if (!intUtils_.isIntegerUnit(retUnit)) {\n          pStr = retUnit.csCode_;\n        } else {\n          pStr = retUnit;\n        }\n      } // If it's not a number, it's a programming error.  Throw a fit.\n      else {\n        throw new Error(\"Processing error - invalid parens number \".concat(pNumText, \" \") + \"found in \".concat(pStr, \".\"));\n      } // If there's something in front of the starting parentheses flag, check to\n      // see if it's a number or an annotation.\n\n\n      if (befText) {\n        // If it's a number, assume that multiplication was assumed\n        if (intUtils_.isNumericString(befText)) {\n          var nMag = retUnit.getProperty('magnitude_');\n          nMag *= Number(befText);\n          retUnit.assignVals({\n            'magnitude_': nMag\n          });\n          pStr = \"\".concat(befText, \".\").concat(pStr);\n          this.retMsg_.push(\"\".concat(befText).concat(pStr, \" is not a valid UCUM code.\\n\") + this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n        } else {\n          if (befText.indexOf(this.braceFlag_) >= 0) {\n            var annoRet = this._getAnnoText(befText, origString); // if we found not only an annotation, but text before or after\n            // the annotation (remembering that this is all before the\n            // parentheses) throw an error - because we don't know what\n            // to do with it.  Could it be missing an operator?\n\n\n            if (annoRet[1] || annoRet[2]) {\n              throw new Error(\"Text found before the parentheses (\" + \"\".concat(befText, \") included an annotation along with other text \") + \"for parenthetical unit \".concat(retUnit.csCode_));\n            } // Otherwise put the annotation after the unit string and note\n            // the misplacement.\n\n\n            pStr += annoRet[0];\n            this.retMsg_.push(\"The annotation \".concat(annoRet[0], \" before the unit \") + \"code is invalid.\\n\" + this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n          } // else the text before the parentheses is neither a number nor\n          // an annotation.  If suggestions were NOT requested, record an\n          // error.\n          else if (!this.suggestions_) {\n            this.retMsg_.push(\"\".concat(befText, \" preceding the unit code \").concat(pStr, \" \") + \"is invalid.  Unable to make a substitution.\");\n            endProcessing = true;\n          } // otherwise try for suggestions\n          else {\n            var suggestStat = this._getSuggestions(befText);\n\n            endProcessing = suggestStat !== 'succeeded';\n          } // end if a brace was found or, if not, suggestions were not or\n          // were requested\n\n        } // end if text preceding the parentheses was not a number\n\n      } // end if there was text before the parentheses\n      // Process any text after the parentheses\n\n\n      if (aftText) {\n        // if it's an annotation, get it and add it to the pStr\n        if (aftText.indexOf(this.braceFlag_) >= 0) {\n          var _annoRet = this._getAnnoText(aftText, origString); // if we found not only an annotation, but text before or after\n          // the annotation (remembering that this is all after the\n          // parentheses) throw an error - because we don't know what\n          // to do with it.  Could it be missing an operator?\n\n\n          if (_annoRet[1] || _annoRet[2]) {\n            throw new Error(\"Text found after the parentheses (\" + \"\".concat(aftText, \") included an annotation along with other text \") + \"for parenthetical unit \".concat(retUnit.csCode_));\n          } // Otherwise put the annotation after the unit string - no message\n          // needed.\n\n\n          pStr += _annoRet[0];\n        } // Otherwise check to see if it's an exponent.  If so, warn the\n        // user that it's not valid - but try it anyway\n        else {\n          if (intUtils_.isNumericString(aftText)) {\n            pStr += aftText;\n            retUnit = retUnit.power(Number(aftText));\n            this.retMsg_.push(\"An exponent (\".concat(aftText, \") following a parenthesis \") + \"is invalid as of revision 1.9 of the UCUM Specification.\\n  \" + this.vcMsgStart_ + pStr + this.vcMsgEnd_);\n          } // else the text after the parentheses is neither a number nor\n          // an annotation.  If suggestions were NOT requested, record an\n          // error.\n          else if (!this.suggestions_) {\n            this.retMsg_.push(\"Text \".concat(aftText, \" following the unit code \").concat(pStr, \" \") + \"is invalid.  Unable to make a substitution.\");\n            endProcessing = true;\n          } // otherwise try for suggestions\n          else {\n            var _suggestStat = this._getSuggestions(befText);\n\n            endProcessing = _suggestStat !== 'succeeded';\n          } // end if text following the parentheses not an exponent\n\n        } // end if text following the parentheses is not an annotation\n\n      } // end if there is text following the parentheses\n\n\n      if (!endProcessing) {\n        if (!retUnit) {\n          retUnit = new Unit({\n            'csCode_': pStr,\n            'magnitude_': 1,\n            'name_': pStr\n          });\n        } else if (intUtils_.isIntegerUnit(retUnit)) {\n          retUnit = new Unit({\n            'csCode_': retUnit,\n            'magnitude_': retUnit,\n            'name_': retUnit\n          });\n        } else {\n          retUnit.csCode_ = pStr;\n        }\n      }\n\n      return [retUnit, endProcessing];\n    } // end _getParensUnit\n\n    /**\n     * Takes a unit string containing annotation flags and returns the\n     * annotation they represent.  This also returns any text found before\n     * the annotation and any found after the annotation.\n     *\n     * This should only be called from within this class (or by test code).\n     * NEEDS FIX in next branch to handle string with multiple annotations.\n     *\n     * @param pStr the string being parsed\n     * @param origString the original string being parsed; used in error msg\n     *  thrown for an invalid index to the annotations array\n     * @returns\n     *  an array containing\n     *    the annotation for the pStr;\n     *    any text found before the annotation; and\n     *    any text found after the annotation.\n     *\n     * the this.retMsg_ array will be updated with any user messages\n     *   (informational, error or warning) generated by this or called methods\n     * the this.annotations_ array is used as the source for the annotations text\n     * @throws an error if for a processing error - an invalid annotation index.\n     */\n\n  }, {\n    key: \"_getAnnoText\",\n    value: function _getAnnoText(pStr, origString) {\n      // if the starting braces flag is not at index 0, get the starting\n      // text and the adjust the pStr to omit it.\n      var asIdx = pStr.indexOf(this.braceFlag_);\n      var startText = asIdx > 0 ? pStr.substring(0, asIdx) : null;\n\n      if (asIdx !== 0) {\n        pStr = pStr.substr(asIdx);\n      } // Get the location of the end flag and, if text follows it, get the text\n\n\n      var aeIdx = pStr.indexOf(this.braceFlag_, 1);\n      var endText = aeIdx + this.bFlagLen_ < pStr.length ? pStr.substr(aeIdx + this.bFlagLen_) : null; // Get the index of the annotation in this.annotations_.\n      // Check it to make sure it's valid, and if not, throw an error\n\n      var idx = pStr.substring(this.bFlagLen_, aeIdx);\n      var idxNum = Number(idx);\n\n      if (!intUtils_.isNumericString(idx) || idxNum >= this.annotations_.length) {\n        throw new Error(\"Processing Error - invalid annotation index \".concat(idx, \" found \") + \"in \".concat(pStr, \" that was created from \").concat(origString));\n      } // Replace the flags and annotation index with the annotation expression\n\n\n      pStr = this.annotations_[idxNum];\n      return [pStr, startText, endText];\n    } // end _getAnnoText\n\n    /**\n     * Takes a unit string and looks for suggested units.  This should be\n     * called for unit strings that cannot be resolved to unit codes.  The\n     * string is searched for in the synonyms table found in the UnitTables\n     * class.  That table includes all synonyms and unit names for the units\n     * in the unit data table.\n     *\n     * @param pStr the string being parsed\n     * @returns an object that contains an element named 'status', whose\n     *  value indicates the status of the request:\n     *   'succeeded' indicates that synonyms were found;\n     *   'failed' indicates that no synonyms were found; or\n     *   'error' which indicates that an error occurred\n     *\n     * the this.retMsg_ array will be updated with a message indicating whether\n     *  or not synonyms/suggestions  were found\n     * the this.suggestions_ array will be updated with a hash (added to the\n     *   array if it already contains others) that contains three elements:\n     *   'msg' which is a message indicating what unit expression the\n     *      suggestions are for;\n     *   'invalidUnit' which is the unit expression the suggestions are for; and\n     *   'units' which is an array of data for each suggested unit found.\n     *       Each array will contain the unit code, the unit name and the\n     *       unit guidance (if any).\n     */\n\n  }, {\n    key: \"_getSuggestions\",\n    value: function _getSuggestions(pStr) {\n      var retObj = intUtils_.getSynonyms(pStr);\n\n      if (retObj['status'] === 'succeeded') {\n        var suggSet = {};\n        suggSet['msg'] = \"\".concat(pStr, \" is not a valid UCUM code.  We found possible \") + \"units that might be what was meant:\";\n        suggSet['invalidUnit'] = pStr;\n        var synLen = retObj['units'].length;\n        suggSet['units'] = [];\n\n        for (var s = 0; s < synLen; s++) {\n          var unit = retObj['units'][s];\n          var unitArray = [unit['code'], unit['name'], unit['guidance']];\n          suggSet['units'].push(unitArray);\n        }\n\n        this.suggestions_.push(suggSet);\n      } else {\n        this.retMsg_.push(\"\".concat(pStr, \" is not a valid UCUM code.  No alternatives \") + \"were found.\");\n      }\n\n      return retObj['status'];\n    } // end getSuggestions\n\n    /**\n     * Creates a unit object from a string defining one unit.  The string\n     * should consist of a unit code for a unit already defined (base or\n     * otherwise).  It may include a prefix and an exponent, e.g., cm2\n     * (centimeter squared).  This should only be called from within this\n     * class (or by test code).\n     *\n     * @params uCode the string defining the unit\n     * @param origString the original string to be parsed; used to provide\n     *  context for messages\n     * @returns\n     *  an array containing:\n     *    a unit object, or null if there were problems creating the unit; and\n     *    the origString passed in, which may be updated if a unit name was\n     *    translated to a unit code.\n     *\n     *  the this.retMsg_ array will be updated with any user messages\n     *    (informational, error or warning) generated by this or called methods\n     *  the this.suggestions_ array will be populated if no unit (with or without\n     *    substitutions) could be found and suggestions were requested\n     */\n\n  }, {\n    key: \"_makeUnit\",\n    value: function _makeUnit(uCode, origString) {\n      // First try the code just as is, without looking for annotations,\n      // prefixes, exponents, or elephants.\n      var retUnit = this.utabs_.getUnitByCode(uCode);\n\n      if (retUnit) {\n        retUnit = retUnit.clone();\n      } // If we found it, we're done.  No need to parse for those elephants (or\n      // other stuff).\n      else if (uCode.indexOf(this.braceFlag_) >= 0) {\n        var getAnnoRet = this._getUnitWithAnnotation(uCode, origString);\n\n        retUnit = getAnnoRet[0];\n\n        if (retUnit) {\n          origString = getAnnoRet[1];\n        } // If a unit is not found, retUnit will be returned null and\n        // the this.retMsg_ array will contain a message describing the problem.\n        // If a unit is found, of course, all is good. So ... nothing left\n        // to see here, move along.\n\n      } // end if the uCode includes an annotation\n      else {\n        // So we didn't find a unit for the full uCode or for one with\n        // annotations.  Try looking for a unit that uses a carat (^)\n        // instead of an asterisk (*)\n        if (uCode.indexOf('^') > -1) {\n          var tryCode = uCode.replace('^', '*');\n          retUnit = this.utabs_.getUnitByCode(tryCode);\n\n          if (retUnit) {\n            retUnit = retUnit.clone();\n            retUnit.csCode_ = retUnit.csCode_.replace('*', '^');\n            retUnit.ciCode_ = retUnit.ciCode_.replace('*', '^');\n          }\n        } // If that didn't work, check to see if it should have brackets\n        // around it (uCode = degF when it should be [degF]\n\n\n        if (!retUnit) {\n          var addBrackets = '[' + uCode + ']';\n          retUnit = this.utabs_.getUnitByCode(addBrackets);\n\n          if (retUnit) {\n            retUnit = retUnit.clone();\n            origString = origString.replace(uCode, addBrackets);\n            this.retMsg_.push(\"\".concat(uCode, \" is not a valid unit expression, but \") + \"\".concat(addBrackets, \" is.\\n\") + this.vcMsgStart_ + \"\".concat(addBrackets, \" (\").concat(retUnit.name_, \")\").concat(this.vcMsgEnd_));\n          } // end if we found the unit after adding brackets\n\n        } // end trying to add brackets\n        // If we didn't find it, try it as a name\n\n\n        if (!retUnit) {\n          var retUnitAry = this.utabs_.getUnitByName(uCode);\n\n          if (retUnitAry && retUnitAry.length > 0) {\n            retUnit = retUnitAry[0].clone();\n            var mString = 'The UCUM code for ' + uCode + ' is ' + retUnit.csCode_ + '.\\n' + this.vcMsgStart_ + retUnit.csCode_ + this.vcMsgEnd_;\n            var dupMsg = false;\n\n            for (var r = 0; r < this.retMsg_.length && !dupMsg; r++) {\n              dupMsg = this.retMsg_[r] === mString;\n            }\n\n            if (!dupMsg) this.retMsg_.push(mString);\n            var rStr = new RegExp('(^|[.\\/({])(' + uCode + ')($|[.\\/)}])');\n            var res = origString.match(rStr);\n            origString = origString.replace(rStr, res[1] + retUnit.csCode_ + res[3]);\n            uCode = retUnit.csCode_;\n          }\n        } // If we still don't have a unit, try assuming a modifier (prefix and/or\n        // exponent) and look for a unit without the modifier\n\n\n        if (!retUnit) {\n          // Well, first see if it's one of the special units.  If so,\n          // replace the placeholder text with the actual unit string, keeping\n          // whatever text (probably a prefix) goes with the unit string.\n          var sUnit = null;\n\n          for (sUnit in Ucum.specUnits_) {\n            if (uCode.indexOf(Ucum.specUnits_[sUnit]) !== -1) uCode = uCode.replace(Ucum.specUnits_[sUnit], sUnit);\n          }\n\n          retUnit = this.utabs_.getUnitByCode(uCode);\n          if (retUnit) retUnit = retUnit.clone();\n        }\n\n        if (!retUnit) {\n          var origCode = uCode;\n          var origUnit = null;\n          var exp = null;\n          var pfxCode = null;\n          var pfxObj = null;\n          var pfxVal = null;\n          var pfxExp = null; // Look first for an exponent.  If we got one, separate it out and\n          // try to get the unit again\n\n          var codeAndExp = this._isCodeWithExponent(uCode);\n\n          if (codeAndExp) {\n            uCode = codeAndExp[0];\n            exp = codeAndExp[1];\n            origUnit = this.utabs_.getUnitByCode(uCode);\n          } // If we still don't have a unit, separate out the prefix, if any,\n          // and try without it.\n\n\n          if (!origUnit) {\n            // Try for a single character prefix first.\n            pfxCode = uCode.charAt(0);\n            pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode); // if we got a prefix, get its info and remove it from the unit code\n\n            if (pfxObj) {\n              pfxVal = pfxObj.getValue();\n              pfxExp = pfxObj.getExp();\n              var pCodeLen = pfxCode.length;\n              uCode = uCode.substr(pCodeLen); // try again for the unit\n\n              origUnit = this.utabs_.getUnitByCode(uCode); // If we still don't have a unit, see if the prefix could be the\n              // two character \"da\" (deka) prefix.  That's the only prefix with\n              // two characters, and without this check it's interpreted as \"d\"\n              // (deci) and the \"a\" is considered part of the unit code.\n\n              if (!origUnit && pfxCode == 'd' && uCode.substr(0, 1) == 'a') {\n                pfxCode = 'da';\n                pfxObj = this.pfxTabs_.getPrefixByCode(pfxCode);\n                pfxVal = pfxObj.getValue();\n                uCode = uCode.substr(1); // try one more time for the unit\n\n                origUnit = this.utabs_.getUnitByCode(uCode);\n              }\n            } // end if we found a prefix\n\n          } // end if we didn't get a unit after removing an exponent\n          // If we still haven't found anything, we're done looking.\n          // (We tried with the full unit string, with the unit string\n          // without the exponent, the unit string without a prefix,\n          // common errors, etc. That's all we can try).\n\n\n          if (!origUnit) {\n            retUnit = null; // BUT if the user asked for suggestions, at least look for them\n\n            if (this.suggestions_) {\n              var suggestStat = this._getSuggestions(origCode);\n            } else {\n              this.retMsg_.push(\"\".concat(origCode, \" is not a valid UCUM code.\"));\n            }\n          } else {\n            // Otherwise we found a unit object.  Clone it and then apply the\n            // prefix and exponent, if any, to it.  And remove the guidance.\n            retUnit = origUnit.clone();\n            retUnit.guidance_ = '';\n            var theDim = retUnit.getProperty('dim_');\n            var theMag = retUnit.getProperty('magnitude_');\n            var theName = retUnit.getProperty('name_');\n            var theCiCode = retUnit.getProperty('ciCode_');\n            var thePrintSymbol = retUnit.getProperty('printSymbol_'); // If there is an exponent for the unit, apply it to the dimension\n            // and magnitude now\n\n            if (exp) {\n              exp = parseInt(exp);\n              var expMul = exp;\n              if (theDim) theDim = theDim.mul(exp);\n              theMag = Math.pow(theMag, exp);\n              retUnit.assignVals({\n                'magnitude_': theMag\n              }); // If there is also a prefix, apply the exponent to the prefix.\n\n              if (pfxObj) {\n                // if the prefix base is 10 it will have an exponent.  Multiply\n                // the current prefix exponent by the exponent for the unit\n                // we're working with.  Then raise the prefix value to the level\n                // defined by the exponent.\n                if (pfxExp) {\n                  expMul *= pfxObj.getExp();\n                  pfxVal = Math.pow(10, expMul);\n                } // If the prefix base is not 10, it won't have an exponent.\n                // At the moment I don't see any units using the prefixes\n                // that aren't base 10.   But if we get one the prefix value\n                // will be applied to the magnitude (below) if the unit does\n                // not have a conversion function, and to the conversion prefix\n                // if it does.\n\n              } // end if there's a prefix as well as the exponent\n\n            } // end if there's an exponent\n            // Now apply the prefix, if there is one, to the conversion\n            // prefix or the magnitude\n\n\n            if (pfxObj) {\n              if (retUnit.cnv_) {\n                retUnit.assignVals({\n                  'cnvPfx_': pfxVal\n                });\n              } else {\n                theMag *= pfxVal;\n                retUnit.assignVals({\n                  'magnitude_': theMag\n                });\n              }\n            } // if we have a prefix and/or an exponent, add them to the unit\n            // attributes - name, csCode, ciCode and print symbol\n\n\n            var theCode = retUnit.csCode_;\n\n            if (pfxObj) {\n              theName = pfxObj.getName() + theName;\n              theCode = pfxCode + theCode;\n              theCiCode = pfxObj.getCiCode() + theCiCode;\n              thePrintSymbol = pfxObj.getPrintSymbol() + thePrintSymbol;\n              retUnit.assignVals({\n                'name_': theName,\n                'csCode_': theCode,\n                'ciCode_': theCiCode,\n                'printSymbol_': thePrintSymbol\n              });\n            }\n\n            if (exp) {\n              var expStr = exp.toString();\n              retUnit.assignVals({\n                'name_': theName + '<sup>' + expStr + '</sup>',\n                'csCode_': theCode + expStr,\n                'ciCode_': theCiCode + expStr,\n                'printSymbol_': thePrintSymbol + '<sup>' + expStr + '</sup>'\n              });\n            }\n          } // end if an original unit was found (without prefix and/or exponent)\n\n        } // end if we didn't get a unit for the full unit code (w/out modifiers)\n\n      } // end if we didn't find the unit on the first try, before parsing\n\n\n      return [retUnit, origString];\n    } // end _makeUnit\n\n    /**\n     * This method handles unit creation when an annotation is included\n     * in the unit string.  This basically isolates and retrieves the\n     * annotation and then calls _makeUnit to try to get a unit from\n     * any text that precedes or follows the annotation.\n     *\n     * @param uCode the string defining the unit\n     * @param origString the original full string submitted to parseString\n     * @returns the unit object found, or null if one could not be found\n     *\n     * the this.retMsg_ array will be updated with any user messages\n     *   (informational, error or warning) generated by this or called methods\n     */\n\n  }, {\n    key: \"_getUnitWithAnnotation\",\n    value: function _getUnitWithAnnotation(uCode, origString) {\n      var retUnit = null; // Get the annotation and anything that precedes or follows it.\n\n      var annoRet = this._getAnnoText(uCode, origString);\n\n      var annoText = annoRet[0];\n      var befAnnoText = annoRet[1];\n      var aftAnnoText = annoRet[2]; // Add the warning about annotations - just once.\n\n      if (this.bracesMsg_ && this.retMsg_.indexOf(this.bracesMsg_) === -1) this.retMsg_.push(this.bracesMsg_); // If there's no text before or after the annotation, it's probably\n      // something that should be interpreted as a 1, e.g., {KCT'U}.\n      // HOWEVER, it could also be a case where someone used braces instead\n      // of brackets, e.g., {degF} instead of [degF].  Check for that before\n      // we assume it should be a 1.\n\n      var msgLen = this.retMsg_.length;\n\n      if (!befAnnoText && !aftAnnoText) {\n        var tryBrackets = '[' + annoText.substring(1, annoText.length - 1) + ']';\n\n        var mkUnitRet = this._makeUnit(tryBrackets, origString); // If we got back a unit, assign it to the returned unit, and add\n        // a message to advise the user that brackets should enclose the code\n\n\n        if (mkUnitRet[0]) {\n          retUnit = mkUnitRet[0];\n          origString = origString.replace(annoText, tryBrackets);\n          this.retMsg_.push(\"\".concat(annoText, \" is not a valid unit expression, but \") + \"\".concat(tryBrackets, \" is.\\n\") + this.vcMsgStart_ + \"\".concat(tryBrackets, \" (\").concat(retUnit.name_, \")\").concat(this.vcMsgEnd_));\n        } // Otherwise assume that this should be interpreted as a 1\n        else {\n          // remove error message generated for trybrackets\n          if (this.retMsg_.length > msgLen) {\n            this.retMsg_.pop();\n          }\n\n          uCode = 1;\n          retUnit = 1;\n        }\n      } // end if it's only an annotation\n      else {\n        // if there's text before and no text after, assume the text before\n        // the annotation is the unit code (with an annotation following it).\n        // Call _makeUnit for the text before the annotation.\n        if (befAnnoText && !aftAnnoText) {\n          // make sure that what's before the annoText is not a number, e.g.,\n          // /100{cells}.  But f it is a number, just set the return unit to\n          // the number.\n          if (intUtils_.isIntegerUnit(befAnnoText)) {\n            retUnit = befAnnoText;\n          } // Otherwise try to find a unit\n          else {\n            var _mkUnitRet = this._makeUnit(befAnnoText, origString); // if a unit was returned\n\n\n            if (_mkUnitRet[0]) {\n              retUnit = _mkUnitRet[0];\n              retUnit.csCode_ += annoText;\n              origString = _mkUnitRet[1];\n            } // Otherwise add a not found message\n            else {\n              this.retMsg_.push(\"Unable to find a unit for \".concat(befAnnoText, \" that \") + \"precedes the annotation \".concat(annoText, \".\"));\n            }\n          }\n        } // else if there's only text after the annotation, try for a unit\n        // from the after text and assume the user put the annotation in\n        // the wrong place (and tell them)\n        else if (!befAnnoText && aftAnnoText) {\n          // Again, test for a number and if it is a number, set the return\n          // unit to the number.\n          if (intUtils_.isIntegerUnit(aftAnnoText)) {\n            retUnit = aftAnnoText + annoText;\n            this.retMsg_.push(\"The annotation \".concat(annoText, \" before the \")(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \" is invalid.\\n\"], [\"\", \" is invalid.\\\\n\"])), aftAnnoText) + this.vcMsgStart_ + retUnit + this.vcMsgEnd_);\n          } else {\n            var _mkUnitRet2 = this._makeUnit(aftAnnoText, origString);\n\n            if (_mkUnitRet2[0]) {\n              retUnit = _mkUnitRet2[0];\n              retUnit.csCode_ += annoText;\n              origString = retUnit.csCode_;\n              this.retMsg_.push(\"The annotation \".concat(annoText, \" before the unit \") + \"code is invalid.\\n\" + this.vcMsgStart_ + retUnit.csCode_ + this.vcMsgEnd_);\n            } // Otherwise add a not found message\n            else {\n              this.retMsg_.push(\"Unable to find a unit for \".concat(befAnnoText, \" that \") + \"follows the annotation \".concat(annoText, \".\"));\n            }\n          }\n        } // else it's got text before AND after the annotation.  Now what?\n        // For now this is an error.  This may be a case of a missing\n        // operator but that is not handled yet.\n        else {\n          this.retMsg_.push(\"Unable to find a unit for \".concat(befAnnoText).concat(annoText) + \"\".concat(aftAnnoText, \".\\nWe are not sure how to interpret text both before \") + \"and after the annotation.  Sorry\");\n        }\n      } // else if there's text before/and or after the annotation\n\n\n      return [retUnit, origString];\n    } // end _getUnitWithAnnotations\n\n    /**\n     * Performs unit arithmetic for the units in the units array.  That array\n     * contains units/numbers and the operators (division or multiplication) to\n     * be performed on each unit/unit or unit/number pair in the array.  This\n     * should only be called from within this class (or by test code).\n     *\n     * @params uArray the array that contains the units, numbers and operators\n     *  derived from the unit string passed in to parseString\n     * @param origString the original string to be parsed; used to provide\n     *  context for messages\n     *\n     * @returns a single unit object that is the result of the unit arithmetic\n     *\n     * the this.retMsg_ array will be updated with any user messages\n     *   (informational, error or warning) generated by this or called methods\n     */\n\n  }, {\n    key: \"_performUnitArithmetic\",\n    value: function _performUnitArithmetic(uArray, origString) {\n      var finalUnit = uArray[0]['un'];\n\n      if (intUtils_.isIntegerUnit(finalUnit)) {\n        finalUnit = new Unit({\n          'csCode_': finalUnit,\n          'magnitude_': Number(finalUnit),\n          'name_': finalUnit\n        });\n      }\n\n      var uLen = uArray.length;\n      var endProcessing = false; // Perform the arithmetic for the units, starting with the first 2 units.\n      // We only need to do the arithmetic if we have more than one unit.\n\n      for (var u2 = 1; u2 < uLen && !endProcessing; u2++) {\n        var nextUnit = uArray[u2]['un'];\n\n        if (intUtils_.isIntegerUnit(nextUnit)) {\n          nextUnit = new Unit({\n            'csCode_': nextUnit,\n            'magnitude_': Number(nextUnit),\n            'name_': nextUnit\n          });\n        }\n\n        if (nextUnit === null || typeof nextUnit !== 'number' && !nextUnit.getProperty) {\n          var msgString = \"Unit string (\".concat(origString, \") contains unrecognized \") + 'element';\n\n          if (nextUnit) {\n            msgString += \" (\".concat(this.openEmph_).concat(nextUnit.toString()) + \"\".concat(this.closeEmph_, \")\");\n          }\n\n          msgString += '; could not parse full string.  Sorry';\n          this.retMsg_.push(msgString);\n          endProcessing = true;\n        } else {\n          try {\n            // Is the operation division?\n            var thisOp = uArray[u2]['op'];\n            var isDiv = thisOp === '/'; // Perform the operation.  Both the finalUnit and nextUnit\n            // are unit objects.\n\n            isDiv ? finalUnit = finalUnit.divide(nextUnit) : finalUnit = finalUnit.multiplyThese(nextUnit);\n          } catch (err) {\n            this.retMsg_.unshift(err.message);\n            endProcessing = true;\n            finalUnit = null;\n          }\n        } // end if we have another valid unit/number to process\n\n      } // end do for each unit after the first one\n\n\n      return finalUnit;\n    } // end _performUnitArithmetic\n\n    /**\n     * This tests a string to see if it starts with characters and ends with\n     * digits.  This is used to test for an exponent on a UCUM code (or what\n     * we think might be a UCUM code).  This is broken out to a separate\n     * function so that the regular expression can be verified to provide the\n     * results we expect, in case someone changes it.  (Per Paul Lynch)\n     * See \"Test _isCodeWithExponent method\" in testUnitString.spec.js\n     *\n     * This particular regex has been tweaked several times.  This one\n     * works with the following test strings:\n     * \"m[H2O]-21 gives [\"m[H2O]-21\", \"m[H2O]\", \"-21\"]\n     * \"m[H2O]+21 gives [\"m[H2O]+21\", \"m[H2O]\", \"+21\"]\n     * \"m[H2O]21 gives [\"m[H2O]-21\", \"m[H2O]\", \"21\"]\n     * \"s2\" gives [\"s2\", \"s, \"2\"]\n     * \"kg\" gives null\n     * \"m[H2O]\" gives null\n     * \"m[H2O]23X\" gives null\n     *\n     * @params uCode the code being tested\n     * @returns an array containing: (1) the code without the exponent (or\n     *  trailing number); and (2) the exponent/trailing number.  Returns null\n     *  if there is no trailing number or something follows the trailing\n     *  number, or if the first part is not characters.\n     */\n\n  }, {\n    key: \"_isCodeWithExponent\",\n    value: function _isCodeWithExponent(uCode) {\n      var ret = [];\n      var res = uCode.match(/(^[^\\-\\+]+?)([\\-\\+\\d]+)$/); // If we got a return with an exponent, separate the exponent from the\n      // unit and return both (as separate values)\n\n      if (res && res[2] && res[2] !== \"\") {\n        ret.push(res[1]);\n        ret.push(res[2]);\n      } // end if we got an exponent\n      else {\n        ret = null;\n      }\n\n      return ret;\n    } // end _isCodeWithExponent\n\n  }]);\n\n  return UnitString;\n}(); // end class UnitString\n\n/**\n *  This function exists ONLY until the original UnitString constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UnitString object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  @return the singleton UnitString object.\n */\n\n\nexports.UnitString = UnitString;\n\nUnitString.getInstance = function () {\n  return new UnitString();\n};\n/*\n// Perform the first request for the object, to set the getInstance method.\nUnitString.getInstance();\n\n*/","map":null,"metadata":{},"sourceType":"script"}