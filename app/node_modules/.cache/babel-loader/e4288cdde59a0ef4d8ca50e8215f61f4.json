{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnitTables = void 0;\n/**\n * This class manages Hashtables that provide references to\n * defined units.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\n\nvar Ucum = require('./config.js').Ucum;\n\nvar UnitTablesFactory = /*#__PURE__*/function () {\n  /**\n   * Constructor.  This creates the empty unit tables (hashes) once. After the\n   * tables are created, it redefines this constructor to throw an error\n   * stating that the constructor is no longer available and that the\n   * getInstance function must be used.   Here's a description of the first\n   * and then all subsequent calls to this constructor.\n   *\n   * First call to constructor:\n   * 1. creates  OBJECT1\n   * 2. initializes attributes of OBJECT1\n   * 3. stores reference to OBJECT1.prototype in holdthis local variable\n   * 4. redefines OBJECT1 as a function that throws an error\n   * 5. defines the getInstance function (which is also defined outside of\n   *    the class definition - see below).\n   *\n   * All subsequent calls to constructor:\n   * 1. throw error message referring to getInstance\n   * 2. call getInstance, returns this - which is OBJECT1.\n   */\n  function UnitTablesFactory() {\n    _classCallCheck(this, UnitTablesFactory);\n\n    /**\n     * Tracks units by name\n     * @type hash - key is the name;\n     *              value is an array of references to the Unit objects\n     *              with the name.  More than one unit may have the same\n     *              name, e.g., \"second\", which is shared by the base unit\n     *              with the code = \"s\" and the unit with code = \"'\".\n     */\n    this.unitNames_ = {};\n    /**\n     * Tracks units by code using case-sensitive version.\n     *\n     * @type hash - key is the code;\n     *              value is the reference to the Unit object.  Codes must\n     *              be unique.\n     */\n\n    this.unitCodes_ = {};\n    /**\n     * Keeps track of the order in which units are defined.  The order is\n     * important because unit definitions build on previous definitions.\n     *\n     * @type {Array}\n     */\n\n    this.codeOrder_ = [];\n    /**\n     * Tracks units by unit strings, e.g., cm-1\n     *\n     * @type hash - key is the unit string\n     *              value is an array of unit objects with that ciUnitString.\n     */\n\n    this.unitStrings_ = {};\n    /**\n     * Tracks units by Dimension vector\n     *\n     * @type hash - key is the dimension vector (not the object, just the\n     *              vector);\n     *              value is an array of references to the Unit objects\n     *              with that vector.  More than one unit may have the same\n     *              unit vector, and this can be used to provide a list\n     *              of commensurable units.\n     */\n\n    this.unitDimensions_ = {};\n    /**\n     * Maps synonyms to units.   Not built until first requested.\n     *\n     * @type hash - key is the synonym\n     *              value is an array of references to Unit objects that\n     *              include that synonym.\n     */\n\n    this.unitSynonyms_ = {};\n    /*\n     * Holds onto the index of the index of the dimension vector flag for\n     * the base mass unit (gram).  This is set when the base unit (gram) is\n     * created, and is stored here so that it doesn't have to be found\n     * over and over again to try to determine whether or not a unit is\n     * mass-based (for mole<->mass conversions)\n     *\n     * @type integer\n     */\n\n    this.massDimIndex_ = 0;\n  }\n  /**\n   * Provides the number of unit objects written to the tables, using the\n   * codes table since codes must be unique.\n   *\n   * @returns count of the number of unit objects in the unitCodes_ table.\n   */\n\n\n  _createClass(UnitTablesFactory, [{\n    key: \"unitsCount\",\n    value: function unitsCount() {\n      return Object.keys(this.unitCodes_).length;\n    }\n    /**\n     * Adds a Unit object to the tables.\n     *\n     * @param theUnit the unit to be added\n     * @returns nothing\n     * @throws passes on an error if one is thrown by the called functions for\n     *  a problem with the unit code or unit name\n     */\n\n  }, {\n    key: \"addUnit\",\n    value: function addUnit(theUnit) {\n      var uName = theUnit['name_'];\n\n      if (uName) {\n        this.addUnitName(theUnit);\n      }\n\n      this.addUnitCode(theUnit);\n      this.addUnitString(theUnit);\n\n      try {\n        if (theUnit['dim_'].getProperty('dimVec_')) this.addUnitDimension(theUnit);\n      } catch (err) {// do nothing - throws error if the property is null\n        // and that's OK here.\n      }\n    } // end addUnit\n\n    /**\n     * Adds a Unit object to the unitNames_ table.  More than one unit\n     * can have the same name, e.g., the two units with the name \"second\",\n     * where the code for one of them is 's' and the code for the other is\n     * \"'\".  Because of this, an array of unit objects is stored for the\n     * name.  In most cases it will be an array of one object, but this\n     * clarifies that there may be more than one.\n     *\n     * @param theUnit the unit to be added\n     * @returns nothing\n     * @throws an error if the unit has no name\n     */\n\n  }, {\n    key: \"addUnitName\",\n    value: function addUnitName(theUnit) {\n      var uName = theUnit['name_'];\n\n      if (uName) {\n        if (this.unitNames_[uName]) this.unitNames_[uName].push(theUnit);else this.unitNames_[uName] = [theUnit];\n      } else throw new Error('UnitTables.addUnitName called for a unit with no name.  ' + \"Unit code = \".concat(theUnit['csCode_'], \".\"));\n    } // end addUnitName\n\n    /**\n     * Adds a Unit object to the unitCodes_, unitUcCodes_, unitLcCodes_ and\n     * codeOrder_ tables.  This also sets the mass dimension index when the\n     * base mass unit (gram) is read.\n     *\n     * @param theUnit the unit to be added\n     * @returns nothing\n     * @throws an error if the unitCodes_ table already contains a unit with\n     *  the code\n     */\n\n  }, {\n    key: \"addUnitCode\",\n    value: function addUnitCode(theUnit) {\n      var uCode = theUnit['csCode_'];\n\n      if (uCode) {\n        if (this.unitCodes_[uCode]) throw new Error(\"UnitTables.addUnitCode called, already contains entry for \" + \"unit with code = \".concat(uCode));else {\n          this.unitCodes_[uCode] = theUnit;\n          this.codeOrder_.push(uCode);\n\n          if (uCode == 'g') {\n            var dimVec = theUnit.dim_.dimVec_;\n            var d = 0;\n\n            for (; d < dimVec.length && dimVec[d] < 1; d++) {\n              ;\n            }\n\n            this.massDimIndex_ = d;\n          }\n        }\n      } else throw new Error('UnitTables.addUnitCode called for unit that has ' + 'no code.');\n    } // end addUnitCode\n\n    /**\n     * Adds a unit object to the unitStrings_ table.  More than one unit\n     * can have the same string, so an array of unit objects is stored\n     * for the string.  The unit string is the string that creates a non-base\n     * unit, e.g., a Newton has a unit code of N, a name of Newton, and a\n     * unitString of kg.m/s2.\n     *\n     * If the unit has no string, nothing is stored and no error is reported.\n     *\n     * @param theUnit the unit to be added\n     * @returns nothing\n     */\n\n  }, {\n    key: \"addUnitString\",\n    value: function addUnitString(theUnit) {\n      var uString = null;\n      if (Ucum.caseSensitive_ == true) uString = theUnit['csUnitString_'];else uString = theUnit['ciUnitString_'];\n\n      if (uString) {\n        var uEntry = {\n          mag: theUnit['baseFactorStr_'],\n          unit: theUnit\n        };\n        if (this.unitStrings_[uString]) this.unitStrings_[uString].push(uEntry);else this.unitStrings_[uString] = [uEntry];\n      }\n    } // end addUnitString\n\n    /**\n     * Adds a Unit object to the unitDimensions_ table.  More than one unit\n     * can have the same dimension (commensurable units have the same dimension).\n     * Because of this, an array of unit objects is stored for the\n     * dimension.\n     *\n     * @param theUnit the unit to be added\n     * @returns nothing\n     * @throws an error if the unit has no dimension\n     */\n\n  }, {\n    key: \"addUnitDimension\",\n    value: function addUnitDimension(theUnit) {\n      var uDim = theUnit['dim_'].getProperty('dimVec_');\n\n      if (uDim) {\n        if (this.unitDimensions_[uDim]) this.unitDimensions_[uDim].push(theUnit);else this.unitDimensions_[uDim] = [theUnit];\n      } else throw new Error('UnitTables.addUnitDimension called for a unit with no dimension.  ' + \"Unit code = \".concat(theUnit['csCode_'], \".\"));\n    } // end addUnitDimension\n\n    /**\n     * Builds the unitSynonyms_ table. This is called the first time the\n     * getUnitsBySynonym method is called.  The table/hash contains each word\n     * (once) from each synonym as well as each word from each unit name.\n     *\n     * Hash keys are the words.  Hash values are an array of unit codes for\n     * each unit that has that word in its synonyms or name.\n     *\n     * @returns nothing\n     */\n\n  }, {\n    key: \"buildUnitSynonyms\",\n    value: function buildUnitSynonyms() {\n      for (var code in this.unitCodes_) {\n        var theUnit = this.unitCodes_[code];\n        var uSyns = theUnit.synonyms_; // If the current unit has synonyms, process each synonym (often multiples)\n\n        if (uSyns) {\n          var synsAry = uSyns.split(';');\n\n          if (synsAry[0] !== '') {\n            var aLen = synsAry.length;\n\n            for (var a = 0; a < aLen; a++) {\n              var theSyn = synsAry[a].trim(); // call addSynonymCodes to process each word in the\n              // synonym, e.g., \"British fluid ounces\"\n\n              this.addSynonymCodes(code, theSyn);\n            } // end do for each synonym\n\n          } // end if the current unit has a non-null synonym attribute\n\n        } // end if the unit has any synonyms\n        // Now call addSynonymCodes to process each word in the unit's name\n\n\n        this.addSynonymCodes(code, theUnit.name_);\n      } // end do for each unit\n\n    } // end buildUnitSynonyms\n\n    /**\n     * Adds unit code entries to the synonyms table for a string containing\n     * one or more words to be considered as synonyms.\n     *\n     * @param theCode the unit code to be connected to the synonyms\n     * @param theSynonyms a string containing one or more words to be\n     *  considered synonyms (and thus to be added to the unitSynonyms hash).\n     */\n\n  }, {\n    key: \"addSynonymCodes\",\n    value: function addSynonymCodes(theCode, theSynonyms) {\n      var words = theSynonyms.split(' ');\n      var wLen = words.length;\n\n      for (var w = 0; w < wLen; w++) {\n        var word = words[w]; // if there is already a synonyms entry for the word,\n        // get the array of unit codes currently assigned to\n        // the word and add the code for the current word to\n        // the synonyms array if it's not already there.\n\n        if (this.unitSynonyms_[word]) {\n          var synCodes = this.unitSynonyms_[word];\n\n          if (synCodes.indexOf(theCode) === -1) {\n            this.unitSynonyms_[word].push(theCode);\n          }\n        } // else there are no synonyms entry for the word.  Create a\n        // synonyms array for the word, setting it to contain the unit code.\n        else {\n          this.unitSynonyms_[word] = [theCode];\n        }\n      } // end do for each word in the synonyms being processed\n\n    } // end addSynonymCodes\n\n    /**\n     *  Returns a unit object with a case-sensitive code matching the\n     *  uCode parameter, or null if no unit is found with that code.\n     *\n     *  @param uCode the code of the unit to be returned\n     *  @returns the unit object or null if it is not found\n     */\n\n  }, {\n    key: \"getUnitByCode\",\n    value: function getUnitByCode(uCode) {\n      var retUnit = null;\n\n      if (uCode) {\n        retUnit = this.unitCodes_[uCode];\n      }\n\n      return retUnit;\n    }\n    /**\n     *  Returns a array of unit objects based on the unit's name.  Usually this\n     *  will be an array of one, but there may be more, since unit names are\n     *  not necessarily unique.\n     *\n     *  @param uName the name of the unit to be returned.  If more than one\n     *  unit has the same name and you only want one specific unit, append the\n     *  csCode of the unit you want to the end of the name, separated by the\n     *  Ucum.codeSep_ value, e.g., inch - [in_i] vs. inch - [in_us].\n     *  @returns null if no unit was found for the specified name OR an array of\n     *  unit objects with the specified name.  Normally this will be an array\n     *  of one object.\n     *  @throws an error if no name is provided to search on\n     */\n\n  }, {\n    key: \"getUnitByName\",\n    value: function getUnitByName(uName) {\n      if (uName === null || uName === undefined) {\n        throw new Error('Unable to find unit by name because no name was provided.');\n      }\n\n      var sepPos = uName.indexOf(Ucum.codeSep_);\n      var uCode = null;\n\n      if (sepPos >= 1) {\n        uCode = uName.substr(sepPos + Ucum.codeSep_.length);\n        uName = uName.substr(0, sepPos);\n      }\n\n      var retUnits = this.unitNames_[uName];\n\n      if (retUnits) {\n        var uLen = retUnits.length;\n\n        if (uCode && uLen > 1) {\n          var i = 0;\n\n          for (; retUnits[i].csCode_ !== uCode && i < uLen; i++) {\n            ;\n          }\n\n          if (i < uLen) retUnits = [retUnits[i]];else {\n            retUnits = null;\n          }\n        } // end if we need to find both a name and a code\n\n      } // end if we got an array of units\n\n\n      return retUnits;\n    } // end getUnitByName\n\n    /**\n     *  Returns an array of unit objects with the specified unit string.\n     *  The array may contain one or more unit reference objects.\n     *  Or none, if no units have a matching unit string (which is not\n     *  considered an error)\n     *\n     *  @param name the name of the unit to be returned\n     *  @returns the array of unit references or null if none were found\n     */\n\n  }, {\n    key: \"getUnitByString\",\n    value: function getUnitByString(uString) {\n      var retAry = null;\n\n      if (uString) {\n        retAry = this.unitStrings_[uString];\n        if (retAry === undefined) retAry = null;\n      }\n\n      return retAry;\n    }\n    /**\n     *  Returns a array of unit objects based on the unit's dimension vector.\n     *\n     *  @param uName the dimension vector of the units to be returned.\n     *\n     *  @returns null if no unit was found for the specified vector OR an array of\n     *  one or more unit objects with the specified vector.\n     *  @throws an error if no vector is provided to search on\n     *  logs an error to the console if no unit is found\n     */\n\n  }, {\n    key: \"getUnitsByDimension\",\n    value: function getUnitsByDimension(uDim) {\n      var unitsArray = null;\n\n      if (uDim === null || uDim === undefined) {\n        throw new Error('Unable to find unit by because no dimension ' + 'vector was provided.');\n      }\n\n      unitsArray = this.unitDimensions_[uDim];\n\n      if (unitsArray === undefined || unitsArray === null) {\n        console.log(\"Unable to find unit with dimension = \".concat(uDim));\n      }\n\n      return unitsArray;\n    } // end getUnitsByDimension\n\n    /**\n     *  Returns a array of unit objects that include the specified synonym.\n     *\n     *  @param uSyn the synonym of the units to be returned.\n     *\n     *  @returns an object with two of the following three elements:\n     *   'status' will be error, failed or succeeded\n     *   'msg' will be included for returns with status = error or failed and\n     *     will explain why the request did not return any units\n     *   'units' any array of unit objects with the specified synonym will be\n     *     returned for requests with status = succeeded\n     */\n\n  }, {\n    key: \"getUnitBySynonym\",\n    value: function getUnitBySynonym(uSyn) {\n      var retObj = {};\n      var unitsArray = [];\n\n      try {\n        if (uSyn === null || uSyn === undefined) {\n          retObj['status'] = 'error';\n          throw new Error('Unable to find unit by synonym because no synonym ' + 'was provided.');\n        } // If this is the first request for a unit by synonym, build the hash map\n\n\n        if (Object.keys(this.unitSynonyms_).length === 0) {\n          this.buildUnitSynonyms();\n        }\n\n        var foundCodes = [];\n        foundCodes = this.unitSynonyms_[uSyn];\n\n        if (foundCodes) {\n          retObj['status'] = 'succeeded';\n          var fLen = foundCodes.length;\n\n          for (var f = 0; f < fLen; f++) {\n            unitsArray.push(this.unitCodes_[foundCodes[f]]);\n          }\n\n          retObj['units'] = unitsArray;\n        }\n\n        if (unitsArray.length === 0) {\n          retObj['status'] = 'failed';\n          retObj['msg'] = \"Unable to find any units with synonym = \".concat(uSyn);\n        }\n      } catch (err) {\n        retObj['msg'] = err.message;\n      }\n\n      return retObj;\n    } // end getUnitBySynonym\n\n    /**\n     * Gets a list of all unit names in the Unit tables\n     *\n     * @returns an array of the unit names\n     */\n\n  }, {\n    key: \"getAllUnitNames\",\n    value: function getAllUnitNames() {\n      return Object.keys(this.unitNames_);\n    } // end getAllUnitNames\n\n    /**\n     * Gets a list of all unit names in the tables.  Where more than one\n     * unit has the same name, the unit code, in parentheses, is appended\n     * to the end of the name.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getUnitNamesList\",\n    value: function getUnitNamesList() {\n      var nameList = [];\n      var codes = Object.keys(this.unitCodes_);\n      codes.sort(this.compareCodes);\n      var uLen = codes.length;\n\n      for (var i = 0; i < uLen; i++) {\n        nameList[i] = codes[i] + Ucum.codeSep_ + this.unitCodes_[codes[i]].name_;\n      } // end do for each code\n\n\n      return nameList;\n    }\n    /*\n     * Returns the mass dimension index\n     * @returns this.massDimIndex_\n     */\n\n  }, {\n    key: \"getMassDimensionIndex\",\n    value: function getMassDimensionIndex() {\n      return this.massDimIndex_;\n    }\n    /**\n     * This provides a sort function for unit codes so that sorting ignores\n     * square brackets and case.\n     *\n     * @param a first value\n     * @param b second value\n     * @returns -1 if a is should fall before b; otherwise 1.\n     */\n\n  }, {\n    key: \"compareCodes\",\n    value: function compareCodes(a, b) {\n      a = a.replace(/[\\[\\]]/g, '');\n      a = a.toLowerCase();\n      b = b.replace(/[\\[\\]]/g, '');\n      b = b.toLowerCase();\n      return a < b ? -1 : 1;\n    }\n    /**\n     * Gets a list of all unit codes in the Unit tables\n     *\n     * @returns an array of the unit names\n     */\n\n  }, {\n    key: \"getAllUnitCodes\",\n    value: function getAllUnitCodes() {\n      return Object.keys(this.unitCodes_);\n    } // end getAllUnitNames\n\n    /**\n     * This is used to get all unit objects.  Currently it is used\n     * to get the objects to write to the json ucum definitions file\n     * that is used to provide prefix and unit definition objects for\n     * conversions and validations.\n     *\n     * @returns an array containing all unit objects, ordered by definition\n     * order\n     */\n\n  }, {\n    key: \"allUnitsByDef\",\n    value: function allUnitsByDef() {\n      var unitsList = [];\n      var uLen = this.codeOrder_.length;\n\n      for (var u = 0; u < uLen; u++) {\n        unitsList.push(this.getUnitByCode(this.codeOrder_[u]));\n      }\n\n      return unitsList;\n    } // end allUnitsByDef\n\n    /**\n     * This is used to get all unit objects, ordered by unit name.  Currently it\n     * is used to create a csv list of all units.\n     * @param sep separator character (or string) to be used to separate each\n     *  column in the output.  Optional, defaults to '|' if not specified.\n     *  (Used to use ; but the synonyms use that extensively).  Don't use a\n     *  comma or any other punctuation found in the output data.\n     * @returns a buffer containing all unit objects, ordered by name\n     * order\n     */\n\n  }, {\n    key: \"allUnitsByName\",\n    value: function allUnitsByName(cols, sep) {\n      if (sep === undefined || sep === null) sep = '|';\n      var unitBuff = '';\n      var unitsList = this.getAllUnitNames();\n      var uLen = unitsList.length;\n      var cLen = cols.length;\n\n      for (var i = 0; i < uLen; i++) {\n        var nameRecs = this.getUnitByName(unitsList[i]);\n\n        for (var u = 0; u < nameRecs.length; u++) {\n          var rec = nameRecs[u];\n\n          for (var c = 0; c < cLen; c++) {\n            if (c > 0) unitBuff += sep;\n\n            if (cols[c] === 'dim_') {\n              if (rec.dim_ !== null && rec.dim_ !== undefined && rec.dim_.dimVec_ instanceof Array) unitBuff += '[' + rec.dim_.dimVec_.join(',') + ']';else unitBuff += '';\n            } else {\n              var cbuf = rec[cols[c]];\n              if (typeof cbuf === 'string') unitBuff += cbuf.replace(/[\\n\\r]/g, ' ');else unitBuff += cbuf;\n            }\n          } // end do for each column requested\n\n\n          unitBuff += '\\r\\n';\n        } // end do for each unit in the unit names array\n\n      }\n\n      return unitBuff;\n    } // end allUnitsByName\n\n    /**\n     * This creates a list of all units in the tables.  It uses the byCode\n     * table, and uses the codeOrder_ array to determine the order in which\n     * the units are listed.\n     *\n     * @param doLong boolean indicating how much to output.  If true, all data\n     *  from the unit objects is included.   If false, only a few major values\n     *  are included.\n     * @param sep separator character (or string) to be used to separate each\n     *  column in the output.  Optional, defaults to '|' if not specified.\n     *  (Used to use ; but the synonyms use that extensively).\n     * @returns {string} buffer containing all the listings\n     */\n\n  }, {\n    key: \"printUnits\",\n    value: function printUnits(doLong, sep) {\n      if (doLong === undefined) doLong = false;\n      if (sep === undefined) sep = '|';\n      var codeList = '';\n      var uLen = this.codeOrder_.length;\n      var unitString = 'csCode' + sep;\n\n      if (doLong) {\n        unitString += 'ciCode' + sep;\n      }\n\n      unitString += 'name' + sep;\n      if (doLong) unitString += 'isBase' + sep;\n      unitString += 'magnitude' + sep + 'dimension' + sep + 'from unit(s)' + sep + 'value' + sep + 'function' + sep;\n      if (doLong) unitString += 'property' + sep + 'printSymbol' + sep + 'synonyms' + sep + 'source' + sep + 'class' + sep + 'isMetric' + sep + 'variable' + sep + 'isSpecial' + sep + 'isAbitrary' + sep;\n      unitString += 'comment';\n      codeList = unitString + '\\n';\n\n      for (var u = 0; u < uLen; u++) {\n        var curUnit = this.getUnitByCode(this.codeOrder_[u]);\n        unitString = this.codeOrder_[u] + sep;\n\n        if (doLong) {\n          unitString += curUnit.getProperty('ciCode_') + sep;\n        }\n\n        unitString += curUnit.getProperty('name_') + sep;\n\n        if (doLong) {\n          if (curUnit.getProperty('isBase_')) unitString += 'true' + sep;else unitString += 'false' + sep;\n        }\n\n        unitString += curUnit.getProperty('magnitude_') + sep;\n        var curDim = curUnit.getProperty('dim_');\n\n        if (curDim) {\n          unitString += curDim.dimVec_ + sep;\n        } else {\n          unitString += 'null' + sep;\n        }\n\n        if (curUnit.csUnitString_) unitString += curUnit.csUnitString_ + sep + curUnit.baseFactor_ + sep;else unitString += 'null' + sep + 'null' + sep;\n        if (curUnit.cnv_) unitString += curUnit.cnv_ + sep;else unitString += 'null' + sep;\n\n        if (doLong) {\n          unitString += curUnit.getProperty('property_') + sep + curUnit.getProperty('printSymbol_') + sep + curUnit.getProperty('synonyms_') + sep + curUnit.getProperty('source_') + sep + curUnit.getProperty('class_') + sep + curUnit.getProperty('isMetric_') + sep + curUnit.getProperty('variable_') + sep + curUnit.getProperty('isSpecial_') + sep + curUnit.getProperty('isArbitrary_') + sep;\n        }\n\n        if (curUnit.defError_) unitString += 'problem parsing this one, deferred to later.';\n        codeList += unitString + '\\n';\n      }\n\n      return codeList;\n    }\n  }]);\n\n  return UnitTablesFactory;\n}(); // end UnitTablesFactory\n// Create a singleton instance and (to preserve the existing API) an object that\n// provides that instance via getInstance().\n\n\nvar unitTablesInstance = new UnitTablesFactory();\nvar UnitTables = {\n  getInstance: function getInstance() {\n    return unitTablesInstance;\n  }\n};\nexports.UnitTables = UnitTables;","map":null,"metadata":{},"sourceType":"script"}