{"ast":null,"code":"const antlr4 = require(\"./antlr4-index\");\n\nconst Lexer = require(\"./generated/FHIRPathLexer\").FHIRPathLexer;\n\nconst Parser = require(\"./generated/FHIRPathParser\").FHIRPathParser;\n\nconst Listener = require(\"./generated/FHIRPathListener\").FHIRPathListener;\n\nvar ErrorListener = function (errors) {\n  antlr4.error.ErrorListener.call(this);\n  this.errors = errors;\n  return this;\n};\n\nErrorListener.prototype = Object.create(antlr4.error.ErrorListener.prototype);\nErrorListener.prototype.constructor = ErrorListener;\n\nErrorListener.prototype.syntaxError = function (rec, sym, line, col, msg, e) {\n  this.errors.push([rec, sym, line, col, msg, e]);\n};\n\nvar parse = function (path) {\n  var chars = new antlr4.InputStream(path);\n  var lexer = new Lexer(chars);\n  var tokens = new antlr4.CommonTokenStream(lexer);\n  var parser = new Parser(tokens);\n  parser.buildParseTrees = true;\n  var errors = [];\n  var listener = new ErrorListener(errors);\n  lexer.removeErrorListeners();\n  lexer.addErrorListener(listener);\n  parser.removeErrorListeners();\n  parser.addErrorListener(listener);\n  var tree = parser.entireExpression();\n\n  function PathListener() {\n    Listener.call(this); // inherit default listener\n\n    return this;\n  } // inherit default listener\n\n\n  PathListener.prototype = Object.create(Listener.prototype);\n  PathListener.prototype.constructor = PathListener;\n  var ast = {};\n  var node;\n  var parentStack = [ast];\n\n  for (let p of Object.keys(Listener.prototype)) {\n    if (p.startsWith(\"enter\")) {\n      PathListener.prototype[p] = function (ctx) {\n        let parentNode = parentStack[parentStack.length - 1];\n        let nodeType = p.slice(5); // remove \"enter\"\n\n        node = {\n          type: nodeType\n        };\n        node.text = ctx.getText();\n        if (!parentNode.children) parentNode.children = [];\n        parentNode.children.push(node);\n        parentStack.push(node); // Also collect this node's terminal nodes, if any.  Terminal nodes are\n        // not walked with the rest of the tree, but include things like \"+\" and\n        // \"-\", which we need.\n\n        node.terminalNodeText = [];\n\n        for (let c of ctx.children) {\n          // Test for node type \"TerminalNodeImpl\".  Minimized code no longer\n          // has the original function names, so we can't rely on\n          // c.constructor.name.  It appears the TerminalNodeImpl is the only\n          // node with a \"symbol\" property, so test for that.\n          if (c.symbol) node.terminalNodeText.push(c.getText());\n        }\n      };\n    } else if (p.startsWith(\"exit\")) {\n      PathListener.prototype[p] = function () {\n        parentStack.pop();\n      };\n    }\n  }\n\n  var printer = new PathListener();\n  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);\n\n  if (errors.length > 0) {\n    let errMsgs = [];\n\n    for (let i = 0, len = errors.length; i < len; ++i) {\n      let err = errors[i];\n      let msg = \"line: \" + err[2] + \"; column: \" + err[3] + \"; message: \" + err[4];\n      errMsgs.push(msg);\n    }\n\n    var e = new Error(errMsgs.join(\"\\n\"));\n    e.errors = errors;\n    throw e;\n  }\n\n  return ast;\n};\n\nmodule.exports = {\n  parse: parse\n};","map":null,"metadata":{},"sourceType":"script"}