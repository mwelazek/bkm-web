{"ast":null,"code":"import keyCode from './constants/key-code';\nimport tabbable from 'tabbable';\nimport { getDocumentActiveElement } from './focus-utils';\nimport { getEventTarget } from './web-component/events';\n/* Class som ved init låser fokuset inne i én DOMElement. Bruksområder er f.eks Modalvinduer.\nTar imot en DomNode (HTMLElement eller string) som fokuset skal låses i. */\n\nexport class TrapFocus {\n  constructor(domNode) {\n    let isTriggerWithinTrappedArea = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.domNode = typeof domNode === 'string' ? document.querySelector(domNode) : domNode;\n    const activeElement = getDocumentActiveElement(domNode);\n    this.previouslyFocusedItem = activeElement ? activeElement : document.activeElement; // Get focusable elements\n\n    this.updateFocusableItems(); // Set focus to element to be able to listen for keypress\n\n    if (!isTriggerWithinTrappedArea && this.focusableItems.length) {\n      this.focusableItems[0].focus();\n    }\n\n    window.addEventListener('keydown', this, false);\n  }\n\n  deactivate() {\n    window.removeEventListener('keydown', this, false);\n    this.focusableItems = [];\n    this.domNode = null;\n\n    if (this.previouslyFocusedItem && this.previouslyFocusedItem.focus) {\n      this.previouslyFocusedItem.focus();\n    }\n  }\n\n  handleEvent(e) {\n    if (e.keyCode !== keyCode.TAB) {\n      return null;\n    }\n\n    e.stopPropagation();\n    e.preventDefault();\n    const target = getEventTarget(e);\n    this.updateFocusableItems();\n    const currentFocusIndex = this.getItemIndex(target); // When the element focused is not in list, sets focus on the first focusable element of the list\n\n    if (currentFocusIndex === -1) {\n      if (this.focusableItems.length > 0 && this.focusableItems[0]) {\n        this.focusableItems[0].focus();\n      }\n\n      return null;\n    }\n\n    if (e.shiftKey) {\n      this.previousFocusableItem(target).focus();\n    } else {\n      this.nextFocusableItem(target).focus();\n    }\n\n    return null;\n  }\n\n  updateFocusableItems() {\n    if (this.domNode) {\n      this.focusableItems = tabbable(this.domNode);\n    }\n  }\n\n  previousFocusableRadioButton(itemWithFocus) {\n    const currentFocusIndex = this.getItemIndex(itemWithFocus); // Previous focusable item should not be a radio button in same group\n\n    for (let i = currentFocusIndex; i >= 0; i--) {\n      const previousElement = this.focusableItems[i];\n\n      if (!this.isRadioButton(previousElement)) {\n        return previousElement;\n      } // Element is a radio button, but not in same group\n\n\n      if (previousElement.name !== itemWithFocus.name) {\n        return this.getSelectedRadioInGroup(previousElement);\n      }\n    } // All the previous items are in the same radio group, start from end\n\n\n    for (let i = this.focusableItems.length - 1; i > currentFocusIndex; i--) {\n      const previousElement = this.focusableItems[i];\n\n      if (!this.isRadioButton(previousElement)) {\n        return previousElement;\n      } // Element is a radio button, but not in same group\n\n\n      if (previousElement.name !== itemWithFocus.name) {\n        return this.getSelectedRadioInGroup(previousElement);\n      }\n    } // Still no element found: we have only radio buttons in the same group\n\n\n    return this.getSelectedRadioInGroup(itemWithFocus);\n  }\n\n  previousFocusableItem(itemWithFocus) {\n    const currentFocusIndex = this.getItemIndex(itemWithFocus);\n\n    if (!this.isRadioButton(itemWithFocus)) {\n      let previousFocusIndex = currentFocusIndex - 1; // Wrap around\n\n      if (previousFocusIndex < 0) {\n        previousFocusIndex = this.focusableItems.length - 1;\n      }\n\n      return this.getSelectedRadioInGroup(this.focusableItems[previousFocusIndex]);\n    }\n\n    return this.previousFocusableRadioButton(itemWithFocus);\n  }\n\n  nextFocusableRadioButton(itemWithFocus) {\n    const currentFocusIndex = this.getItemIndex(itemWithFocus); // Next focusable item should not be a radio button in same group\n\n    for (let i = currentFocusIndex + 1; i < this.focusableItems.length; i++) {\n      const nextElement = this.focusableItems[i];\n\n      if (!this.isRadioButton(nextElement)) {\n        return nextElement;\n      } // Element is a radio button, but not in same group\n\n\n      if (nextElement.name !== itemWithFocus.name) {\n        return this.getSelectedRadioInGroup(nextElement);\n      }\n    } // All the next items are in the same radio group, start from beginning\n\n\n    for (let i = 0; i < currentFocusIndex; i++) {\n      const nextElement = this.focusableItems[i];\n\n      if (!this.isRadioButton(nextElement)) {\n        return nextElement;\n      } // Element is a radio button, but not in same group\n\n\n      if (nextElement.name !== itemWithFocus.name) {\n        return this.getSelectedRadioInGroup(nextElement);\n      }\n    } // Still no element found: we have only radio buttons in the same group\n\n\n    return this.getSelectedRadioInGroup(itemWithFocus);\n  }\n\n  nextFocusableItem(itemWithFocus) {\n    const currentFocusIndex = this.getItemIndex(itemWithFocus);\n\n    if (!this.isRadioButton(itemWithFocus)) {\n      let nextFocusIndex = currentFocusIndex + 1; // Wrap around\n\n      if (nextFocusIndex > this.focusableItems.length - 1) {\n        nextFocusIndex = 0;\n      }\n\n      return this.getSelectedRadioInGroup(this.focusableItems[nextFocusIndex]);\n    }\n\n    return this.nextFocusableRadioButton(itemWithFocus);\n  } // If user tabbed into a radio group, we need to focus the selected radio button in the group\n\n\n  getSelectedRadioInGroup(item) {\n    if (!this.isRadioButton(item)) {\n      return item;\n    }\n\n    const currentFocusIndex = this.getItemIndex(item);\n    const radioGrouItems = [];\n    let i;\n\n    for (i = currentFocusIndex; i < this.focusableItems.length; i++) {\n      if (this.focusableItems[i].name === item.name) {\n        radioGrouItems.push(this.focusableItems[i]);\n      } else {\n        break; // Element is not in radio group, no need to continue loop\n      }\n    }\n\n    for (i = currentFocusIndex - 1; i >= 0; i--) {\n      if (this.focusableItems[i].name === item.name) {\n        radioGrouItems.push(this.focusableItems[i]);\n      } else {\n        break; // Element is not in radio group, no need to continue loop\n      }\n    }\n\n    const selectedItems = radioGrouItems.filter(i => i.checked);\n\n    if (selectedItems.length === 0) {\n      return item; // No element in this group is selected\n    }\n\n    return selectedItems[0];\n  }\n\n  getItemIndex(item) {\n    return this.focusableItems.indexOf(item);\n  }\n\n  isRadioButton(element) {\n    return element.type === 'radio';\n  }\n\n}\nexport default TrapFocus;","map":null,"metadata":{},"sourceType":"module"}