{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst immer_1 = __importStar(require(\"immer\"));\n\nconst fhir_1 = require(\"../types/fhir\");\n\nconst constants_1 = require(\"@helsenorge/toolkit/constants\");\n\nconst form_1 = require(\"../actions/form\");\n\nconst generateQuestionnaireResponse_1 = require(\"../actions/generateQuestionnaireResponse\");\n\nconst newValue_1 = require(\"../actions/newValue\");\n\nconst syncQuestionnaireResponse_1 = require(\"../actions/syncQuestionnaireResponse\");\n\nconst createQuestionnaireResponseAnswer_1 = require(\"../util/createQuestionnaireResponseAnswer\");\n\nconst extension_1 = require(\"../util/extension\");\n\nconst index_1 = require(\"../util/index\");\n\nconst skjemautfyller_core_1 = require(\"../util/skjemautfyller-core\");\n\nimmer_1.enableES5();\nconst initialState = {\n  FormData: {\n    Content: null\n  },\n  FormDefinition: {\n    Content: null\n  },\n  Language: constants_1.Languages.NORWEGIAN.toLowerCase()\n};\n\nfunction reducer() {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case newValue_1.NEW_VALUE:\n      return processNewValueAction(action, state);\n\n    case newValue_1.REMOVE_ATTACHMENT_VALUE:\n      return processRemoveAttachmentValueAction(action, state);\n\n    case newValue_1.REMOVE_CODING_VALUE:\n      return processRemoveCodingValueAction(action, state);\n\n    case newValue_1.NEW_CODINGSTRING_VALUE:\n      return processNewCodingStringValueAction(action, state);\n\n    case newValue_1.REMOVE_CODINGSTRING_VALUE:\n      return processRemoveCodingStringValueAction(action, state);\n\n    case newValue_1.ADD_REPEAT_ITEM:\n      return processAddRepeatItemAction(action, state);\n\n    case newValue_1.DELETE_REPEAT_ITEM:\n      return processDeleteRepeatItemAction(action, state);\n\n    case form_1.SET_SKJEMA_DEFINITION:\n      return processSetSkjemaDefinition(action, state);\n\n    default:\n      return state;\n  }\n}\n\nexports.default = reducer;\n\nfunction getFormData(state) {\n  if (!state.skjemautfyller.form.FormData) {\n    return null;\n  }\n\n  return state.skjemautfyller.form.FormData;\n}\n\nexports.getFormData = getFormData;\n\nfunction getArrayToAddGroupTo(itemToAddTo) {\n  if (!itemToAddTo) {\n    return undefined;\n  }\n\n  if (itemToAddTo.answer) {\n    return itemToAddTo.answer[0].item;\n  } else if (itemToAddTo.item) {\n    return itemToAddTo.item;\n  }\n}\n\nfunction processAddRepeatItemAction(action, state) {\n  return immer_1.default(state, draft => {\n    if (!action.parentPath) {\n      return state;\n    }\n\n    let arrayToAddItemTo = [];\n\n    if (action.parentPath.length === 0 && draft.FormData.Content) {\n      arrayToAddItemTo = draft.FormData.Content.item;\n    } else if (action.parentPath.length > 0) {\n      const itemToAddTo = skjemautfyller_core_1.getResponseItemWithPath(action.parentPath, draft.FormData);\n      arrayToAddItemTo = getArrayToAddGroupTo(itemToAddTo);\n    }\n\n    if (!arrayToAddItemTo || arrayToAddItemTo.length === 0) {\n      return;\n    }\n\n    if (!action.responseItems || action.responseItems.length === 0) {\n      return;\n    }\n\n    const newItem = copyItem(action.responseItems[0], undefined, draft.FormDefinition.Content);\n\n    if (!newItem) {\n      return;\n    }\n\n    const indexToInsert = arrayToAddItemTo.map(o => o.linkId).lastIndexOf(newItem.linkId);\n    arrayToAddItemTo.splice(indexToInsert + 1, 0, newItem);\n  });\n}\n\nfunction processDeleteRepeatItemAction(action, state) {\n  return immer_1.default(state, draft => {\n    if (!action.itemPath) {\n      return state;\n    }\n\n    let arrayToDeleteItem = [];\n\n    if (action.itemPath.length === 1 && draft.FormData.Content) {\n      arrayToDeleteItem = draft.FormData.Content.item;\n    } else if (action.itemPath.length > 0) {\n      const parentPath = action.itemPath.slice(0, -1);\n      const itemToAddTo = skjemautfyller_core_1.getResponseItemWithPath(parentPath, draft.FormData);\n      arrayToDeleteItem = getArrayToAddGroupTo(itemToAddTo);\n    }\n\n    if (!arrayToDeleteItem || arrayToDeleteItem.length === 0) {\n      return;\n    }\n\n    if (!action.item) {\n      return;\n    }\n\n    const definitionLinkId = action.item.linkId;\n    const index = action.itemPath[action.itemPath.length - 1].index;\n    let itemIndexInArray = 0;\n\n    for (let i = 0; i <= arrayToDeleteItem.length - 1; i++) {\n      if (arrayToDeleteItem[i].linkId === definitionLinkId) {\n        if (itemIndexInArray === index) {\n          arrayToDeleteItem.splice(i, 1);\n          break;\n        }\n\n        itemIndexInArray++;\n      }\n    }\n  });\n}\n\nfunction copyItem(source, target, questionnaire) {\n  if (!target) {\n    target = {\n      linkId: source.linkId\n    };\n\n    if (source.text) {\n      target.text = source.text;\n    }\n  }\n\n  for (let i = 0; source.item && i < source.item.length; i++) {\n    if (!target.item) {\n      target.item = [];\n    }\n\n    const newResponseItem = {\n      linkId: source.item[i].linkId\n    };\n\n    if (source.item[i].text) {\n      newResponseItem.text = source.item[i].text;\n    }\n\n    const numberOfItemsWithSameLinkId = target.item.filter(item => item.linkId === newResponseItem.linkId).length;\n\n    if (numberOfItemsWithSameLinkId > 0) {\n      const defItem = skjemautfyller_core_1.getQuestionnaireDefinitionItem(newResponseItem.linkId, questionnaire.item);\n      const minOccurs = defItem ? extension_1.getMinOccursExtensionValue(defItem) || 1 : 1;\n\n      if (numberOfItemsWithSameLinkId >= minOccurs) {\n        continue;\n      }\n    }\n\n    target.item.push(newResponseItem);\n    copyItem(source.item[i], newResponseItem, questionnaire);\n  }\n\n  const defItem = skjemautfyller_core_1.getQuestionnaireDefinitionItem(source.linkId, questionnaire.item);\n\n  if (defItem && defItem.type !== 'attachment') {\n    for (let i = 0; source.answer && i < source.answer.length; i++) {\n      if (!target.answer) {\n        target.answer = [];\n      }\n\n      const answer = source.answer[i];\n      const targetAnswer = {\n        item: []\n      };\n\n      for (let j = 0; answer && answer.item && j < answer.item.length; j++) {\n        const newResponseItem = {\n          linkId: answer.item[j].linkId\n        };\n        targetAnswer.item.push(newResponseItem);\n        target.text = source.text;\n        copyItem(answer.item[j], newResponseItem, questionnaire);\n      }\n\n      target.answer.push(targetAnswer);\n    }\n  }\n\n  return target;\n}\n\nfunction runEnableWhen(action, state, draft) {\n  if (action.item && draft.FormData.Content) {\n    const qrItemsToClear = [];\n    const responseItems = skjemautfyller_core_1.getResponseItems(draft.FormData);\n    const calculatedResponseItems = JSON.parse(JSON.stringify(responseItems));\n    calculateEnableWhenItemsToClear([action.item], state.FormData, state.FormDefinition, action.itemPath, qrItemsToClear, calculatedResponseItems);\n\n    if (responseItems && responseItems.length > 0) {\n      for (let w = 0; w < qrItemsToClear.length; w++) {\n        const qrItemWithEnableWhen = getResponseItemWithLinkIdPossiblyContainingRepeat(qrItemsToClear[w].linkId, responseItems, action.itemPath);\n\n        if (qrItemWithEnableWhen) {\n          removeAddedRepeatingItems(qrItemsToClear[w].qItemWithEnableWhen, qrItemWithEnableWhen, responseItems);\n          wipeAnswerItems(qrItemWithEnableWhen, qrItemsToClear[w].qItemWithEnableWhen);\n        } else {\n          const qrItemWithEnableWhen = skjemautfyller_core_1.getResponseItemAndPathWithLinkId(qrItemsToClear[w].linkId, draft.FormData.Content);\n\n          for (let r = 0; r < qrItemWithEnableWhen.length; r++) {\n            removeAddedRepeatingItems(qrItemsToClear[w].qItemWithEnableWhen, qrItemWithEnableWhen[r].item, responseItems);\n            wipeAnswerItems(qrItemWithEnableWhen[r].item, qrItemsToClear[w].qItemWithEnableWhen);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction processRemoveCodingValueAction(action, state) {\n  return immer_1.default(state, draft => {\n    const responseItem = skjemautfyller_core_1.getResponseItemWithPath(action.itemPath || [], draft.FormData);\n\n    if (!responseItem || !responseItem.answer || !responseItem.answer.length) {\n      return;\n    }\n\n    if (action.valueCoding) {\n      responseItem.answer = responseItem.answer.map(el => {\n        if (el && el.item && el.valueCoding && el.valueCoding.code && action.valueCoding) {\n          return {\n            item: el.item\n          };\n        }\n\n        return el;\n      }).filter(el => {\n        if (el && el.valueCoding && el.valueCoding.code && action.valueCoding) {\n          return el.valueCoding.code !== action.valueCoding.code;\n        }\n\n        return true;\n      });\n\n      if (responseItem.answer.length === 0) {\n        delete responseItem.answer;\n      }\n    }\n\n    runEnableWhen(action, state, draft);\n  });\n}\n\nfunction processRemoveCodingStringValueAction(action, state) {\n  return immer_1.default(state, draft => {\n    const responseItem = skjemautfyller_core_1.getResponseItemWithPath(action.itemPath || [], draft.FormData);\n\n    if (!responseItem || !responseItem.answer || !responseItem.answer.length) {\n      return;\n    }\n\n    responseItem.answer = responseItem.answer.filter(el => {\n      return el && el.valueString ? false : true;\n    });\n\n    if (responseItem.answer.length === 0) {\n      delete responseItem.answer;\n    }\n\n    runEnableWhen(action, state, draft);\n  });\n}\n\nfunction processRemoveAttachmentValueAction(action, state) {\n  return immer_1.default(state, draft => {\n    const responseItem = skjemautfyller_core_1.getResponseItemWithPath(action.itemPath || [], draft.FormData);\n\n    if (!responseItem || !responseItem.answer || !responseItem.answer.length) {\n      return;\n    }\n\n    if (action.valueAttachment) {\n      const attachmentToRemove = action.valueAttachment.url;\n      responseItem.answer = responseItem.answer.filter(el => el && el.valueAttachment && el.valueAttachment.url !== attachmentToRemove);\n    }\n\n    if (responseItem.answer.length === 0) {\n      delete responseItem.answer;\n    }\n  });\n}\n\nfunction processNewValueAction(action, state) {\n  return immer_1.default(state, draft => {\n    const responseItem = skjemautfyller_core_1.getResponseItemWithPath(action.itemPath || [], draft.FormData);\n\n    if (!responseItem) {\n      return;\n    }\n\n    let hasAnswer = false;\n\n    if (!responseItem.answer) {\n      responseItem.answer = [];\n    }\n\n    let answer = responseItem.answer[0];\n\n    if (!answer) {\n      answer = {};\n      responseItem.answer.push(answer);\n    }\n\n    if (action.valueBoolean !== undefined) {\n      hasAnswer = true;\n      answer.valueBoolean = action.valueBoolean;\n    }\n\n    if (action.valueDecimal !== undefined && !isNaN(action.valueDecimal)) {\n      hasAnswer = true;\n      answer.valueDecimal = action.valueDecimal;\n    }\n\n    if (action.valueInteger !== undefined && !isNaN(action.valueInteger)) {\n      hasAnswer = true;\n      answer.valueInteger = action.valueInteger;\n    }\n\n    if (!index_1.isStringEmpty(action.valueDate)) {\n      hasAnswer = true;\n      answer.valueDate = action.valueDate;\n    }\n\n    if (!index_1.isStringEmpty(action.valueDateTime)) {\n      hasAnswer = true;\n      answer.valueDateTime = action.valueDateTime;\n    }\n\n    if (!index_1.isStringEmpty(action.valueTime)) {\n      hasAnswer = true;\n      answer.valueTime = action.valueTime;\n    }\n\n    if (!index_1.isStringEmpty(action.valueString)) {\n      hasAnswer = true;\n      answer.valueString = action.valueString;\n    }\n\n    if (action.valueQuantity && action.valueQuantity.value !== undefined) {\n      hasAnswer = true;\n      answer.valueQuantity = action.valueQuantity;\n    }\n\n    if (action.valueCoding) {\n      hasAnswer = true;\n      const coding = {\n        code: action.valueCoding.code,\n        display: action.valueCoding.display\n      };\n\n      if (action.valueCoding.system !== undefined && action.valueCoding.system !== null) {\n        coding.system = action.valueCoding.system;\n      }\n\n      if (action.multipleAnswers) {\n        if (Object.keys(answer).length === 0) {\n          answer.valueCoding = coding;\n        } else {\n          const newAnswer = {};\n          newAnswer.valueCoding = coding;\n          responseItem.answer.push(newAnswer);\n        }\n      } else {\n        answer.valueCoding = coding;\n      }\n    }\n\n    if (action.valueAttachment && Object.keys(action.valueAttachment).length > 0) {\n      hasAnswer = true;\n      const attachment = {\n        url: action.valueAttachment.url,\n        title: action.valueAttachment.title,\n        data: action.valueAttachment.data,\n        contentType: action.valueAttachment.contentType,\n        creation: action.valueAttachment.creation,\n        hash: action.valueAttachment.hash,\n        size: action.valueAttachment.size,\n        language: action.valueAttachment.language\n      };\n\n      if (action.multipleAnswers) {\n        if (Object.keys(answer).length === 0) {\n          answer.valueAttachment = attachment;\n        } else {\n          const newAnswer = {};\n          newAnswer.valueAttachment = attachment;\n          responseItem.answer.push(newAnswer);\n        }\n      } else {\n        answer.valueAttachment = attachment;\n      }\n    }\n\n    if (!hasAnswer) {\n      nullAnswerValue(answer);\n\n      if (Object.keys(answer).filter(prop => !prop.startsWith('value')).length === 0) {\n        if (responseItem.answer && responseItem.answer.length === 1) {\n          delete responseItem.answer;\n        }\n      }\n    }\n\n    runEnableWhen(action, state, draft);\n  });\n}\n\nfunction processNewCodingStringValueAction(action, state) {\n  return immer_1.default(state, draft => {\n    const responseItem = skjemautfyller_core_1.getResponseItemWithPath(action.itemPath || [], draft.FormData);\n\n    if (!responseItem) {\n      return;\n    }\n\n    if (!responseItem.answer) {\n      responseItem.answer = [];\n    }\n\n    if (!index_1.isStringEmpty(action.valueString)) {\n      let found = -1;\n\n      for (let i = 0; i < responseItem.answer.length; i++) {\n        if (!index_1.isStringEmpty(responseItem.answer[i].valueString)) {\n          found = i;\n          break;\n        }\n      }\n\n      const newAnswer = {\n        valueString: action.valueString\n      };\n\n      if (found >= 0) {\n        responseItem.answer[found] = newAnswer;\n      } else {\n        responseItem.answer.push(newAnswer);\n      }\n    }\n  });\n}\n\nfunction getResponseItemWithLinkIdPossiblyContainingRepeat(linkId, items, path) {\n  const findResponseItem = (linkId, items) => {\n    for (const item of items) {\n      const result = skjemautfyller_core_1.getQuestionnaireResponseItemWithLinkid(linkId, item, path || []);\n      if (result) return result;\n    }\n  };\n\n  return findResponseItem(linkId, items);\n}\n\nfunction calculateEnableWhenItemsToClear(items, formData, formDefinition, path, qrItemsToClear, responseItems) {\n  if (!items || !formData.Content) {\n    return;\n  }\n\n  const definitionItems = skjemautfyller_core_1.getDefinitionItems(formDefinition);\n\n  if (!responseItems || responseItems.length === 0) {\n    return;\n  }\n\n  const qitemsWithEnableWhen = [];\n\n  for (let i = 0; i < items.length; i++) {\n    if (definitionItems) {\n      qitemsWithEnableWhen.push(...getItemsWithEnableWhen(items[i].linkId, definitionItems));\n    }\n  }\n\n  if (!qitemsWithEnableWhen || qitemsWithEnableWhen.length === 0) {\n    return;\n  }\n\n  for (const qItemWithEnableWhen of qitemsWithEnableWhen) {\n    const enableWhenClauses = qItemWithEnableWhen.enableWhen;\n\n    if (!enableWhenClauses) {\n      continue;\n    }\n\n    const qrItemsWithEnableWhen = skjemautfyller_core_1.getResponseItemAndPathWithLinkId(qItemWithEnableWhen.linkId, formData.Content);\n\n    for (const qrItemWithEnableWhen of qrItemsWithEnableWhen) {\n      const enableMatches = [];\n      const enableBehavior = qItemWithEnableWhen.enableBehavior;\n      enableWhenClauses.forEach(enableWhen => {\n        const enableWhenQuestionItem = skjemautfyller_core_1.getQuestionnaireDefinitionItem(enableWhen.question, definitionItems);\n        if (!enableWhenQuestionItem) return;\n        const responseItem = getResponseItemWithLinkIdPossiblyContainingRepeat(enableWhen.question, responseItems, path);\n\n        if (responseItem) {\n          const matchesAnswer = skjemautfyller_core_1.enableWhenMatchesAnswer(enableWhen, responseItem.answer);\n          enableMatches.push(matchesAnswer);\n        }\n      });\n      const enable = enableBehavior === fhir_1.QuestionnaireItemEnableBehaviorCodes.ALL ? enableMatches.every(x => x === true) : enableMatches.some(x => x === true);\n\n      if (!enable) {\n        const item = getResponseItemWithLinkIdPossiblyContainingRepeat(qrItemWithEnableWhen.item.linkId, responseItems, path);\n\n        if (item) {\n          removeAddedRepeatingItems(qItemWithEnableWhen, item, responseItems);\n          wipeAnswerItems(item, qItemWithEnableWhen);\n        }\n\n        qrItemsToClear.push({\n          qItemWithEnableWhen: qItemWithEnableWhen,\n          linkId: qrItemWithEnableWhen.item.linkId\n        });\n      }\n    }\n  }\n\n  calculateEnableWhenItemsToClear(qitemsWithEnableWhen, formData, formDefinition, path, qrItemsToClear, responseItems);\n  qitemsWithEnableWhen.forEach(i => i.item && calculateEnableWhenItemsToClear(i.item, formData, formDefinition, path, qrItemsToClear, responseItems));\n}\n\nfunction removeAddedRepeatingItems(defItem, repeatingItemLinkId, responseItems) {\n  if (defItem.repeats) {\n    const arrayToDeleteItem = skjemautfyller_core_1.getArrayContainingResponseItemFromItems(repeatingItemLinkId.linkId, responseItems);\n    const minOccurs = extension_1.getMinOccursExtensionValue(defItem);\n\n    if (arrayToDeleteItem) {\n      const keepThreshold = minOccurs ? minOccurs : 1;\n      let repeatingItemIndex = arrayToDeleteItem.filter(item => item.linkId === repeatingItemLinkId.linkId).length;\n\n      for (let i = arrayToDeleteItem.length - 1; i >= 0; i--) {\n        const e = arrayToDeleteItem[i];\n\n        if (e.linkId === defItem.linkId) {\n          if (repeatingItemIndex > keepThreshold) {\n            arrayToDeleteItem.splice(i, 1);\n          }\n\n          repeatingItemIndex--;\n        }\n      }\n    }\n  }\n}\n\nfunction getFormDefinition(state) {\n  if (!state.skjemautfyller.form.FormDefinition) {\n    return null;\n  }\n\n  return state.skjemautfyller.form.FormDefinition;\n}\n\nexports.getFormDefinition = getFormDefinition;\n\nfunction wipeAnswerItems(answerItem, item) {\n  if (!answerItem || !item) {\n    return undefined;\n  }\n\n  if (answerItem.answer) {\n    answerItem.answer.forEach(answer => {\n      resetAnswerValue(answer, item);\n    });\n\n    for (let i = answerItem.answer.length - 1; i >= 0; i--) {\n      const a = answerItem.answer[i];\n      if (Object.keys(a).length === 0) answerItem.answer.splice(i, 1);\n    }\n  }\n\n  for (let i = 0; answerItem.item && item.item && i < answerItem.item.length; i++) {\n    wipeAnswerItems(answerItem.item[i], item.item[i]);\n  }\n\n  for (let i = 0; answerItem.answer && item.item && i < answerItem.answer.length; i++) {\n    const nestedItems = answerItem.answer[i].item;\n\n    if (nestedItems && nestedItems.length > 0) {\n      for (let j = 0; j < nestedItems.length; j++) {\n        wipeAnswerItems(nestedItems[j], item.item[i]);\n      }\n    }\n  }\n}\n\nfunction resetAnswerValue(answer, item) {\n  const initialAnswer = createQuestionnaireResponseAnswer_1.createQuestionnaireResponseAnswer(item);\n  nullAnswerValue(answer, initialAnswer);\n}\n\nfunction nullAnswerValue(answer) {\n  let initialAnswer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  if (!answer) {\n    return undefined;\n  }\n\n  if (answer.valueBoolean !== undefined) {\n    initialAnswer ? answer.valueBoolean = initialAnswer.valueBoolean : answer.valueBoolean = false;\n  } else if (answer.valueCoding !== undefined) {\n    initialAnswer ? answer.valueCoding = initialAnswer.valueCoding : delete answer.valueCoding;\n  } else if (answer.valueDate !== undefined) {\n    initialAnswer ? answer.valueDate = initialAnswer.valueDate : delete answer.valueDate;\n  } else if (answer.valueDateTime !== undefined) {\n    initialAnswer ? answer.valueDateTime = initialAnswer.valueDateTime : delete answer.valueDateTime;\n  } else if (answer.valueDecimal !== undefined) {\n    initialAnswer ? answer.valueDecimal = initialAnswer.valueDecimal : delete answer.valueDecimal;\n  } else if (answer.valueInteger !== undefined) {\n    initialAnswer ? answer.valueInteger = initialAnswer.valueInteger : delete answer.valueInteger;\n  } else if (answer.valueString !== undefined) {\n    initialAnswer ? answer.valueString = initialAnswer.valueString : delete answer.valueString;\n  } else if (answer.valueTime !== undefined) {\n    initialAnswer ? answer.valueTime = initialAnswer.valueTime : delete answer.valueTime;\n  }\n}\n\nexports.nullAnswerValue = nullAnswerValue;\n\nfunction getItemsWithEnableWhen(linkId, definitionItems) {\n  const relatedItems = [];\n\n  const getQuestionnaireItemHasEnableWhenLinkid = function (linkId, definitionItem) {\n    if (!definitionItem) {\n      return undefined;\n    }\n\n    const hasItems = definitionItem.item && definitionItem.item.length > 0;\n\n    if (!hasItems) {\n      return undefined;\n    }\n\n    const itemsEnableWhenMatchLinkId = getItemEnableWhenQuestionMatchIdFromArray(linkId, definitionItem.item);\n\n    if (itemsEnableWhenMatchLinkId && itemsEnableWhenMatchLinkId.length >= 0) {\n      itemsEnableWhenMatchLinkId.forEach(i => {\n        relatedItems.push(i);\n      });\n    }\n\n    for (let i = 0; definitionItem.item && i < definitionItem.item.length; i++) {\n      getQuestionnaireItemHasEnableWhenLinkid(linkId, definitionItem.item[i]);\n    }\n  };\n\n  for (let k = 0; k < definitionItems.length; k++) {\n    const enableWhen = definitionItems[k].enableWhen;\n\n    if (enableWhen) {\n      for (let n = 0; n < enableWhen.length; n++) {\n        if (enableWhen[n].question === linkId) {\n          relatedItems.push(definitionItems[k]);\n        }\n      }\n    }\n\n    getQuestionnaireItemHasEnableWhenLinkid(linkId, definitionItems[k]);\n  }\n\n  return relatedItems;\n}\n\nfunction getItemEnableWhenQuestionMatchIdFromArray(linkId, definitionItems) {\n  if (!definitionItems) {\n    return [];\n  }\n\n  const matchedItems = [];\n\n  for (let i = 0; i < definitionItems.length; i++) {\n    const enableWhen = definitionItems[i].enableWhen;\n\n    if (!enableWhen) {\n      continue;\n    }\n\n    for (let j = 0; j < enableWhen.length; j++) {\n      if (enableWhen[j].question === linkId) {\n        matchedItems.push(definitionItems[i]);\n      }\n    }\n  }\n\n  return matchedItems;\n}\n\nfunction processSetSkjemaDefinition(action, state) {\n  if (!action.questionnaire) {\n    return state;\n  }\n\n  const formDefinition = {\n    Content: action.questionnaire\n  };\n  let formData;\n\n  if (action.questionnaireResponse && action.syncQuestionnaireResponse) {\n    formData = {\n      Content: syncQuestionnaireResponse_1.syncQuestionnaireResponse(action.questionnaire, action.questionnaireResponse)\n    };\n  } else if (action.questionnaireResponse) {\n    formData = {\n      Content: action.questionnaireResponse\n    };\n  } // override stale formData slice\n  // else if (state.FormData === initialState.FormData) {\n  //     formData = { Content: generateQuestionnaireResponse_1.generateQuestionnaireResponse(action.questionnaire) };\n  // }\n  else {\n    // formData = state.FormData;\n    formData = {\n      Content: generateQuestionnaireResponse_1.generateQuestionnaireResponse(action.questionnaire)\n    };\n  }\n\n  return Object.assign(Object.assign({}, state), {\n    FormDefinition: formDefinition,\n    FormData: formData,\n    Language: action.language || state.Language\n  });\n}","map":null,"metadata":{},"sourceType":"script"}