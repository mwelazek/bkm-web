{"ast":null,"code":"const util = require(\"./utilities\");\n\nconst misc = require(\"./misc\");\n\nconst engine = {}; // Cache for rewritten RegExp patterns\n\nconst cachedRegExp = {};\n/**\n * Rewrites RegExp pattern to support single-line mode (dotAll) in IE11:\n * To do that we replace \".\" with \"[^]\" in source RegExp pattern,\n * except where \".\" is escaped or is inside unescaped [].\n * Another way to do the same is using package regexpu-core\n * or packages regjsparser/regjsgen.\n * @param {string} pattern - source RegExp pattern\n * @return {string}\n */\n\nfunction rewritePatternForDotAll(pattern) {\n  if (!cachedRegExp[pattern]) {\n    cachedRegExp[pattern] = pattern.replace(/\\./g, (_, offset, entirePattern) => {\n      // The preceding part of the string\n      const precedingPart = entirePattern.substr(0, offset); // The preceding part of the string without escaped characters: '\\', '[' or ']'\n\n      const cleanPrecedingPart = precedingPart.replace(/\\\\\\\\/g, '').replace(/\\\\[\\][]/g, ''); // Check if '.' is escaped\n\n      const escaped = cleanPrecedingPart[cleanPrecedingPart.length - 1] === '\\\\'; // The last index of unescaped '['\n\n      const lastIndexOfOpenBracket = cleanPrecedingPart.lastIndexOf('['); // The last index of unescaped ']'\n\n      const lastIndexOfCloseBracket = cleanPrecedingPart.lastIndexOf(']');\n      return escaped || lastIndexOfOpenBracket > lastIndexOfCloseBracket ? '.' : '[^]';\n    });\n  }\n\n  return cachedRegExp[pattern];\n}\n\nengine.indexOf = function (coll, substr) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.indexOf(substr);\n};\n\nengine.substring = function (coll, start, length) {\n  const str = misc.singleton(coll, 'String');\n\n  if (util.isEmpty(str) || util.isEmpty(start) || start < 0 || start >= str.length) {\n    return [];\n  }\n\n  if (length === undefined || util.isEmpty(length)) {\n    return str.substring(start);\n  }\n\n  return str.substring(start, start + length);\n};\n\nengine.startsWith = function (coll, prefix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(prefix) || util.isEmpty(str) ? [] : str.startsWith(prefix);\n};\n\nengine.endsWith = function (coll, postfix) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(postfix) || util.isEmpty(str) ? [] : str.endsWith(postfix);\n};\n\nengine.containsFn = function (coll, substr) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.includes(substr);\n};\n\nengine.upper = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toUpperCase();\n};\n\nengine.lower = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.toLowerCase();\n}; // Check if dotAll is supported.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll for details.\n\n\nconst dotAllIsSupported = new RegExp('').dotAll === false;\n\nif (dotAllIsSupported) {\n  engine.matches = function (coll, regex) {\n    const str = misc.singleton(coll, 'String');\n\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n\n    const reg = new RegExp(regex, 's');\n    return reg.test(str);\n  };\n} else {\n  engine.matches = function (coll, regex) {\n    const str = misc.singleton(coll, 'String');\n\n    if (util.isEmpty(regex) || util.isEmpty(str)) {\n      return [];\n    }\n\n    const reg = new RegExp(rewritePatternForDotAll(regex));\n    return reg.test(str);\n  };\n}\n\nengine.replace = function (coll, pattern, repl) {\n  const str = misc.singleton(coll, 'String');\n\n  if (util.isEmpty(pattern) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n\n  const reg = new RegExp(util.escapeStringForRegExp(pattern), 'g');\n  return str.replace(reg, repl);\n};\n\nengine.replaceMatches = function (coll, regex, repl) {\n  const str = misc.singleton(coll, 'String');\n\n  if (util.isEmpty(regex) || util.isEmpty(repl) || util.isEmpty(str)) {\n    return [];\n  }\n\n  const reg = new RegExp(regex, 'g');\n  return str.replace(reg, repl);\n};\n\nengine.length = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.length;\n};\n\nengine.toChars = function (coll) {\n  const str = misc.singleton(coll, 'String');\n  return util.isEmpty(str) ? [] : str.split('');\n};\n\nmodule.exports = engine;","map":null,"metadata":{},"sourceType":"script"}