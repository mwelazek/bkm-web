{"ast":null,"code":"// Contains the FHIRPath Filtering and Projection functions.  (Section 5.2 of\n// the FHIRPath 1.0.0 specification).\n\n/**\n *  Adds the filtering and projection functions to the given FHIRPath engine.\n */\nconst util = require('./utilities');\n\nconst {\n  TypeInfo,\n  ResourceNode\n} = require('./types');\n\nvar engine = {};\n\nengine.whereMacro = function (parentData, expr) {\n  if (parentData !== false && !parentData) {\n    return [];\n  }\n\n  return util.flatten(parentData.filter((x, i) => {\n    this.$index = i;\n    return expr(x)[0];\n  }));\n};\n\nengine.extension = function (parentData, url) {\n  if (parentData !== false && !parentData || !url) {\n    return [];\n  }\n\n  return util.flatten(parentData.map((x, i) => {\n    this.$index = i;\n    const extensions = x && (x.data && x.data.extension || x._data && x._data.extension);\n\n    if (extensions) {\n      return extensions.filter(extension => extension.url === url).map(x => ResourceNode.makeResNode(x, 'Extension'));\n    }\n\n    return [];\n  }));\n};\n\nengine.selectMacro = function (data, expr) {\n  if (data !== false && !data) {\n    return [];\n  }\n\n  return util.flatten(data.map((x, i) => {\n    this.$index = i;\n    return expr(x);\n  }));\n};\n\nengine.repeatMacro = function (parentData, expr) {\n  if (parentData !== false && !parentData) {\n    return [];\n  }\n\n  var res = [];\n  var items = parentData;\n  var next = null;\n  var lres = null;\n\n  while (items.length != 0) {\n    next = items.shift();\n    lres = expr(next);\n\n    if (lres) {\n      res = res.concat(lres);\n      items = items.concat(lres);\n    }\n  }\n\n  return res;\n}; //TODO: behavior on object?\n\n\nengine.singleFn = function (x) {\n  if (x.length == 1) {\n    return x;\n  } else if (x.length == 0) {\n    return [];\n  } else {\n    //TODO: should throw error?\n    return {\n      $status: \"error\",\n      $error: \"Expected single\"\n    };\n  }\n};\n\nengine.firstFn = function (x) {\n  return x[0];\n};\n\nengine.lastFn = function (x) {\n  return x[x.length - 1];\n};\n\nengine.tailFn = function (x) {\n  return x.slice(1, x.length);\n};\n\nengine.takeFn = function (x, n) {\n  return x.slice(0, n);\n};\n\nengine.skipFn = function (x, num) {\n  return x.slice(num, x.length);\n};\n\nengine.ofTypeFn = function (coll, typeInfo) {\n  return coll.filter(value => {\n    return TypeInfo.fromValue(value).is(typeInfo);\n  });\n};\n\nmodule.exports = engine;","map":null,"metadata":{},"sourceType":"script"}