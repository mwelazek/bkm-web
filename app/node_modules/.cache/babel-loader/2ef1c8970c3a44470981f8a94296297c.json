{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n// Represents an executor for a sequence of lexer actions which traversed during\n// the matching operation of a lexer rule (token).\n//\n// <p>The executor tracks position information for position-dependent lexer actions\n// efficiently, ensuring that actions appearing only at the end of the rule do\n// not cause bloating of the {@link DFA} created for the lexer.</p>\nvar hashStuff = require(\"../Utils\").hashStuff;\n\nvar LexerIndexedCustomAction = require('./LexerAction').LexerIndexedCustomAction;\n\nfunction LexerActionExecutor(lexerActions) {\n  this.lexerActions = lexerActions === null ? [] : lexerActions; // Caches the result of {@link //hashCode} since the hash code is an element\n  // of the performance-critical {@link LexerATNConfig//hashCode} operation.\n\n  this.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n  // lexerActions]))\n\n  return this;\n} // Creates a {@link LexerActionExecutor} which executes the actions for\n// the input {@code lexerActionExecutor} followed by a specified\n// {@code lexerAction}.\n//\n// @param lexerActionExecutor The executor for actions already traversed by\n// the lexer while matching a token within a particular\n// {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n// though it were an empty executor.\n// @param lexerAction The lexer action to execute after the actions\n// specified in {@code lexerActionExecutor}.\n//\n// @return A {@link LexerActionExecutor} for executing the combine actions\n// of {@code lexerActionExecutor} and {@code lexerAction}.\n\n\nLexerActionExecutor.append = function (lexerActionExecutor, lexerAction) {\n  if (lexerActionExecutor === null) {\n    return new LexerActionExecutor([lexerAction]);\n  }\n\n  var lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);\n  return new LexerActionExecutor(lexerActions);\n}; // Creates a {@link LexerActionExecutor} which encodes the current offset\n// for position-dependent lexer actions.\n//\n// <p>Normally, when the executor encounters lexer actions where\n// {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n// {@link IntStream//seek} on the input {@link CharStream} to set the input\n// position to the <em>end</em> of the current token. This behavior provides\n// for efficient DFA representation of lexer actions which appear at the end\n// of a lexer rule, even when the lexer rule matches a variable number of\n// characters.</p>\n//\n// <p>Prior to traversing a match transition in the ATN, the current offset\n// from the token start index is assigned to all position-dependent lexer\n// actions which have not already been assigned a fixed offset. By storing\n// the offsets relative to the token start index, the DFA representation of\n// lexer actions which appear in the middle of tokens remains efficient due\n// to sharing among tokens of the same length, regardless of their absolute\n// position in the input stream.</p>\n//\n// <p>If the current executor already has offsets assigned to all\n// position-dependent lexer actions, the method returns {@code this}.</p>\n//\n// @param offset The current offset to assign to all position-dependent\n// lexer actions which do not already have offsets assigned.\n//\n// @return A {@link LexerActionExecutor} which stores input stream offsets\n// for all position-dependent lexer actions.\n// /\n\n\nLexerActionExecutor.prototype.fixOffsetBeforeMatch = function (offset) {\n  var updatedLexerActions = null;\n\n  for (var i = 0; i < this.lexerActions.length; i++) {\n    if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n      if (updatedLexerActions === null) {\n        updatedLexerActions = this.lexerActions.concat([]);\n      }\n\n      updatedLexerActions[i] = new LexerIndexedCustomAction(offset, this.lexerActions[i]);\n    }\n  }\n\n  if (updatedLexerActions === null) {\n    return this;\n  } else {\n    return new LexerActionExecutor(updatedLexerActions);\n  }\n}; // Execute the actions encapsulated by this executor within the context of a\n// particular {@link Lexer}.\n//\n// <p>This method calls {@link IntStream//seek} to set the position of the\n// {@code input} {@link CharStream} prior to calling\n// {@link LexerAction//execute} on a position-dependent action. Before the\n// method returns, the input position will be restored to the same position\n// it was in when the method was invoked.</p>\n//\n// @param lexer The lexer instance.\n// @param input The input stream which is the source for the current token.\n// When this method is called, the current {@link IntStream//index} for\n// {@code input} should be the start of the following token, i.e. 1\n// character past the end of the current token.\n// @param startIndex The token start index. This value may be passed to\n// {@link IntStream//seek} to set the {@code input} position to the beginning\n// of the token.\n// /\n\n\nLexerActionExecutor.prototype.execute = function (lexer, input, startIndex) {\n  var requiresSeek = false;\n  var stopIndex = input.index;\n\n  try {\n    for (var i = 0; i < this.lexerActions.length; i++) {\n      var lexerAction = this.lexerActions[i];\n\n      if (lexerAction instanceof LexerIndexedCustomAction) {\n        var offset = lexerAction.offset;\n        input.seek(startIndex + offset);\n        lexerAction = lexerAction.action;\n        requiresSeek = startIndex + offset !== stopIndex;\n      } else if (lexerAction.isPositionDependent) {\n        input.seek(stopIndex);\n        requiresSeek = false;\n      }\n\n      lexerAction.execute(lexer);\n    }\n  } finally {\n    if (requiresSeek) {\n      input.seek(stopIndex);\n    }\n  }\n};\n\nLexerActionExecutor.prototype.hashCode = function () {\n  return this.cachedHashCode;\n};\n\nLexerActionExecutor.prototype.updateHashCode = function (hash) {\n  hash.update(this.cachedHashCode);\n};\n\nLexerActionExecutor.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof LexerActionExecutor)) {\n    return false;\n  } else if (this.cachedHashCode != other.cachedHashCode) {\n    return false;\n  } else if (this.lexerActions.length != other.lexerActions.length) {\n    return false;\n  } else {\n    var numActions = this.lexerActions.length;\n\n    for (var idx = 0; idx < numActions; ++idx) {\n      if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nexports.LexerActionExecutor = LexerActionExecutor;","map":null,"metadata":{},"sourceType":"script"}