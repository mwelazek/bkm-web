{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\nvar Set = require('./Utils').Set;\n\nvar BitSet = require('./Utils').BitSet;\n\nvar Token = require('./Token').Token;\n\nvar ATNConfig = require('./atn/ATNConfig').ATNConfig;\n\nvar Interval = require('./IntervalSet').Interval;\n\nvar IntervalSet = require('./IntervalSet').IntervalSet;\n\nvar RuleStopState = require('./atn/ATNState').RuleStopState;\n\nvar RuleTransition = require('./atn/Transition').RuleTransition;\n\nvar NotSetTransition = require('./atn/Transition').NotSetTransition;\n\nvar WildcardTransition = require('./atn/Transition').WildcardTransition;\n\nvar AbstractPredicateTransition = require('./atn/Transition').AbstractPredicateTransition;\n\nvar pc = require('./PredictionContext');\n\nvar predictionContextFromRuleContext = pc.predictionContextFromRuleContext;\nvar PredictionContext = pc.PredictionContext;\nvar SingletonPredictionContext = pc.SingletonPredictionContext;\n\nfunction LL1Analyzer(atn) {\n  this.atn = atn;\n} //* Special value added to the lookahead sets to indicate that we hit\n//  a predicate during analysis if {@code seeThruPreds==false}.\n///\n\n\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE; //*\n// Calculates the SLL(1) expected lookahead set for each outgoing transition\n// of an {@link ATNState}. The returned array has one element for each\n// outgoing transition in {@code s}. If the closure from transition\n// <em>i</em> leads to a semantic predicate before matching a symbol, the\n// element at index <em>i</em> of the result will be {@code null}.\n//\n// @param s the ATN state\n// @return the expected symbols for each outgoing transition of {@code s}.\n///\n\nLL1Analyzer.prototype.getDecisionLookahead = function (s) {\n  if (s === null) {\n    return null;\n  }\n\n  var count = s.transitions.length;\n  var look = [];\n\n  for (var alt = 0; alt < count; alt++) {\n    look[alt] = new IntervalSet();\n    var lookBusy = new Set();\n    var seeThruPreds = false; // fail to get lookahead upon pred\n\n    this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY, look[alt], lookBusy, new BitSet(), seeThruPreds, false); // Wipe out lookahead for this alternative if we found nothing\n    // or we had a predicate when we !seeThruPreds\n\n\n    if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n      look[alt] = null;\n    }\n  }\n\n  return look;\n}; //*\n// Compute set of tokens that can follow {@code s} in the ATN in the\n// specified {@code ctx}.\n//\n// <p>If {@code ctx} is {@code null} and the end of the rule containing\n// {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n// If {@code ctx} is not {@code null} and the end of the outermost rule is\n// reached, {@link Token//EOF} is added to the result set.</p>\n//\n// @param s the ATN state\n// @param stopState the ATN state to stop at. This can be a\n// {@link BlockEndState} to detect epsilon paths through a closure.\n// @param ctx the complete parser context, or {@code null} if the context\n// should be ignored\n//\n// @return The set of tokens that can follow {@code s} in the ATN in the\n// specified {@code ctx}.\n///\n\n\nLL1Analyzer.prototype.LOOK = function (s, stopState, ctx) {\n  var r = new IntervalSet();\n  var seeThruPreds = true; // ignore preds; get all lookahead\n\n  ctx = ctx || null;\n  var lookContext = ctx !== null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n\n  this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n\n  return r;\n}; //*\n// Compute set of tokens that can follow {@code s} in the ATN in the\n// specified {@code ctx}.\n//\n// <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n// rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n// the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n// {@code true} and {@code stopState} or the end of the outermost rule is\n// reached, {@link Token//EOF} is added to the result set.</p>\n//\n// @param s the ATN state.\n// @param stopState the ATN state to stop at. This can be a\n// {@link BlockEndState} to detect epsilon paths through a closure.\n// @param ctx The outer context, or {@code null} if the outer context should\n// not be used.\n// @param look The result lookahead set.\n// @param lookBusy A set used for preventing epsilon closures in the ATN\n// from causing a stack overflow. Outside code should pass\n// {@code new Set<ATNConfig>} for this argument.\n// @param calledRuleStack A set used for preventing left recursion in the\n// ATN from causing a stack overflow. Outside code should pass\n// {@code new BitSet()} for this argument.\n// @param seeThruPreds {@code true} to true semantic predicates as\n// implicitly {@code true} and \"see through them\", otherwise {@code false}\n// to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n// result if one is encountered.\n// @param addEOF Add {@link Token//EOF} to the result if the end of the\n// outermost context is reached. This parameter has no effect if {@code ctx}\n// is {@code null}.\n///\n\n\nLL1Analyzer.prototype._LOOK = function (s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n  var c = new ATNConfig({\n    state: s,\n    alt: 0,\n    context: ctx\n  }, null);\n\n  if (lookBusy.contains(c)) {\n    return;\n  }\n\n  lookBusy.add(c);\n\n  if (s === stopState) {\n    if (ctx === null) {\n      look.addOne(Token.EPSILON);\n      return;\n    } else if (ctx.isEmpty() && addEOF) {\n      look.addOne(Token.EOF);\n      return;\n    }\n  }\n\n  if (s instanceof RuleStopState) {\n    if (ctx === null) {\n      look.addOne(Token.EPSILON);\n      return;\n    } else if (ctx.isEmpty() && addEOF) {\n      look.addOne(Token.EOF);\n      return;\n    }\n\n    if (ctx !== PredictionContext.EMPTY) {\n      // run thru all possible stack tops in ctx\n      for (var i = 0; i < ctx.length; i++) {\n        var returnState = this.atn.states[ctx.getReturnState(i)];\n        var removed = calledRuleStack.contains(returnState.ruleIndex);\n\n        try {\n          calledRuleStack.remove(returnState.ruleIndex);\n\n          this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n        } finally {\n          if (removed) {\n            calledRuleStack.add(returnState.ruleIndex);\n          }\n        }\n      }\n\n      return;\n    }\n  }\n\n  for (var j = 0; j < s.transitions.length; j++) {\n    var t = s.transitions[j];\n\n    if (t.constructor === RuleTransition) {\n      if (calledRuleStack.contains(t.target.ruleIndex)) {\n        continue;\n      }\n\n      var newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n\n      try {\n        calledRuleStack.add(t.target.ruleIndex);\n\n        this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n      } finally {\n        calledRuleStack.remove(t.target.ruleIndex);\n      }\n    } else if (t instanceof AbstractPredicateTransition) {\n      if (seeThruPreds) {\n        this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n      } else {\n        look.addOne(LL1Analyzer.HIT_PRED);\n      }\n    } else if (t.isEpsilon) {\n      this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n    } else if (t.constructor === WildcardTransition) {\n      look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n    } else {\n      var set = t.label;\n\n      if (set !== null) {\n        if (t instanceof NotSetTransition) {\n          set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n        }\n\n        look.addSet(set);\n      }\n    }\n  }\n};\n\nexports.LL1Analyzer = LL1Analyzer;","map":null,"metadata":{},"sourceType":"script"}