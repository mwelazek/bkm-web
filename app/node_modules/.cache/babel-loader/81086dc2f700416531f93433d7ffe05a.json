{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fhir_1 = require(\"../types/fhir\");\n\nconst itemType_1 = __importDefault(require(\"../constants/itemType\"));\n\nconst enableWhenMatcher_1 = require(\"../util/enableWhenMatcher\");\n\nconst extension_1 = require(\"./extension\");\n\nfunction getRootQuestionnaireResponseItemFromData(definitionLinkId, formData) {\n  if (!formData || !formData.Content) {\n    return undefined;\n  }\n\n  const content = formData.Content;\n\n  if (!content.item || content.item.length === 0) {\n    return undefined;\n  }\n\n  return getItemWithIdFromResponseItemArray(definitionLinkId, content.item);\n}\n\nexports.getRootQuestionnaireResponseItemFromData = getRootQuestionnaireResponseItemFromData;\n\nfunction isInGroupContext(path, item, items) {\n  const pathItem = path && path.find(p => p.linkId === item.linkId && p.index !== undefined);\n\n  if (!pathItem) {\n    return true;\n  }\n\n  const repeatingItems = getItemWithIdFromResponseItemArray(item.linkId, items) || [];\n  return repeatingItems.indexOf(item) === pathItem.index;\n}\n\nexports.isInGroupContext = isInGroupContext;\n\nfunction getQuestionnaireResponseItemWithLinkid(linkId, responseItem, referencePath) {\n  if (!responseItem) {\n    return undefined;\n  }\n\n  if (responseItem.linkId === linkId) {\n    return responseItem;\n  }\n\n  for (let i = 0; responseItem.item && i < responseItem.item.length; i++) {\n    if (!isInGroupContext(referencePath, responseItem.item[i], responseItem.item)) {\n      continue;\n    }\n\n    const item = getQuestionnaireResponseItemWithLinkid(linkId, responseItem.item[i], referencePath);\n\n    if (item) {\n      return item;\n    }\n  }\n\n  for (let i = 0; responseItem.answer && i < responseItem.answer.length; i++) {\n    const answer = responseItem.answer[i];\n\n    for (let j = 0; answer.item && j < answer.item.length; j++) {\n      if (!isInGroupContext(referencePath, answer.item[j], answer.item)) {\n        continue;\n      }\n\n      const item = getQuestionnaireResponseItemWithLinkid(linkId, answer.item[j], referencePath);\n\n      if (item) {\n        return item;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nexports.getQuestionnaireResponseItemWithLinkid = getQuestionnaireResponseItemWithLinkid;\n\nfunction getQuestionnaireResponseItemsWithLinkId(linkId, responseItems) {\n  let recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!responseItems) {\n    return [];\n  }\n\n  let itemsWithLinkId = getItemsWithIdFromResponseItemArray(linkId, responseItems, recursive);\n\n  if (itemsWithLinkId && itemsWithLinkId.length > 0) {\n    return itemsWithLinkId;\n  }\n\n  function collectAnswerItems(items) {\n    if (items.length === 0) return [];\n    let answers = [];\n    answers = answers.concat(...items.map(i => i.answer || []));\n    let subItems = [];\n    subItems = subItems.concat(...items.map(i => i.item || []));\n    return answers.concat(...collectAnswerItems(subItems));\n  }\n\n  const answers = collectAnswerItems(responseItems);\n  let items = [];\n  items = items.concat(...answers.map(a => a.item || []));\n  itemsWithLinkId = getItemsWithIdFromResponseItemArray(linkId, items, false);\n  return itemsWithLinkId;\n}\n\nexports.getQuestionnaireResponseItemsWithLinkId = getQuestionnaireResponseItemsWithLinkId;\n\nfunction getArrayContainingResponseItemFromItems(linkId, items) {\n  for (const item of items) {\n    if (item.linkId === linkId) {\n      return items;\n    }\n\n    if (item.item) {\n      const result = getArrayContainingResponseItemFromItems(linkId, item.item);\n      if (result) return result;\n    }\n\n    if (item.answer) {\n      const result = getArrayContainingResponseItemFromAnswers(linkId, item.answer);\n      if (result) return result;\n    }\n  }\n\n  return undefined;\n}\n\nexports.getArrayContainingResponseItemFromItems = getArrayContainingResponseItemFromItems;\n\nfunction getArrayContainingResponseItemFromAnswers(linkId, answers) {\n  for (const answer of answers) {\n    if (answer.item) {\n      const result = getArrayContainingResponseItemFromItems(linkId, answer.item);\n      if (result) return result;\n    }\n  }\n\n  return undefined;\n}\n\nfunction getAnswerFromResponseItem(responseItem) {\n  if (!responseItem) {\n    return undefined;\n  }\n\n  if (!responseItem.answer || responseItem.answer.length === 0) {\n    return undefined;\n  }\n\n  if (responseItem.answer.length > 1) {\n    return responseItem.answer;\n  }\n\n  return responseItem.answer[0];\n}\n\nexports.getAnswerFromResponseItem = getAnswerFromResponseItem;\n\nfunction getResponseItems(formData) {\n  if (!formData || !formData.Content) {\n    return undefined;\n  }\n\n  const response = formData.Content;\n\n  if (!response.item || response.item.length === 0) {\n    return undefined;\n  }\n\n  return response.item;\n}\n\nexports.getResponseItems = getResponseItems;\n\nfunction getDefinitionItems(formDefinition) {\n  if (!formDefinition || !formDefinition.Content) {\n    return undefined;\n  }\n\n  const definition = formDefinition.Content;\n\n  if (!definition.item || definition.item.length === 0) {\n    return undefined;\n  }\n\n  return definition.item;\n}\n\nexports.getDefinitionItems = getDefinitionItems;\n\nfunction getItemWithIdFromResponseItemArray(linkId, responseItems) {\n  if (!responseItems || responseItems.length === 0) {\n    return undefined;\n  }\n\n  const filteredItems = responseItems.filter(i => i.linkId === linkId);\n\n  if (!filteredItems || filteredItems.length === 0) {\n    return undefined;\n  }\n\n  return filteredItems;\n}\n\nexports.getItemWithIdFromResponseItemArray = getItemWithIdFromResponseItemArray;\n\nfunction getItemsWithIdFromResponseItemArray(linkId, responseItems) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!responseItems || responseItems.length === 0) {\n    return [];\n  }\n\n  const filteredItems = responseItems.filter(i => i.linkId === linkId);\n\n  if (recurse) {\n    const reducer = (acc, val) => {\n      if (val.item) {\n        acc.push(...getItemsWithIdFromResponseItemArray(linkId, val.item, recurse));\n      }\n\n      return acc;\n    };\n\n    return responseItems.reduce(reducer, filteredItems);\n  }\n\n  return filteredItems;\n}\n\nexports.getItemsWithIdFromResponseItemArray = getItemsWithIdFromResponseItemArray;\n\nfunction getItemWithTypeFromArray(type, items) {\n  if (!items || items.length === 0) {\n    return undefined;\n  }\n\n  let filteredItems = [];\n\n  if (type === itemType_1.default.ATTATCHMENT) {\n    filteredItems = items.filter(i => i.answer && i.answer[0] && i.answer[0].valueAttachment !== null && i.answer[0].valueAttachment !== undefined);\n  }\n\n  if (!filteredItems || filteredItems.length === 0) {\n    return undefined;\n  }\n\n  return filteredItems;\n}\n\nexports.getItemWithTypeFromArray = getItemWithTypeFromArray;\n\nfunction hasAnswer(answer) {\n  if (!answer) {\n    return false;\n  }\n\n  return hasBooleanAnswer(answer) || hasCodingAnswer(answer) || hasQuantityAnswer(answer) || hasDateAnswer(answer) || hasDateTimeAnswer(answer) || hasDateTimeAnswer(answer) || hasDecimalAnswer(answer) || hasIntegerAnswer(answer) || hasStringAnswer(answer) || hasAttachmentAnswer(answer);\n}\n\nexports.hasAnswer = hasAnswer;\n\nfunction hasBooleanAnswer(answer) {\n  return answer.valueBoolean === true || answer.valueBoolean === false;\n}\n\nexports.hasBooleanAnswer = hasBooleanAnswer;\n\nfunction hasCodingAnswer(answer) {\n  const coding = answer.valueCoding;\n  const codingValue = coding && coding.code ? String(coding.code) : null;\n  return codingValue !== null && codingValue !== undefined && codingValue !== '';\n}\n\nexports.hasCodingAnswer = hasCodingAnswer;\n\nfunction hasQuantityAnswer(answer) {\n  return answer.valueQuantity != null && (!!answer.valueQuantity.value || answer.valueQuantity.value === 0);\n}\n\nexports.hasQuantityAnswer = hasQuantityAnswer;\n\nfunction hasDateAnswer(answer) {\n  return !!answer.valueDate;\n}\n\nexports.hasDateAnswer = hasDateAnswer;\n\nfunction hasDateTimeAnswer(answer) {\n  return !!answer.valueDateTime;\n}\n\nexports.hasDateTimeAnswer = hasDateTimeAnswer;\n\nfunction hasDecimalAnswer(answer) {\n  return !!answer.valueDecimal || answer.valueDecimal === 0;\n}\n\nexports.hasDecimalAnswer = hasDecimalAnswer;\n\nfunction hasIntegerAnswer(answer) {\n  return !!answer.valueInteger || answer.valueInteger === 0;\n}\n\nexports.hasIntegerAnswer = hasIntegerAnswer;\n\nfunction hasStringAnswer(answer) {\n  return !!answer.valueString;\n}\n\nexports.hasStringAnswer = hasStringAnswer;\n\nfunction hasTimeAnswer(answer) {\n  return !!answer.valueTime;\n}\n\nexports.hasTimeAnswer = hasTimeAnswer;\n\nfunction hasAttachmentAnswer(answer) {\n  return answer.valueAttachment != null && !!answer.valueAttachment.id;\n}\n\nexports.hasAttachmentAnswer = hasAttachmentAnswer;\n\nfunction enableWhenMatchesAnswer(enableWhen, answers) {\n  if (!enableWhen) return false;\n  answers = answers || [];\n\n  if (enableWhen.operator === fhir_1.QuestionnaireEnableOperator.Exists.code && enableWhen.answerBoolean === false) {\n    return !answers.some(a => hasAnswer(a));\n  }\n\n  if (enableWhen.operator === fhir_1.QuestionnaireEnableOperator.Exists.code && enableWhen.answerBoolean === true) {\n    return answers.some(a => hasAnswer(a));\n  }\n\n  if (answers.length === 0) {\n    return false;\n  }\n\n  let matches = false;\n  answers.forEach(answer => {\n    matches = matches || enableWhenMatcher_1.enableWhenMatches(enableWhen, answer);\n  });\n  return matches;\n}\n\nexports.enableWhenMatchesAnswer = enableWhenMatchesAnswer;\n\nfunction createIdSuffix(path) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let repeats = arguments.length > 2 ? arguments[2] : undefined;\n  let suffix = '';\n\n  if (path) {\n    path.forEach(p => {\n      if (p.index) {\n        suffix += '^' + p.index;\n      }\n    });\n  }\n\n  if (!repeats) return suffix;\n  return suffix + '^' + index;\n}\n\nexports.createIdSuffix = createIdSuffix;\n\nfunction createPathForItem(path, item, responseItem, index) {\n  let newPath;\n\n  if (path === null || path === undefined) {\n    newPath = [];\n  } else {\n    newPath = copyPath(path);\n  }\n\n  index = item.repeats ? index : undefined;\n\n  if (item && responseItem) {\n    newPath.push(Object.assign({\n      linkId: responseItem.linkId\n    }, item.repeats && {\n      index\n    }));\n  }\n\n  return newPath;\n}\n\nexports.createPathForItem = createPathForItem;\n\nfunction shouldRenderDeleteButton(item, index) {\n  if (!item.repeats) {\n    return false;\n  }\n\n  if (index === 0) {\n    return false;\n  }\n\n  const minOccurs = extension_1.getMinOccursExtensionValue(item);\n\n  if (minOccurs) {\n    if (index >= minOccurs) {\n      return true;\n    }\n  } else {\n    return true;\n  }\n\n  return false;\n}\n\nexports.shouldRenderDeleteButton = shouldRenderDeleteButton;\n\nfunction copyPath(path) {\n  const newPath = [];\n\n  for (let i = 0; i < path.length; i++) {\n    newPath.push(Object.assign({}, path[i]));\n  }\n\n  return newPath;\n}\n\nfunction getResponseItemAndPathWithLinkId(linkId, item) {\n  let currentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  var _a, _b, _c;\n\n  const response = [];\n  let index = 0;\n  const seen = {};\n\n  for (const i of (_a = item.item) !== null && _a !== void 0 ? _a : []) {\n    index = i.linkId in seen ? seen[i.linkId] : 0;\n    response.push(...getResponseItemAndPathWithLinkIdTraverse(linkId, i, currentPath, index));\n    seen[i.linkId] = index + 1;\n  }\n\n  if (isOfTypeQuestionnaireResponseItem(item)) {\n    for (const a of (_b = item.answer) !== null && _b !== void 0 ? _b : []) {\n      for (const i of (_c = a.item) !== null && _c !== void 0 ? _c : []) {\n        index = i.linkId in seen ? seen[i.linkId] : 0;\n        response.push(...getResponseItemAndPathWithLinkIdTraverse(linkId, i, currentPath, index));\n        seen[i.linkId] = index + 1;\n      }\n    }\n  }\n\n  return response;\n}\n\nexports.getResponseItemAndPathWithLinkId = getResponseItemAndPathWithLinkId;\n\nfunction getResponseItemAndPathWithLinkIdTraverse(linkId, item, currentPath, currentIndex) {\n  currentPath.push({\n    linkId: item.linkId,\n    index: currentIndex\n  });\n  let response = [];\n\n  if (item.linkId === linkId) {\n    response = [{\n      item: item,\n      path: copyPath(currentPath)\n    }];\n  } else {\n    response = getResponseItemAndPathWithLinkId(linkId, item, currentPath);\n  }\n\n  currentPath.pop();\n  return response;\n}\n\nfunction isOfTypeQuestionnaireResponseItem(item) {\n  return item.answer !== undefined;\n}\n\nfunction getResponseItemWithPath(path, formData) {\n  if (!path || path.length === 0) {\n    return undefined;\n  }\n\n  if (!formData.Content || !formData.Content.item) {\n    return undefined;\n  }\n\n  const rootItems = getRootQuestionnaireResponseItemFromData(path[0].linkId, formData);\n\n  if (!rootItems || rootItems.length === 0) {\n    return undefined;\n  }\n\n  let item = rootItems[path[0].index || 0];\n\n  for (let i = 1; i < path.length; i++) {\n    let itemsWithLinkIdFromPath = getItemWithIdFromResponseItemArray(path[i].linkId, item.item);\n\n    if (!itemsWithLinkIdFromPath || itemsWithLinkIdFromPath.length === 0) {\n      const itemsFromAnswer = item.answer && item.answer.map(a => a.item).reduce((a, b) => (a || []).concat(b || []));\n      itemsWithLinkIdFromPath = getItemWithIdFromResponseItemArray(path[i].linkId, itemsFromAnswer);\n\n      if (!itemsWithLinkIdFromPath || itemsWithLinkIdFromPath.length === 0) {\n        break;\n      }\n    }\n\n    item = itemsWithLinkIdFromPath[path[i].index || 0];\n  }\n\n  return item;\n}\n\nexports.getResponseItemWithPath = getResponseItemWithPath;\n\nfunction getQuestionnaireDefinitionItem(linkId, definitionItems) {\n  let definitionItem;\n\n  for (let i = 0; definitionItems && i < definitionItems.length; i++) {\n    definitionItem = definitionItems[i];\n\n    if (definitionItem.linkId !== linkId) {\n      definitionItem = getQuestionnaireDefinitionItemWithLinkid(linkId, definitionItems[i]);\n    }\n\n    if (definitionItem === undefined || definitionItem === null) {\n      continue;\n    }\n\n    break;\n  }\n\n  return definitionItem;\n}\n\nexports.getQuestionnaireDefinitionItem = getQuestionnaireDefinitionItem;\n\nfunction getQuestionnaireDefinitionItemWithLinkid(linkId, definitionItem) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (!definitionItem) {\n    return undefined;\n  }\n\n  const hasItems = definitionItem.item && definitionItem.item.length > 0;\n\n  if (!hasItems) {\n    return undefined;\n  }\n\n  const itemsWithLinkId = getQuestionnaireItemWithIdFromArray(linkId, definitionItem.item);\n\n  if (itemsWithLinkId && itemsWithLinkId.length >= index) {\n    return itemsWithLinkId[index];\n  }\n\n  for (let i = 0; definitionItem.item && i < definitionItem.item.length; i++) {\n    const item = getQuestionnaireDefinitionItemWithLinkid(linkId, definitionItem.item[i]);\n\n    if (item) {\n      return item;\n    }\n  }\n}\n\nfunction getQuestionnaireItemWithIdFromArray(linkId, items) {\n  if (!items || items.length === 0) {\n    return undefined;\n  }\n\n  const filteredItems = items.filter(i => i.linkId === linkId);\n\n  if (!filteredItems || filteredItems.length === 0) {\n    return undefined;\n  }\n\n  return filteredItems;\n}","map":null,"metadata":{},"sourceType":"script"}