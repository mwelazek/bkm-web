{"ast":null,"code":"\"use strict\"; // In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\n\nvar BrowserAdapter_1 = require(\"../adapters/BrowserAdapter\");\n\nvar adapter = new BrowserAdapter_1.default();\n\nvar _adapter$getSmartApi = adapter.getSmartApi(),\n    ready = _adapter$getSmartApi.ready,\n    authorize = _adapter$getSmartApi.authorize,\n    init = _adapter$getSmartApi.init,\n    client = _adapter$getSmartApi.client,\n    options = _adapter$getSmartApi.options; // We have two kinds of browser builds - \"pure\" for new browsers and \"legacy\"\n// for old ones. In pure builds we assume that the browser supports everything\n// we need. In legacy mode, the library also acts as a polyfill. Babel will\n// automatically polyfill everything except \"fetch\", which we have to handle\n// manually.\n// @ts-ignore\n\n\nif (typeof FHIRCLIENT_PURE == \"undefined\") {\n  var fetch = require(\"cross-fetch\");\n\n  require(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n\n  if (!window.fetch) {\n    window.fetch = fetch.default;\n    window.Headers = fetch.Headers;\n    window.Request = fetch.Request;\n    window.Response = fetch.Response;\n  }\n} // $lab:coverage:off$\n\n\nvar FHIR = {\n  AbortController: window.AbortController,\n  client: client,\n  oauth2: {\n    settings: options,\n    ready: ready,\n    authorize: authorize,\n    init: init\n  }\n};\nmodule.exports = FHIR; // $lab:coverage:on$","map":null,"metadata":{},"sourceType":"script"}