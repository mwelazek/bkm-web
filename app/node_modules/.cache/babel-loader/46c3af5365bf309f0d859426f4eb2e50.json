{"ast":null,"code":"/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nvar Utils = require('./../Utils');\n\nvar Token = require('./../Token').Token;\n\nvar RuleNode = require('./Tree').RuleNode;\n\nvar ErrorNode = require('./Tree').ErrorNode;\n\nvar TerminalNode = require('./Tree').TerminalNode;\n\nvar ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;\n\nvar RuleContext = require('./../RuleContext').RuleContext;\n\nvar INVALID_ALT_NUMBER = require('./../atn/ATN').INVALID_ALT_NUMBER;\n/** A set of utility routines useful for all kinds of ANTLR trees. */\n\n\nfunction Trees() {} // Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n//  node payloads to get the text for the nodes.  Detect\n//  parse trees and extract data appropriately.\n\n\nTrees.toStringTree = function (tree, ruleNames, recog) {\n  ruleNames = ruleNames || null;\n  recog = recog || null;\n\n  if (recog !== null) {\n    ruleNames = recog.ruleNames;\n  }\n\n  var s = Trees.getNodeText(tree, ruleNames);\n  s = Utils.escapeWhitespace(s, false);\n  var c = tree.getChildCount();\n\n  if (c === 0) {\n    return s;\n  }\n\n  var res = \"(\" + s + ' ';\n\n  if (c > 0) {\n    s = Trees.toStringTree(tree.getChild(0), ruleNames);\n    res = res.concat(s);\n  }\n\n  for (var i = 1; i < c; i++) {\n    s = Trees.toStringTree(tree.getChild(i), ruleNames);\n    res = res.concat(' ' + s);\n  }\n\n  res = res.concat(\")\");\n  return res;\n};\n\nTrees.getNodeText = function (t, ruleNames, recog) {\n  ruleNames = ruleNames || null;\n  recog = recog || null;\n\n  if (recog !== null) {\n    ruleNames = recog.ruleNames;\n  }\n\n  if (ruleNames !== null) {\n    if (t instanceof RuleContext) {\n      var altNumber = t.getAltNumber();\n\n      if (altNumber != INVALID_ALT_NUMBER) {\n        return ruleNames[t.ruleIndex] + \":\" + altNumber;\n      }\n\n      return ruleNames[t.ruleIndex];\n    } else if (t instanceof ErrorNode) {\n      return t.toString();\n    } else if (t instanceof TerminalNode) {\n      if (t.symbol !== null) {\n        return t.symbol.text;\n      }\n    }\n  } // no recog for rule names\n\n\n  var payload = t.getPayload();\n\n  if (payload instanceof Token) {\n    return payload.text;\n  }\n\n  return t.getPayload().toString();\n}; // Return ordered list of all children of this node\n\n\nTrees.getChildren = function (t) {\n  var list = [];\n\n  for (var i = 0; i < t.getChildCount(); i++) {\n    list.push(t.getChild(i));\n  }\n\n  return list;\n}; // Return a list of all ancestors of this node.  The first node of\n//  list is the root and the last is the parent of this node.\n//\n\n\nTrees.getAncestors = function (t) {\n  var ancestors = [];\n  t = t.getParent();\n\n  while (t !== null) {\n    ancestors = [t].concat(ancestors);\n    t = t.getParent();\n  }\n\n  return ancestors;\n};\n\nTrees.findAllTokenNodes = function (t, ttype) {\n  return Trees.findAllNodes(t, ttype, true);\n};\n\nTrees.findAllRuleNodes = function (t, ruleIndex) {\n  return Trees.findAllNodes(t, ruleIndex, false);\n};\n\nTrees.findAllNodes = function (t, index, findTokens) {\n  var nodes = [];\n\n  Trees._findAllNodes(t, index, findTokens, nodes);\n\n  return nodes;\n};\n\nTrees._findAllNodes = function (t, index, findTokens, nodes) {\n  // check this node (the root) first\n  if (findTokens && t instanceof TerminalNode) {\n    if (t.symbol.type === index) {\n      nodes.push(t);\n    }\n  } else if (!findTokens && t instanceof ParserRuleContext) {\n    if (t.ruleIndex === index) {\n      nodes.push(t);\n    }\n  } // check children\n\n\n  for (var i = 0; i < t.getChildCount(); i++) {\n    Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n  }\n};\n\nTrees.descendants = function (t) {\n  var nodes = [t];\n\n  for (var i = 0; i < t.getChildCount(); i++) {\n    nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n  }\n\n  return nodes;\n};\n\nexports.Trees = Trees;","map":null,"metadata":{},"sourceType":"script"}