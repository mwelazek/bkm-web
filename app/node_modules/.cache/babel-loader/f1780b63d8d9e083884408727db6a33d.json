{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n//\n// This class extends {@link BufferedTokenStream} with functionality to filter\n// token streams to tokens on a particular channel (tokens where\n// {@link Token//getChannel} returns a particular value).\n//\n// <p>\n// This token stream provides access to all tokens by index or when calling\n// methods like {@link //getText}. The channel filtering is only used for code\n// accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n// {@link //LB}.</p>\n//\n// <p>\n// By default, tokens are placed on the default channel\n// ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n// {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n// call {@link Lexer//setChannel}.\n// </p>\n//\n// <p>\n// Note: lexer rules which use the {@code ->skip} lexer command or call\n// {@link Lexer//skip} do not produce tokens at all, so input text matched by\n// such a rule will not be available as part of the token stream, regardless of\n// channel.</p>\n///\nvar Token = require('./Token').Token;\n\nvar BufferedTokenStream = require('./BufferedTokenStream').BufferedTokenStream;\n\nfunction CommonTokenStream(lexer, channel) {\n  BufferedTokenStream.call(this, lexer);\n  this.channel = channel === undefined ? Token.DEFAULT_CHANNEL : channel;\n  return this;\n}\n\nCommonTokenStream.prototype = Object.create(BufferedTokenStream.prototype);\nCommonTokenStream.prototype.constructor = CommonTokenStream;\n\nCommonTokenStream.prototype.adjustSeekIndex = function (i) {\n  return this.nextTokenOnChannel(i, this.channel);\n};\n\nCommonTokenStream.prototype.LB = function (k) {\n  if (k === 0 || this.index - k < 0) {\n    return null;\n  }\n\n  var i = this.index;\n  var n = 1; // find k good tokens looking backwards\n\n  while (n <= k) {\n    // skip off-channel tokens\n    i = this.previousTokenOnChannel(i - 1, this.channel);\n    n += 1;\n  }\n\n  if (i < 0) {\n    return null;\n  }\n\n  return this.tokens[i];\n};\n\nCommonTokenStream.prototype.LT = function (k) {\n  this.lazyInit();\n\n  if (k === 0) {\n    return null;\n  }\n\n  if (k < 0) {\n    return this.LB(-k);\n  }\n\n  var i = this.index;\n  var n = 1; // we know tokens[pos] is a good one\n  // find k good tokens\n\n  while (n < k) {\n    // skip off-channel tokens, but make sure to not look past EOF\n    if (this.sync(i + 1)) {\n      i = this.nextTokenOnChannel(i + 1, this.channel);\n    }\n\n    n += 1;\n  }\n\n  return this.tokens[i];\n}; // Count EOF just once.///\n\n\nCommonTokenStream.prototype.getNumberOfOnChannelTokens = function () {\n  var n = 0;\n  this.fill();\n\n  for (var i = 0; i < this.tokens.length; i++) {\n    var t = this.tokens[i];\n\n    if (t.channel === this.channel) {\n      n += 1;\n    }\n\n    if (t.type === Token.EOF) {\n      break;\n    }\n  }\n\n  return n;\n};\n\nexports.CommonTokenStream = CommonTokenStream;","map":null,"metadata":{},"sourceType":"script"}