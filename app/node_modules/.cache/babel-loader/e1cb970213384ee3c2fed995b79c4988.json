{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n//\n// This implementation of {@link ANTLRErrorListener} can be used to identify\n// certain potential correctness and performance problems in grammars. \"Reports\"\n// are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n// message.\n//\n// <ul>\n// <li><b>Ambiguities</b>: These are cases where more than one path through the\n// grammar can match the input.</li>\n// <li><b>Weak context sensitivity</b>: These are cases where full-context\n// prediction resolved an SLL conflict to a unique alternative which equaled the\n// minimum alternative of the SLL conflict.</li>\n// <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n// full-context prediction resolved an SLL conflict to a unique alternative,\n// <em>and</em> the minimum alternative of the SLL conflict was found to not be\n// a truly viable alternative. Two-stage parsing cannot be used for inputs where\n// this situation occurs.</li>\n// </ul>\nvar BitSet = require('./../Utils').BitSet;\n\nvar ErrorListener = require('./ErrorListener').ErrorListener;\n\nvar Interval = require('./../IntervalSet').Interval;\n\nfunction DiagnosticErrorListener(exactOnly) {\n  ErrorListener.call(this);\n  exactOnly = exactOnly || true; // whether all ambiguities or only exact ambiguities are reported.\n\n  this.exactOnly = exactOnly;\n  return this;\n}\n\nDiagnosticErrorListener.prototype = Object.create(ErrorListener.prototype);\nDiagnosticErrorListener.prototype.constructor = DiagnosticErrorListener;\n\nDiagnosticErrorListener.prototype.reportAmbiguity = function (recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n  if (this.exactOnly && !exact) {\n    return;\n  }\n\n  var msg = \"reportAmbiguity d=\" + this.getDecisionDescription(recognizer, dfa) + \": ambigAlts=\" + this.getConflictingAlts(ambigAlts, configs) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n  recognizer.notifyErrorListeners(msg);\n};\n\nDiagnosticErrorListener.prototype.reportAttemptingFullContext = function (recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n  var msg = \"reportAttemptingFullContext d=\" + this.getDecisionDescription(recognizer, dfa) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n  recognizer.notifyErrorListeners(msg);\n};\n\nDiagnosticErrorListener.prototype.reportContextSensitivity = function (recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n  var msg = \"reportContextSensitivity d=\" + this.getDecisionDescription(recognizer, dfa) + \", input='\" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\";\n  recognizer.notifyErrorListeners(msg);\n};\n\nDiagnosticErrorListener.prototype.getDecisionDescription = function (recognizer, dfa) {\n  var decision = dfa.decision;\n  var ruleIndex = dfa.atnStartState.ruleIndex;\n  var ruleNames = recognizer.ruleNames;\n\n  if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n    return \"\" + decision;\n  }\n\n  var ruleName = ruleNames[ruleIndex] || null;\n\n  if (ruleName === null || ruleName.length === 0) {\n    return \"\" + decision;\n  }\n\n  return \"\" + decision + \" (\" + ruleName + \")\";\n}; //\n// Computes the set of conflicting or ambiguous alternatives from a\n// configuration set, if that information was not already provided by the\n// parser.\n//\n// @param reportedAlts The set of conflicting or ambiguous alternatives, as\n// reported by the parser.\n// @param configs The conflicting or ambiguous configuration set.\n// @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n// returns the set of alternatives represented in {@code configs}.\n//\n\n\nDiagnosticErrorListener.prototype.getConflictingAlts = function (reportedAlts, configs) {\n  if (reportedAlts !== null) {\n    return reportedAlts;\n  }\n\n  var result = new BitSet();\n\n  for (var i = 0; i < configs.items.length; i++) {\n    result.add(configs.items[i].alt);\n  }\n\n  return \"{\" + result.values().join(\", \") + \"}\";\n};\n\nexports.DiagnosticErrorListener = DiagnosticErrorListener;","map":null,"metadata":{},"sourceType":"script"}