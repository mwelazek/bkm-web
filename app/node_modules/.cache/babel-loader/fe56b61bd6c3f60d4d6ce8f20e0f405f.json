{"ast":null,"code":"\"use strict\";\n/*\n * This file contains some shared functions. They are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\n\nvar _regeneratorRuntime = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __rest = void 0 && (void 0).__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertJsonPatch = exports.assert = exports.getTargetWindow = exports.getPatientParam = exports.byCodes = exports.byCode = exports.getAccessTokenExpiration = exports.jwtDecode = exports.randomString = exports.absolute = exports.makeArray = exports.setPath = exports.getPath = exports.fetchConformanceStatement = exports.getAndCache = exports.request = exports.responseToJSON = exports.checkResponse = exports.units = exports.debug = void 0;\n\nvar HttpError_1 = require(\"./HttpError\");\n\nvar settings_1 = require(\"./settings\");\n\nvar debug = require(\"debug\"); // $lab:coverage:off$\n// @ts-ignore\n\n\nvar _ref = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\"),\n    fetch = _ref.fetch; // $lab:coverage:on$\n\n\nvar _debug = debug(\"FHIR\");\n\nexports.debug = _debug;\n/**\n * The cache for the `getAndCache` function\n */\n\nvar cache = {};\n/**\n * A namespace with functions for converting between different measurement units\n */\n\nexports.units = {\n  cm: function cm(_ref2) {\n    var code = _ref2.code,\n        value = _ref2.value;\n    ensureNumerical({\n      code: code,\n      value: value\n    });\n    if (code == \"cm\") return value;\n    if (code == \"m\") return value * 100;\n    if (code == \"in\") return value * 2.54;\n    if (code == \"[in_us]\") return value * 2.54;\n    if (code == \"[in_i]\") return value * 2.54;\n    if (code == \"ft\") return value * 30.48;\n    if (code == \"[ft_us]\") return value * 30.48;\n    throw new Error(\"Unrecognized length unit: \" + code);\n  },\n  kg: function kg(_ref3) {\n    var code = _ref3.code,\n        value = _ref3.value;\n    ensureNumerical({\n      code: code,\n      value: value\n    });\n    if (code == \"kg\") return value;\n    if (code == \"g\") return value / 1000;\n    if (code.match(/lb/)) return value / 2.20462;\n    if (code.match(/oz/)) return value / 35.274;\n    throw new Error(\"Unrecognized weight unit: \" + code);\n  },\n  any: function any(pq) {\n    ensureNumerical(pq);\n    return pq.value;\n  }\n};\n/**\n * Assertion function to guard arguments for `units` functions\n */\n\nfunction ensureNumerical(_ref4) {\n  var value = _ref4.value,\n      code = _ref4.code;\n\n  if (typeof value !== \"number\") {\n    throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n  }\n}\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\n\n\nfunction checkResponse(_x) {\n  return _checkResponse.apply(this, arguments);\n}\n\nfunction _checkResponse() {\n  _checkResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resp) {\n    var error;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (resp.ok) {\n              _context.next = 5;\n              break;\n            }\n\n            error = new HttpError_1.default(resp);\n            _context.next = 4;\n            return error.parse();\n\n          case 4:\n            throw error;\n\n          case 5:\n            return _context.abrupt(\"return\", resp);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _checkResponse.apply(this, arguments);\n}\n\nexports.checkResponse = checkResponse;\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n */\n\nfunction responseToJSON(resp) {\n  return resp.text().then(function (text) {\n    return text.length ? JSON.parse(text) : \"\";\n  });\n}\n\nexports.responseToJSON = responseToJSON;\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n */\n\nfunction request(url) {\n  var requestOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var includeResponse = requestOptions.includeResponse,\n      options = __rest(requestOptions, [\"includeResponse\"]);\n\n  return fetch(url, Object.assign(Object.assign({\n    mode: \"cors\"\n  }, options), {\n    headers: Object.assign({\n      accept: \"application/json\"\n    }, options.headers)\n  })).then(checkResponse).then(function (res) {\n    var type = res.headers.get(\"Content-Type\") + \"\";\n\n    if (type.match(/\\bjson\\b/i)) {\n      return responseToJSON(res).then(function (body) {\n        return {\n          res: res,\n          body: body\n        };\n      });\n    }\n\n    if (type.match(/^text\\//i)) {\n      return res.text().then(function (body) {\n        return {\n          res: res,\n          body: body\n        };\n      });\n    }\n\n    return {\n      res: res\n    };\n  }).then(function (_ref5) {\n    var res = _ref5.res,\n        body = _ref5.body;\n\n    // Some servers will reply after CREATE with json content type but with\n    // empty body. In this case check if a location header is received and\n    // fetch that to use it as the final result.\n    if (!body && res.status == 201) {\n      var location = res.headers.get(\"location\");\n\n      if (location) {\n        return request(location, Object.assign(Object.assign({}, options), {\n          method: \"GET\",\n          body: null,\n          includeResponse: includeResponse\n        }));\n      }\n    }\n\n    if (includeResponse) {\n      return {\n        body: body,\n        response: res\n      };\n    } // For any non-text and non-json response return the Response object.\n    // This to let users decide if they want to call text(), blob() or\n    // something else on it\n\n\n    if (body === undefined) {\n      return res;\n    } // Otherwise just return the parsed body (can also be \"\" or null)\n\n\n    return body;\n  });\n}\n\nexports.request = request;\n/**\n * Makes a request using `fetch` and stores the result in internal memory cache.\n * The cache is cleared when the page is unloaded.\n * @param url The URL to request\n * @param requestOptions Request options\n * @param force If true, reload from source and update the cache, even if it has\n * already been cached.\n */\n\nfunction getAndCache(url, requestOptions) {\n  var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.env.NODE_ENV === \"test\";\n\n  if (force || !cache[url]) {\n    cache[url] = request(url, requestOptions);\n    return cache[url];\n  }\n\n  return Promise.resolve(cache[url]);\n}\n\nexports.getAndCache = getAndCache;\n/**\n * Fetches the conformance statement from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n * @param [requestOptions] Any options passed to the fetch call\n */\n\nfunction fetchConformanceStatement() {\n  var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  var requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  var url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n  return getAndCache(url, requestOptions).catch(function (ex) {\n    throw new Error(\"Failed to fetch the conformance statement from \\\"\".concat(url, \"\\\". \").concat(ex));\n  });\n}\n\nexports.fetchConformanceStatement = fetchConformanceStatement;\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\n\nfunction getPath(obj) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  path = path.trim();\n\n  if (!path) {\n    return obj;\n  }\n\n  var segments = path.split(\".\");\n  var result = obj;\n\n  while (result && segments.length) {\n    var key = segments.shift();\n\n    if (!key && Array.isArray(result)) {\n      return result.map(function (o) {\n        return getPath(o, segments.join(\".\"));\n      });\n    } else {\n      result = result[key];\n    }\n  }\n\n  return result;\n}\n\nexports.getPath = getPath;\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @param value The value to set\n * @param createEmpty If true, create missing intermediate objects or arrays\n * @returns The modified object\n */\n\nfunction setPath(obj, path, value) {\n  var createEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  path.trim().split(\".\").reduce(function (out, key, idx, arr) {\n    if (out && idx === arr.length - 1) {\n      out[key] = value;\n    } else {\n      if (out && out[key] === undefined && createEmpty) {\n        out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};\n      }\n\n      return out ? out[key] : undefined;\n    }\n  }, obj);\n  return obj;\n}\n\nexports.setPath = setPath;\n/**\n * If the argument is an array returns it as is. Otherwise puts it in an array\n * (`[arg]`) and returns the result\n * @param arg The element to test and possibly convert to array\n * @category Utility\n */\n\nfunction makeArray(arg) {\n  if (Array.isArray(arg)) {\n    return arg;\n  }\n\n  return [arg];\n}\n\nexports.makeArray = makeArray;\n/**\n * Given a path, converts it to absolute url based on the `baseUrl`. If baseUrl\n * is not provided, the result would be a rooted path (one that starts with `/`).\n * @param path The path to convert\n * @param baseUrl The base URL\n */\n\nfunction absolute(path, baseUrl) {\n  if (path.match(/^http/)) return path;\n  if (path.match(/^urn/)) return path;\n  return String(baseUrl || \"\").replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\n\nexports.absolute = absolute;\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param strLength The length of the output string. Defaults to 8.\n * @param charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n * @category Utility\n */\n\nfunction randomString() {\n  var strLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n  var charSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  var result = [];\n  var len = charSet.length;\n\n  while (strLength--) {\n    result.push(charSet.charAt(Math.floor(Math.random() * len)));\n  }\n\n  return result.join(\"\");\n}\n\nexports.randomString = randomString;\n/**\n * Decodes a JWT token and returns it's body.\n * @param token The token to read\n * @param env An `Adapter` or any other object that has an `atob` method\n * @category Utility\n */\n\nfunction jwtDecode(token, env) {\n  var payload = token.split(\".\")[1];\n  return payload ? JSON.parse(env.atob(payload)) : null;\n}\n\nexports.jwtDecode = jwtDecode;\n/**\n * Given a token response, computes and returns the expiresAt timestamp.\n * Note that this should only be used immediately after an access token is\n * received, otherwise the computed timestamp will be incorrect.\n * @param tokenResponse\n * @param env\n */\n\nfunction getAccessTokenExpiration(tokenResponse, env) {\n  var now = Math.floor(Date.now() / 1000); // Option 1 - using the expires_in property of the token response\n\n  if (tokenResponse.expires_in) {\n    return now + tokenResponse.expires_in;\n  } // Option 2 - using the exp property of JWT tokens (must not assume JWT!)\n\n\n  if (tokenResponse.access_token) {\n    var tokenBody = jwtDecode(tokenResponse.access_token, env);\n\n    if (tokenBody && tokenBody.exp) {\n      return tokenBody.exp;\n    }\n  } // Option 3 - if none of the above worked set this to 5 minutes after now\n\n\n  return now + 300;\n}\n\nexports.getAccessTokenExpiration = getAccessTokenExpiration;\n/**\n * Groups the observations by code. Returns a map that will look like:\n * ```js\n * const map = client.byCodes(observations, \"code\");\n * // map = {\n * //     \"55284-4\": [ observation1, observation2 ],\n * //     \"6082-2\": [ observation3 ]\n * // }\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCode(observations, property) {\n  var ret = {};\n\n  function handleCodeableConcept(concept, observation) {\n    if (concept && Array.isArray(concept.coding)) {\n      concept.coding.forEach(function (_ref6) {\n        var code = _ref6.code;\n\n        if (code) {\n          ret[code] = ret[code] || [];\n          ret[code].push(observation);\n        }\n      });\n    }\n  }\n\n  makeArray(observations).forEach(function (o) {\n    if (o.resourceType === \"Observation\" && o[property]) {\n      if (Array.isArray(o[property])) {\n        o[property].forEach(function (concept) {\n          return handleCodeableConcept(concept, o);\n        });\n      } else {\n        handleCodeableConcept(o[property], o);\n      }\n    }\n  });\n  return ret;\n}\n\nexports.byCode = byCode;\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes. Example:\n * ```js\n * const filter = client.byCodes(observations, \"category\");\n * filter(\"laboratory\") // => [ observation1, observation2 ]\n * filter(\"vital-signs\") // => [ observation3 ]\n * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCodes(observations, property) {\n  var bank = byCode(observations, property);\n  return function () {\n    for (var _len = arguments.length, codes = new Array(_len), _key = 0; _key < _len; _key++) {\n      codes[_key] = arguments[_key];\n    }\n\n    return codes.filter(function (code) {\n      return code + \"\" in bank;\n    }).reduce(function (prev, code) {\n      return prev.concat(bank[code + \"\"]);\n    }, []);\n  };\n}\n\nexports.byCodes = byCodes;\n/**\n * Given a conformance statement and a resource type, returns the name of the\n * URL parameter that can be used to scope the resource type by patient ID.\n */\n\nfunction getPatientParam(conformance, resourceType) {\n  // Find what resources are supported by this server\n  var resources = getPath(conformance, \"rest.0.resource\") || []; // Check if this resource is supported\n\n  var meta = resources.find(function (r) {\n    return r.type === resourceType;\n  });\n\n  if (!meta) {\n    throw new Error(\"Resource \\\"\".concat(resourceType, \"\\\" is not supported by this FHIR server\"));\n  } // Check if any search parameters are available for this resource\n\n\n  if (!Array.isArray(meta.searchParam)) {\n    throw new Error(\"No search parameters supported for \\\"\".concat(resourceType, \"\\\" on this FHIR server\"));\n  } // This is a rare case but could happen in generic workflows\n\n\n  if (resourceType == \"Patient\" && meta.searchParam.find(function (x) {\n    return x.name == \"_id\";\n  })) {\n    return \"_id\";\n  } // Now find the first possible parameter name\n\n\n  var out = settings_1.patientParams.find(function (p) {\n    return meta.searchParam.find(function (x) {\n      return x.name == p;\n    });\n  }); // If there is no match\n\n  if (!out) {\n    throw new Error(\"I don't know what param to use for \" + resourceType);\n  }\n\n  return out;\n}\n\nexports.getPatientParam = getPatientParam;\n/**\n * Resolves a reference to target window. It may also open new window or tab if\n * the `target = \"popup\"` or `target = \"_blank\"`.\n * @param target\n * @param width Only used when `target = \"popup\"`\n * @param height Only used when `target = \"popup\"`\n */\n\nfunction getTargetWindow(_x2) {\n  return _getTargetWindow.apply(this, arguments);\n}\n\nfunction _getTargetWindow() {\n  _getTargetWindow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(target) {\n    var width,\n        height,\n        error,\n        targetWindow,\n        _error,\n        _targetWindow,\n        winOrFrame,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            width = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 800;\n            height = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 720;\n\n            if (!(typeof target == \"function\")) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 5;\n            return target();\n\n          case 5:\n            target = _context2.sent;\n\n          case 6:\n            if (!(target && typeof target == \"object\")) {\n              _context2.next = 8;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", target);\n\n          case 8:\n            if (!(typeof target != \"string\")) {\n              _context2.next = 11;\n              break;\n            }\n\n            _debug(\"Invalid target type '%s'. Failing back to '_self'.\", typeof target);\n\n            return _context2.abrupt(\"return\", self);\n\n          case 11:\n            if (!(target == \"_self\")) {\n              _context2.next = 13;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", self);\n\n          case 13:\n            if (!(target == \"_parent\")) {\n              _context2.next = 15;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", parent);\n\n          case 15:\n            if (!(target == \"_top\")) {\n              _context2.next = 17;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", top);\n\n          case 17:\n            if (!(target == \"_blank\")) {\n              _context2.next = 34;\n              break;\n            }\n\n            targetWindow = null;\n            _context2.prev = 19;\n            targetWindow = window.open(\"\", \"SMARTAuthPopup\");\n\n            if (targetWindow) {\n              _context2.next = 23;\n              break;\n            }\n\n            throw new Error(\"Perhaps window.open was blocked\");\n\n          case 23:\n            _context2.next = 28;\n            break;\n\n          case 25:\n            _context2.prev = 25;\n            _context2.t0 = _context2[\"catch\"](19);\n            error = _context2.t0;\n\n          case 28:\n            if (targetWindow) {\n              _context2.next = 33;\n              break;\n            }\n\n            _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n\n            return _context2.abrupt(\"return\", self);\n\n          case 33:\n            return _context2.abrupt(\"return\", targetWindow);\n\n          case 34:\n            if (!(target == \"popup\")) {\n              _context2.next = 51;\n              break;\n            }\n\n            _targetWindow = null; // if (!targetWindow || targetWindow.closed) {\n\n            _context2.prev = 36;\n            _targetWindow = window.open(\"\", \"SMARTAuthPopup\", [\"height=\" + height, \"width=\" + width, \"menubar=0\", \"resizable=1\", \"status=0\", \"top=\" + (screen.height - height) / 2, \"left=\" + (screen.width - width) / 2].join(\",\"));\n\n            if (_targetWindow) {\n              _context2.next = 40;\n              break;\n            }\n\n            throw new Error(\"Perhaps the popup window was blocked\");\n\n          case 40:\n            _context2.next = 45;\n            break;\n\n          case 42:\n            _context2.prev = 42;\n            _context2.t1 = _context2[\"catch\"](36);\n            _error = _context2.t1;\n\n          case 45:\n            if (_targetWindow) {\n              _context2.next = 50;\n              break;\n            }\n\n            _debug(\"Cannot open window. Failing back to '_self'. %s\", _error);\n\n            return _context2.abrupt(\"return\", self);\n\n          case 50:\n            return _context2.abrupt(\"return\", _targetWindow);\n\n          case 51:\n            // Frame or window by name\n            winOrFrame = frames[target];\n\n            if (!winOrFrame) {\n              _context2.next = 54;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", winOrFrame);\n\n          case 54:\n            _debug(\"Unknown target '%s'. Failing back to '_self'.\", target);\n\n            return _context2.abrupt(\"return\", self);\n\n          case 56:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[19, 25], [36, 42]]);\n  }));\n  return _getTargetWindow.apply(this, arguments);\n}\n\nexports.getTargetWindow = getTargetWindow;\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexports.assert = assert;\n\nfunction assertJsonPatch(patch) {\n  assert(Array.isArray(patch), \"The JSON patch must be an array\");\n  assert(patch.length > 0, \"The JSON patch array should not be empty\");\n  patch.forEach(function (operation) {\n    assert([\"add\", \"replace\", \"test\", \"move\", \"copy\", \"remove\"].indexOf(operation.op) > -1, 'Each patch operation must have an \"op\" property which must be one of: \"add\", \"replace\", \"test\", \"move\", \"copy\", \"remove\"');\n    assert(operation.path && typeof operation.path, \"Invalid \\\"\".concat(operation.op, \"\\\" operation. Missing \\\"path\\\" property\"));\n\n    if (operation.op == \"add\" || operation.op == \"replace\" || operation.op == \"test\") {\n      assert(\"value\" in operation, \"Invalid \\\"\".concat(operation.op, \"\\\" operation. Missing \\\"value\\\" property\"));\n      assert(Object.keys(operation).length == 3, \"Invalid \\\"\".concat(operation.op, \"\\\" operation. Contains unknown properties\"));\n    } else if (operation.op == \"move\" || operation.op == \"copy\") {\n      assert(typeof operation.from == \"string\", \"Invalid \\\"\".concat(operation.op, \"\\\" operation. Requires a string \\\"from\\\" property\"));\n      assert(Object.keys(operation).length == 3, \"Invalid \\\"\".concat(operation.op, \"\\\" operation. Contains unknown properties\"));\n    } else {\n      assert(Object.keys(operation).length == 2, \"Invalid \\\"\".concat(operation.op, \"\\\" operation. Contains unknown properties\"));\n    }\n  });\n}\n\nexports.assertJsonPatch = assertJsonPatch;","map":null,"metadata":{},"sourceType":"script"}