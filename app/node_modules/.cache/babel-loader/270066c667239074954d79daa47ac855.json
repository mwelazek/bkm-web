{"ast":null,"code":"// This file holds code to hande the FHIRPath Existence functions (5.1 in the\n// specification).\nconst util = require(\"./utilities\");\n\nconst filtering = require(\"./filtering\");\n\nconst misc = require(\"./misc\");\n\nconst engine = {};\nengine.emptyFn = util.isEmpty;\n\nengine.notFn = function (coll) {\n  let d = misc.singleton(coll, 'Boolean');\n  return typeof d === 'boolean' ? !d : [];\n};\n\nengine.existsMacro = function (coll, expr) {\n  var vec = coll;\n\n  if (expr) {\n    return engine.existsMacro(filtering.whereMacro(coll, expr));\n  }\n\n  return !util.isEmpty(vec);\n};\n\nengine.allMacro = function (coll, expr) {\n  for (let i = 0, len = coll.length; i < len; ++i) {\n    this.$index = i;\n\n    if (!util.isTrue(expr(coll[i]))) {\n      return [false];\n    }\n  }\n\n  return [true];\n};\n\nengine.allTrueFn = function (x) {\n  let rtn = true;\n\n  for (let i = 0, len = x.length; i < len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allTrue\");\n    rtn = xi === true;\n  }\n\n  return [rtn];\n};\n\nengine.anyTrueFn = function (x) {\n  let rtn = false;\n\n  for (let i = 0, len = x.length; i < len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyTrue\");\n    rtn = xi === true;\n  }\n\n  return [rtn];\n};\n\nengine.allFalseFn = function (x) {\n  let rtn = true;\n\n  for (let i = 0, len = x.length; i < len && rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"allFalse\");\n    rtn = xi === false;\n  }\n\n  return [rtn];\n};\n\nengine.anyFalseFn = function (x) {\n  let rtn = false;\n\n  for (let i = 0, len = x.length; i < len && !rtn; ++i) {\n    let xi = util.assertType(x[i], [\"boolean\"], \"anyFalse\");\n    rtn = xi === false;\n  }\n\n  return [rtn];\n};\n/**\n *  Returns a JSON version of the given object, but with keys of the object in\n *  sorted order (or at least a stable order).\n *  From: https://stackoverflow.com/a/35810961/360782\n */\n\n\nfunction orderedJsonStringify(obj) {\n  return JSON.stringify(sortObjByKey(obj));\n}\n/**\n *  If given value is an object, returns a new object with the properties added\n *  in sorted order, and handles nested objects.  Otherwise, returns the given\n *  value.\n *  From: https://stackoverflow.com/a/35810961/360782\n */\n\n\nfunction sortObjByKey(value) {\n  return typeof value === 'object' ? Array.isArray(value) ? value.map(sortObjByKey) : Object.keys(value).sort().reduce((o, key) => {\n    const v = value[key];\n    o[key] = sortObjByKey(v);\n    return o;\n  }, {}) : value;\n}\n/**\n *  Returns true if coll1 is a subset of coll2.\n */\n\n\nfunction subsetOf(coll1, coll2) {\n  let rtn = coll1.length <= coll2.length;\n\n  if (rtn) {\n    // This requires a deep-equals comparision of every object in coll1,\n    // against each object in coll2.\n    // Optimize by building a hashmap of JSON versions of the objects.\n    var c2Hash = {};\n\n    for (let p = 0, pLen = coll1.length; p < pLen && rtn; ++p) {\n      let obj1 = util.valData(coll1[p]);\n      let obj1Str = orderedJsonStringify(obj1);\n      let found = false;\n\n      if (p === 0) {\n        // c2Hash is not yet built\n        for (let i = 0, len = coll2.length; i < len; ++i) {\n          // No early return from this loop, because we're building c2Hash.\n          let obj2 = util.valData(coll2[i]);\n          let obj2Str = orderedJsonStringify(obj2);\n          c2Hash[obj2Str] = obj2;\n          found = found || obj1Str === obj2Str;\n        }\n      } else found = !!c2Hash[obj1Str];\n\n      rtn = found;\n    }\n  }\n\n  return rtn;\n}\n\nengine.subsetOfFn = function (coll1, coll2) {\n  return [subsetOf(coll1, coll2)];\n};\n\nengine.supersetOfFn = function (coll1, coll2) {\n  return [subsetOf(coll2, coll1)];\n};\n\nengine.isDistinctFn = function (x) {\n  return [x.length === engine.distinctFn(x).length];\n};\n\nengine.distinctFn = function (x) {\n  let unique = []; // Since this requires a deep equals, use a hash table (on JSON strings) for\n  // efficiency.\n\n  if (x.length > 0) {\n    let uniqueHash = {};\n\n    for (let i = 0, len = x.length; i < len; ++i) {\n      let xObj = x[i];\n      let xStr = JSON.stringify(xObj);\n      let uObj = uniqueHash[xStr];\n\n      if (uObj === undefined) {\n        unique.push(xObj);\n        uniqueHash[xStr] = xObj;\n      }\n    }\n  }\n\n  return unique;\n};\n\nmodule.exports = engine;","map":null,"metadata":{},"sourceType":"script"}