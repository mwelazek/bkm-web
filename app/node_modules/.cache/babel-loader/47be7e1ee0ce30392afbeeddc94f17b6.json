{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n//\n// Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n// info about the set, with support for combining similar configurations using a\n// graph-structured stack.\n///\nvar ATN = require('./ATN').ATN;\n\nvar Utils = require('./../Utils');\n\nvar Hash = Utils.Hash;\nvar Set = Utils.Set;\n\nvar SemanticContext = require('./SemanticContext').SemanticContext;\n\nvar merge = require('./../PredictionContext').merge;\n\nfunction hashATNConfig(c) {\n  return c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n  if (a === b) {\n    return true;\n  } else if (a === null || b === null) {\n    return false;\n  } else return a.equalsForConfigSet(b);\n}\n\nfunction ATNConfigSet(fullCtx) {\n  //\n  // The reason that we need this is because we don't want the hash map to use\n  // the standard hash code and equals. We need all configurations with the\n  // same\n  // {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n  // doubles\n  // the number of objects associated with ATNConfigs. The other solution is\n  // to\n  // use a hash table that lets us specify the equals/hashcode operation.\n  // All configs but hashed by (s, i, _, pi) not including context. Wiped out\n  // when we go readonly as this set becomes a DFA state.\n  this.configLookup = new Set(hashATNConfig, equalATNConfigs); // Indicates that this configuration set is part of a full context\n  // LL prediction. It will be used to determine how to merge $. With SLL\n  // it's a wildcard whereas it is not for LL context merge.\n\n  this.fullCtx = fullCtx === undefined ? true : fullCtx; // Indicates that the set of configurations is read-only. Do not\n  // allow any code to manipulate the set; DFA states will point at\n  // the sets and they must not change. This does not protect the other\n  // fields; in particular, conflictingAlts is set after\n  // we've made this readonly.\n\n  this.readOnly = false; // Track the elements as they are added to the set; supports get(i)///\n\n  this.configs = []; // TODO: these fields make me pretty uncomfortable but nice to pack up info\n  // together, saves recomputation\n  // TODO: can we track conflicts as they are added to save scanning configs\n  // later?\n\n  this.uniqueAlt = 0;\n  this.conflictingAlts = null; // Used in parser and lexer. In lexer, it indicates we hit a pred\n  // while computing a closure operation. Don't make a DFA state from this.\n\n  this.hasSemanticContext = false;\n  this.dipsIntoOuterContext = false;\n  this.cachedHashCode = -1;\n  return this;\n} // Adding a new config means merging contexts with existing configs for\n// {@code (s, i, pi, _)}, where {@code s} is the\n// {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n// {@code pi} is the {@link ATNConfig//semanticContext}. We use\n// {@code (s,i,pi)} as key.\n//\n// <p>This method updates {@link //dipsIntoOuterContext} and\n// {@link //hasSemanticContext} when necessary.</p>\n// /\n\n\nATNConfigSet.prototype.add = function (config, mergeCache) {\n  if (mergeCache === undefined) {\n    mergeCache = null;\n  }\n\n  if (this.readOnly) {\n    throw \"This set is readonly\";\n  }\n\n  if (config.semanticContext !== SemanticContext.NONE) {\n    this.hasSemanticContext = true;\n  }\n\n  if (config.reachesIntoOuterContext > 0) {\n    this.dipsIntoOuterContext = true;\n  }\n\n  var existing = this.configLookup.add(config);\n\n  if (existing === config) {\n    this.cachedHashCode = -1;\n    this.configs.push(config); // track order here\n\n    return true;\n  } // a previous (s,i,pi,_), merge with it and save result\n\n\n  var rootIsWildcard = !this.fullCtx;\n  var merged = merge(existing.context, config.context, rootIsWildcard, mergeCache); // no need to check for existing.context, config.context in cache\n  // since only way to create new graphs is \"call rule\" and here. We\n  // cache at both places.\n\n  existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext); // make sure to preserve the precedence filter suppression during the merge\n\n  if (config.precedenceFilterSuppressed) {\n    existing.precedenceFilterSuppressed = true;\n  }\n\n  existing.context = merged; // replace context; no need to alt mapping\n\n  return true;\n};\n\nATNConfigSet.prototype.getStates = function () {\n  var states = new Set();\n\n  for (var i = 0; i < this.configs.length; i++) {\n    states.add(this.configs[i].state);\n  }\n\n  return states;\n};\n\nATNConfigSet.prototype.getPredicates = function () {\n  var preds = [];\n\n  for (var i = 0; i < this.configs.length; i++) {\n    var c = this.configs[i].semanticContext;\n\n    if (c !== SemanticContext.NONE) {\n      preds.push(c.semanticContext);\n    }\n  }\n\n  return preds;\n};\n\nObject.defineProperty(ATNConfigSet.prototype, \"items\", {\n  get: function () {\n    return this.configs;\n  }\n});\n\nATNConfigSet.prototype.optimizeConfigs = function (interpreter) {\n  if (this.readOnly) {\n    throw \"This set is readonly\";\n  }\n\n  if (this.configLookup.length === 0) {\n    return;\n  }\n\n  for (var i = 0; i < this.configs.length; i++) {\n    var config = this.configs[i];\n    config.context = interpreter.getCachedContext(config.context);\n  }\n};\n\nATNConfigSet.prototype.addAll = function (coll) {\n  for (var i = 0; i < coll.length; i++) {\n    this.add(coll[i]);\n  }\n\n  return false;\n};\n\nATNConfigSet.prototype.equals = function (other) {\n  return this === other || other instanceof ATNConfigSet && Utils.equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;\n};\n\nATNConfigSet.prototype.hashCode = function () {\n  var hash = new Hash();\n  hash.update(this.configs);\n  return hash.finish();\n};\n\nATNConfigSet.prototype.updateHashCode = function (hash) {\n  if (this.readOnly) {\n    if (this.cachedHashCode === -1) {\n      this.cachedHashCode = this.hashCode();\n    }\n\n    hash.update(this.cachedHashCode);\n  } else {\n    hash.update(this.hashCode());\n  }\n};\n\nObject.defineProperty(ATNConfigSet.prototype, \"length\", {\n  get: function () {\n    return this.configs.length;\n  }\n});\n\nATNConfigSet.prototype.isEmpty = function () {\n  return this.configs.length === 0;\n};\n\nATNConfigSet.prototype.contains = function (item) {\n  if (this.configLookup === null) {\n    throw \"This method is not implemented for readonly sets.\";\n  }\n\n  return this.configLookup.contains(item);\n};\n\nATNConfigSet.prototype.containsFast = function (item) {\n  if (this.configLookup === null) {\n    throw \"This method is not implemented for readonly sets.\";\n  }\n\n  return this.configLookup.containsFast(item);\n};\n\nATNConfigSet.prototype.clear = function () {\n  if (this.readOnly) {\n    throw \"This set is readonly\";\n  }\n\n  this.configs = [];\n  this.cachedHashCode = -1;\n  this.configLookup = new Set();\n};\n\nATNConfigSet.prototype.setReadonly = function (readOnly) {\n  this.readOnly = readOnly;\n\n  if (readOnly) {\n    this.configLookup = null; // can't mod, no need for lookup cache\n  }\n};\n\nATNConfigSet.prototype.toString = function () {\n  return Utils.arrayToString(this.configs) + (this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") + (this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") + (this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n};\n\nfunction OrderedATNConfigSet() {\n  ATNConfigSet.call(this);\n  this.configLookup = new Set();\n  return this;\n}\n\nOrderedATNConfigSet.prototype = Object.create(ATNConfigSet.prototype);\nOrderedATNConfigSet.prototype.constructor = OrderedATNConfigSet;\nexports.ATNConfigSet = ATNConfigSet;\nexports.OrderedATNConfigSet = OrderedATNConfigSet;","map":null,"metadata":{},"sourceType":"script"}