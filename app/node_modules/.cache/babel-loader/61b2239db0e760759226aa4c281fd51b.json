{"ast":null,"code":"//\n\n/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n///\n// A tuple: (ATN state, predicted alt, syntactic, semantic context).\n//  The syntactic context is a graph-structured stack node whose\n//  path(s) to the root is the rule invocation(s)\n//  chain used to arrive at the state.  The semantic context is\n//  the tree of semantic predicates encountered before reaching\n//  an ATN state.\n///\nvar DecisionState = require('./ATNState').DecisionState;\n\nvar SemanticContext = require('./SemanticContext').SemanticContext;\n\nvar Hash = require(\"../Utils\").Hash;\n\nfunction checkParams(params, isCfg) {\n  if (params === null) {\n    var result = {\n      state: null,\n      alt: null,\n      context: null,\n      semanticContext: null\n    };\n\n    if (isCfg) {\n      result.reachesIntoOuterContext = 0;\n    }\n\n    return result;\n  } else {\n    var props = {};\n    props.state = params.state || null;\n    props.alt = params.alt === undefined ? null : params.alt;\n    props.context = params.context || null;\n    props.semanticContext = params.semanticContext || null;\n\n    if (isCfg) {\n      props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n      props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n    }\n\n    return props;\n  }\n}\n\nfunction ATNConfig(params, config) {\n  this.checkContext(params, config);\n  params = checkParams(params);\n  config = checkParams(config, true); // The ATN state associated with this configuration///\n\n  this.state = params.state !== null ? params.state : config.state; // What alt (or lexer rule) is predicted by this configuration///\n\n  this.alt = params.alt !== null ? params.alt : config.alt; // The stack of invoking states leading to the rule/states associated\n  //  with this config.  We track only those contexts pushed during\n  //  execution of the ATN simulator.\n\n  this.context = params.context !== null ? params.context : config.context;\n  this.semanticContext = params.semanticContext !== null ? params.semanticContext : config.semanticContext !== null ? config.semanticContext : SemanticContext.NONE; // We cannot execute predicates dependent upon local context unless\n  // we know for sure we are in the correct context. Because there is\n  // no way to do this efficiently, we simply cannot evaluate\n  // dependent predicates unless we are in the rule that initially\n  // invokes the ATN simulator.\n  //\n  // closure() tracks the depth of how far we dip into the\n  // outer context: depth &gt; 0.  Note that it may not be totally\n  // accurate depth since I don't ever decrement. TODO: make it a boolean then\n\n  this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n  this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n  return this;\n}\n\nATNConfig.prototype.checkContext = function (params, config) {\n  if ((params.context === null || params.context === undefined) && (config === null || config.context === null || config.context === undefined)) {\n    this.context = null;\n  }\n};\n\nATNConfig.prototype.hashCode = function () {\n  var hash = new Hash();\n  this.updateHashCode(hash);\n  return hash.finish();\n};\n\nATNConfig.prototype.updateHashCode = function (hash) {\n  hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n}; // An ATN configuration is equal to another if both have\n//  the same state, they predict the same alternative, and\n//  syntactic/semantic contexts are the same.\n\n\nATNConfig.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof ATNConfig)) {\n    return false;\n  } else {\n    return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;\n  }\n};\n\nATNConfig.prototype.hashCodeForConfigSet = function () {\n  var hash = new Hash();\n  hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n  return hash.finish();\n};\n\nATNConfig.prototype.equalsForConfigSet = function (other) {\n  if (this === other) {\n    return true;\n  } else if (!(other instanceof ATNConfig)) {\n    return false;\n  } else {\n    return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);\n  }\n};\n\nATNConfig.prototype.toString = function () {\n  return \"(\" + this.state + \",\" + this.alt + (this.context !== null ? \",[\" + this.context.toString() + \"]\" : \"\") + (this.semanticContext !== SemanticContext.NONE ? \",\" + this.semanticContext.toString() : \"\") + (this.reachesIntoOuterContext > 0 ? \",up=\" + this.reachesIntoOuterContext : \"\") + \")\";\n};\n\nfunction LexerATNConfig(params, config) {\n  ATNConfig.call(this, params, config); // This is the backing field for {@link //getLexerActionExecutor}.\n\n  var lexerActionExecutor = params.lexerActionExecutor || null;\n  this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);\n  this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;\n  return this;\n}\n\nLexerATNConfig.prototype = Object.create(ATNConfig.prototype);\nLexerATNConfig.prototype.constructor = LexerATNConfig;\n\nLexerATNConfig.prototype.updateHashCode = function (hash) {\n  hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n};\n\nLexerATNConfig.prototype.equals = function (other) {\n  return this === other || other instanceof LexerATNConfig && this.passedThroughNonGreedyDecision == other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && ATNConfig.prototype.equals.call(this, other);\n};\n\nLexerATNConfig.prototype.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\nLexerATNConfig.prototype.equalsForConfigSet = LexerATNConfig.prototype.equals;\n\nLexerATNConfig.prototype.checkNonGreedyDecision = function (source, target) {\n  return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;\n};\n\nexports.ATNConfig = ATNConfig;\nexports.LexerATNConfig = LexerATNConfig;","map":null,"metadata":{},"sourceType":"script"}