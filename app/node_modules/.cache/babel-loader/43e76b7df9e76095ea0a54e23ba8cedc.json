{"ast":null,"code":"const addMinutes = require('date-fns/add_minutes');\n\nconst ucumUtils = require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance();\n\nconst numbers = require('./numbers');\n\nconst ucumSystemUrl = 'http://unitsofmeasure.org';\nlet timeFormat = '[0-9][0-9](\\\\:[0-9][0-9](\\\\:[0-9][0-9](\\\\.[0-9]+)?)?)?(Z|(\\\\+|-)[0-9][0-9]\\\\:[0-9][0-9])?';\nlet timeRE = new RegExp('^T?' + timeFormat + '$');\nlet dateTimeRE = new RegExp('^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T' + timeFormat + ')?)?)?Z?$'); // FHIR date/time regular expressions are slightly different.  For now, we will\n// stick with the FHIRPath regular expressions.\n//let fhirTimeRE = /([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?/;\n//let fhirDateTimeRE =\n///([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;\n\n/**\n *   Class FP_Type is the superclass for FHIRPath types that required special\n *   handling.\n */\n\nclass FP_Type {\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   */\n  equals() {\n    return false;\n  }\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).\n   */\n\n\n  equivalentTo() {\n    return false;\n  }\n\n  toString() {\n    return this.asStr ? this.asStr : super.toString();\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   *  Returns -1, 0, or 1 if this object is less then, equal to, or greater\n   *  than otherObj.\n   */\n\n\n  compare() {\n    throw 'Not implemented';\n  }\n\n}\n/**\n *  A class for Quantities.\n */\n\n\nclass FP_Quantity extends FP_Type {\n  constructor(value, unit) {\n    super();\n    this.asStr = value + ' ' + unit;\n    this.value = value;\n    this.unit = unit;\n  }\n\n  equals(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEqual(this.value, otherQuantity.value);\n    } // Special year/month comparison case: 1 year = 12 month\n\n\n    const compareYearsAndMonths = this._compareYearsAndMonths(otherQuantity);\n\n    if (compareYearsAndMonths) {\n      return compareYearsAndMonths.isEqual;\n    } // General comparison case\n\n\n    const thisQuantity = FP_Quantity.toUcumQuantity(this.value, this.unit),\n          normalizedOtherQuantity = FP_Quantity.toUcumQuantity(otherQuantity.value, otherQuantity.unit),\n          convResult = ucumUtils.convertUnitTo(normalizedOtherQuantity.unit, normalizedOtherQuantity.value, thisQuantity.unit);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEqual(thisQuantity.value, convResult.toVal);\n  }\n\n  equivalentTo(otherQuantity) {\n    if (!(otherQuantity instanceof this.constructor)) {\n      return false;\n    }\n\n    if (this.unit === otherQuantity.unit) {\n      return numbers.isEquivalent(this.value, otherQuantity.value);\n    }\n\n    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),\n          otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),\n          convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);\n\n    if (convResult.status !== 'succeeded') {\n      return false;\n    }\n\n    return numbers.isEquivalent(this.value, convResult.toVal);\n  }\n  /**\n   * If both quantities have one of these units: year or month,\n   * then a special case will apply; otherwise returns null.\n   * In the special case of comparison, the fact that 1 year = 12 months is used.\n   *\n   * Just note: in general, for a calendar duration:\n   * 1 year = 365 days\n   * 12 month = 12*30 days = 360 days\n   * so, 1 year != 12 month\n   * That's why this special case is needed\n   *\n   * @param {FP_Quantity} otherQuantity\n   * @return {null|{isEqual: boolean}}\n   * @private\n   */\n\n\n  _compareYearsAndMonths(otherQuantity) {\n    const magnitude1 = FP_Quantity._yearMonthConversionFactor[this.unit],\n          magnitude2 = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];\n\n    if (magnitude1 && magnitude2) {\n      return {\n        isEqual: numbers.isEqual(this.value * magnitude1, otherQuantity.value * magnitude2)\n      };\n    }\n\n    return null;\n  }\n\n}\n\nconst surroundingApostrophesRegex = /^'|'$/g;\n/**\n * Converts a FHIR path unit to a UCUM unit code by converting a calendar duration keyword to an equivalent UCUM unit code\n * or removing single quotes for a UCUM unit.\n * @param {string} unit\n * @return {string}\n */\n\nFP_Quantity.getEquivalentUcumUnitCode = function (unit) {\n  return FP_Quantity.mapTimeUnitsToUCUMCode[unit] || unit.replace(surroundingApostrophesRegex, '');\n};\n/**\n * Converts FHIR path value/unit to UCUM value/unit. Usable for comparison.\n * @param {number} value\n * @param {string} unit\n * @returns { {value: number, unit: string} }\n */\n\n\nFP_Quantity.toUcumQuantity = function (value, unit) {\n  const magnitude = FP_Quantity._calendarDuration2Seconds[unit];\n\n  if (magnitude) {\n    return {\n      value: magnitude * value,\n      unit: 's'\n    };\n  }\n\n  return {\n    value,\n    unit: unit.replace(surroundingApostrophesRegex, '')\n  };\n};\n/**\n * Converts FHIRPath value/unit to other FHIRPath value/unit.\n * @param {string} fromUnit\n * @param {number} value\n * @param {string} toUnit\n * @return {FP_Quantity|null}\n */\n\n\nFP_Quantity.convUnitTo = function (fromUnit, value, toUnit) {\n  // 1 Year <-> 12 Months\n  const fromYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[fromUnit],\n        toYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[toUnit];\n\n  if (fromYearMonthMagnitude && toYearMonthMagnitude) {\n    return new FP_Quantity(fromYearMonthMagnitude * value / toYearMonthMagnitude, toUnit);\n  }\n\n  const fromMagnitude = FP_Quantity._calendarDuration2Seconds[fromUnit],\n        toMagnitude = FP_Quantity._calendarDuration2Seconds[toUnit]; // To FHIR path calendar duration\n\n  if (toMagnitude) {\n    if (fromMagnitude) {\n      return new FP_Quantity(fromMagnitude * value / toMagnitude, toUnit);\n    } else {\n      const convResult = ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, 's');\n\n      if (convResult.status === 'succeeded') {\n        return new FP_Quantity(convResult.toVal / toMagnitude, toUnit);\n      }\n    } // To Ucum unit\n\n  } else {\n    const convResult = fromMagnitude ? ucumUtils.convertUnitTo('s', fromMagnitude * value, toUnit.replace(/^'|'$/g, '')) : ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, toUnit.replace(/^'|'$/g, ''));\n\n    if (convResult.status === 'succeeded') {\n      return new FP_Quantity(convResult.toVal, toUnit);\n    }\n  }\n\n  return null;\n}; // Defines conversion factors for calendar durations\n\n\nFP_Quantity._calendarDuration2Seconds = {\n  'years': 365 * 24 * 60 * 60,\n  'months': 30 * 24 * 60 * 60,\n  'weeks': 7 * 24 * 60 * 60,\n  'days': 24 * 60 * 60,\n  'hours': 60 * 60,\n  'minutes': 60,\n  'seconds': 1,\n  'milliseconds': .001,\n  'year': 365 * 24 * 60 * 60,\n  'month': 30 * 24 * 60 * 60,\n  'week': 7 * 24 * 60 * 60,\n  'day': 24 * 60 * 60,\n  'hour': 60 * 60,\n  'minute': 60,\n  'second': 1,\n  'millisecond': .001\n}; // Defines special case to compare years with months for calendar durations\n\nFP_Quantity._yearMonthConversionFactor = {\n  'years': 12,\n  'months': 1,\n  'year': 12,\n  'month': 1\n};\n/**\n *  Defines a map from time units that are supported for arithmetic (including\n *  some UCUM time based units) to FHIRPath time units.\n */\n\nFP_Quantity.arithmeticDurationUnits = {\n  'years': \"year\",\n  'months': \"month\",\n  'weeks': \"week\",\n  'days': \"day\",\n  'hours': \"hour\",\n  'minutes': \"minute\",\n  'seconds': \"second\",\n  'milliseconds': \"millisecond\",\n  'year': \"year\",\n  'month': \"month\",\n  'week': \"week\",\n  'day': \"day\",\n  'hour': \"hour\",\n  'minute': \"minute\",\n  'second': \"second\",\n  'millisecond': \"millisecond\",\n  \"'wk'\": \"week\",\n  \"'d'\": \"day\",\n  \"'h'\": \"hour\",\n  \"'min'\": \"minute\",\n  \"'s'\": \"second\",\n  \"'ms'\": \"millisecond\"\n};\n/**\n *  Defines a map from UCUM code to FHIRPath time units.\n */\n\nFP_Quantity.mapUCUMCodeToTimeUnits = {\n  'a': \"year\",\n  'mo': \"month\",\n  'wk': \"week\",\n  'd': \"day\",\n  'h': \"hour\",\n  'min': \"minute\",\n  's': \"second\",\n  'ms': \"millisecond\"\n};\n/**\n *  Defines a map from FHIRPath time units to UCUM code.\n */\n\nFP_Quantity.mapTimeUnitsToUCUMCode = Object.keys(FP_Quantity.mapUCUMCodeToTimeUnits).reduce(function (res, key) {\n  res[FP_Quantity.mapUCUMCodeToTimeUnits[key]] = key;\n  res[FP_Quantity.mapUCUMCodeToTimeUnits[key] + 's'] = key;\n  return res;\n}, {});\n\nclass FP_TimeBase extends FP_Type {\n  constructor(timeStr) {\n    super();\n    this.asStr = timeStr;\n  }\n  /**\n   *  Adds a time-based quantity to this date/time.\n   * @param timeQuantity a quantity to be added to this date/time.  See the\n   *  FHIRPath specification for supported units.\n   */\n\n\n  plus(timeQuantity) {\n    const unit = timeQuantity.unit;\n    let timeUnit = FP_Quantity.arithmeticDurationUnits[unit];\n\n    if (!timeUnit) {\n      throw new Error('For date/time arithmetic, the unit of the quantity ' + 'must be one of the following time-based units: ' + Object.keys(FP_Quantity.arithmeticDurationUnits));\n    }\n\n    const cls = this.constructor;\n    const unitPrecision = cls._timeUnitToDatePrecision[timeUnit];\n\n    if (unitPrecision === undefined) {\n      throw new Error('Unsupported unit for +.  The unit should be one of ' + Object.keys(cls._timeUnitToDatePrecision).join(', ') + '.');\n    }\n\n    let qVal = timeQuantity.value;\n    const isTime = cls === FP_Time; // From the FHIRPath specification: \"For precisions above seconds, the\n    // decimal portion of the time-valued quantity is ignored, since date/time\n    // arithmetic above seconds is performed with calendar duration semantics.\"\n\n    if (isTime ? unitPrecision < 2 : unitPrecision < 5) {\n      qVal = Math.trunc(qVal);\n    } // If the precision of the time quantity is higher than the precision of the\n    // date, we need to convert the time quantity to the precision of the date.\n\n\n    if (this._getPrecision() < unitPrecision) {\n      const neededUnit = cls._datePrecisionToTimeUnit[this._getPrecision()];\n\n      if (neededUnit !== 'second') {\n        const newQuantity = FP_Quantity.convUnitTo(timeUnit, qVal, neededUnit);\n        timeUnit = newQuantity.unit;\n        qVal = Math.trunc(newQuantity.value);\n      }\n    }\n\n    const newDate = FP_TimeBase.timeUnitToAddFn[timeUnit](this._getDateObj(), qVal); // newDate is a Date.  We need to make a string with the correct precision.\n\n    let precision = this._getPrecision();\n\n    if (isTime) precision += 3; // based on dateTimeRE, not timeRE\n\n    let newDateStr = FP_DateTime.isoDateTime(newDate, precision);\n\n    if (isTime) {\n      // FP_Time just needs the time part of the string\n      newDateStr = newDateStr.slice(newDateStr.indexOf('T') + 1);\n    }\n\n    return new cls(newDateStr);\n  }\n  /**\n   *  Tests whether this object is equal to another.  Returns either true,\n   *  false, or undefined (where in the FHIRPath specification empty would be\n   *  returned).  The undefined return value indicates that the values were the\n   *  same to the shared precision, but that they had differnent levels of\n   *  precision.\n   * @param otherDateTime any sub-type of FP_TimeBase, but it should be the same\n   *  as the type of \"this\".\n   */\n\n\n  equals(otherDateTime) {\n    // From the 2019May ballot:\n    // For Date, DateTime and Time equality, the comparison is performed by\n    // considering each precision in order, beginning with years (or hours for\n    // time values), and respecting timezone offsets. If the values are the\n    // same, comparison proceeds to the next precision; if the values are\n    // different, the comparison stops and the result is false. If one input has\n    // a value for the precision and the other does not, the comparison stops\n    // and the result is empty ({ }); if neither input has a value for the\n    // precision, or the last precision has been reached, the comparison stops\n    // and the result is true.\n    // Note:  Per the spec above\n    //   2012-01 = 2012 //  empty\n    //   2012-01 = 2011 //  false\n    //   2012-01 ~ 2012 //  false\n    var rtn;\n    if (!(otherDateTime instanceof this.constructor)) rtn = false;else {\n      var thisPrec = this._getPrecision();\n\n      var otherPrec = otherDateTime._getPrecision();\n\n      if (thisPrec == otherPrec) {\n        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();\n      } else {\n        // The dates are not equal, but decide whether to return empty or false.\n        var commonPrec = thisPrec <= otherPrec ? thisPrec : otherPrec; // Adjust for timezone offsets, if any, so they are at a common timezone\n\n        var thisUTCStr = this._getDateObj().toISOString();\n\n        var otherUTCStr = otherDateTime._getDateObj().toISOString();\n\n        if (this.constructor === FP_Time) {\n          commonPrec += 3; // because we now have year, month, and day\n\n          thisPrec += 3;\n          otherPrec += 3;\n        } // Now parse the strings and compare the adjusted time parts.\n        // Dates without time specify no timezone and should be treated as already normalized to UTC. So we do not adjust the timezone, as this would change the date\n\n\n        var thisAdj = thisPrec > 2 ? new FP_DateTime(thisUTCStr)._getTimeParts() : this._getTimeParts();\n        var otherAdj = otherPrec > 2 ? new FP_DateTime(otherUTCStr)._getTimeParts() : otherDateTime._getTimeParts();\n\n        for (var i = 0; i <= commonPrec && rtn !== false; ++i) {\n          rtn = thisAdj[i] == otherAdj[i];\n        } // if rtn is still true, then return empty to indicate the difference in\n        // precision.\n\n\n        if (rtn) rtn = undefined;\n      }\n    } // else return undefined (empty)\n\n    return rtn;\n  }\n  /**\n   *  Tests whether this object is equivalant to another.  Returns either true\n   *  or false.\n   */\n\n\n  equivalentTo(otherDateTime) {\n    var rtn = otherDateTime instanceof this.constructor;\n\n    if (rtn) {\n      var thisPrec = this._getPrecision();\n\n      var otherPrec = otherDateTime._getPrecision();\n\n      rtn = thisPrec == otherPrec;\n\n      if (rtn) {\n        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();\n      }\n    }\n\n    return rtn;\n  }\n  /**\n   *  Returns a number less than 0, equal to 0 or greater than 0\n   *  if this (date) time is less than, equal to, or greater than otherTime.\n   *  Comparisons are made at the lesser of the two time precisions.\n   *  @param {FP_TimeBase} otherTime\n   *  @return {number}\n   */\n\n\n  compare(otherTime) {\n    var thisPrecision = this._getPrecision();\n\n    var otherPrecision = otherTime._getPrecision();\n\n    var thisTimeInt = thisPrecision <= otherPrecision ? this._getDateObj().getTime() : this._dateAtPrecision(otherPrecision).getTime();\n    var otherTimeInt = otherPrecision <= thisPrecision ? otherTime._getDateObj().getTime() : otherTime._dateAtPrecision(thisPrecision).getTime();\n\n    if (thisPrecision !== otherPrecision && thisTimeInt === otherTimeInt) {\n      return null;\n    }\n\n    return thisTimeInt - otherTimeInt;\n  }\n  /**\n   *  Returns a number representing the precision of the time string given to\n   *  the constructor.  (Higher means more precise).  The number is the number\n   *  of components of the time string (ignoring the time zone) produced by\n   *  matching against the time regular expression, except that milliseconds\n   *  and seconds are counted together as a single of level of precision.\n   *  @return {number}\n   */\n\n\n  _getPrecision() {\n    if (this.precision === undefined) this._getMatchData();\n    return this.precision;\n  }\n  /**\n   *  Returns the match data from matching the given RegExp against the\n   *  date/time string given to the constructor.\n   *  Also sets this.precision.\n   * @param regEx The regular expression to match against the date/time string.\n   * @param maxPrecision the maximum precision possible for the type\n   */\n\n\n  _getMatchData(regEx, maxPrecision) {\n    if (this.timeMatchData === undefined) {\n      this.timeMatchData = this.asStr.match(regEx);\n\n      if (this.timeMatchData) {\n        for (let i = maxPrecision; i >= 0 && this.precision === undefined; --i) {\n          if (this.timeMatchData[i]) this.precision = i;\n        }\n      }\n    }\n\n    return this.timeMatchData;\n  }\n  /**\n   *  Returns an array of the pieces of the given time string, for use in\n   *  constructing lower precision versions of the time. The returned array will\n   *  contain separate elements for the hour, minutes, seconds, and milliseconds\n   *  (or as many of those are as present).  The length of the returned array\n   *  will therefore be an indication of the precision.\n   *  It will not include the timezone.\n   * @timeMatchData the result of matching the time portion of the string passed\n   *  into the constructor against the \"timeRE\" regular expression.\n   */\n\n\n  _getTimeParts(timeMatchData) {\n    var timeParts = []; // Finish parsing the data into pieces, for later use in building\n    // lower-precision versions of the date if needed.\n\n    timeParts = [timeMatchData[0]];\n    var timeZone = timeMatchData[4];\n\n    if (timeZone) {\n      // remove time zone from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length - timeZone.length);\n    }\n\n    var min = timeMatchData[1];\n\n    if (min) {\n      // remove minutes from hours\n      let hours = timeParts[0];\n      timeParts[0] = hours.slice(0, hours.length - min.length);\n      timeParts[1] = min;\n      var sec = timeMatchData[2];\n\n      if (sec) {\n        // remove seconds from minutes\n        timeParts[1] = min.slice(0, min.length - sec.length);\n        timeParts[2] = sec;\n        var ms = timeMatchData[3];\n\n        if (ms) {\n          // remove milliseconds from seconds\n          timeParts[2] = sec.slice(0, sec.length - ms.length);\n          timeParts[3] = ms;\n        }\n      }\n    }\n\n    return timeParts;\n  }\n  /**\n   *  Returns a date object representing this time on a certain date.\n   */\n\n\n  _getDateObj() {\n    if (!this.dateObj) {\n      var precision = this._getPrecision(); // We cannot directly pass the string into the date constructor because\n      // (1) we don't want to introduce a time-dependent system date and (2) the\n      // time string might not have contained minutes, which are required by the\n      // Date constructor.\n\n\n      this.dateObj = this._dateAtPrecision(precision);\n    }\n\n    return this.dateObj;\n  }\n  /**\n   *  Creates a date object for the given timezone.  The returned date object\n   *  will have the specified date and time in the specified timezone.\n   * @param year...ms Just as in the Date constructor.\n   * @param timezoneOffset (optional) a string in the format (+-)HH:mm or Z, representing the\n   *  timezone offset.  If not provided, the local timzone will be assumed (as the\n   *  Date constructor does).\n   */\n\n\n  _createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset) {\n    var d = new Date(year, month, day, hour, minutes, seconds, ms);\n\n    if (timezoneOffset) {\n      // d is in local time.  Adjust for the timezone offset.\n      // First adjust the date by the timezone offset before reducing its\n      // precision.  Otherwise,\n      // @2018-11-01T-04:00 < @2018T-05:00\n      var localTimezoneMinutes = d.getTimezoneOffset();\n      var timezoneMinutes = 0; // if Z\n\n      if (timezoneOffset != 'Z') {\n        var timezoneParts = timezoneOffset.split(':'); // (+-)hours:minutes\n\n        var hours = parseInt(timezoneParts[0]);\n        timezoneMinutes = parseInt(timezoneParts[1]);\n        if (hours < 0) timezoneMinutes = -timezoneMinutes;\n        timezoneMinutes += 60 * hours;\n      } // localTimezoneMinutes has the inverse sign of its timezone offset\n\n\n      d = addMinutes(d, -localTimezoneMinutes - timezoneMinutes);\n    }\n\n    return d;\n  }\n\n}\n/**\n *  A map from a FHIRPath time units to a function used to add that\n *  quantity to a date/time.\n */\n\n\nFP_TimeBase.timeUnitToAddFn = {\n  \"year\": require('date-fns/add_years'),\n  \"month\": require('date-fns/add_months'),\n  \"week\": require('date-fns/add_weeks'),\n  \"day\": require('date-fns/add_days'),\n  \"hour\": require('date-fns/add_hours'),\n  \"minute\": require('date-fns/add_minutes'),\n  \"second\": require('date-fns/add_seconds'),\n  \"millisecond\": require('date-fns/add_milliseconds')\n};\n\nclass FP_DateTime extends FP_TimeBase {\n  /**\n   *  Constructs an FP_DateTime, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_DateTime.checkString instead.\n   */\n  constructor(dateStr) {\n    super(dateStr);\n  }\n  /**\n   *  Returns -1, 0, or 1 if this date time is less then, equal to, or greater\n   *  than otherDateTime.  Comparisons are made at the lesser of the two date time\n   *  precisions.\n   */\n\n\n  compare(otherDateTime) {\n    if (!(otherDateTime instanceof FP_DateTime)) throw 'Invalid comparison of a DateTime with something else';\n    return super.compare(otherDateTime);\n  }\n  /**\n   *  Returns the match data from matching timeRE against the time string.\n   *  Also sets this.precision.\n   */\n\n\n  _getMatchData() {\n    return super._getMatchData(dateTimeRE, 5);\n  }\n  /**\n   *  Returns an array of the pieces of the date time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  date time. The returned array will contain separate elements for the year,\n   *  month, day, hour, minutes, seconds, and milliseconds (or as many of those\n   *  are as present).  The length of the returned array will therefore be an\n   *  indication of the precision.  It will not include the timezone.\n   */\n\n\n  _getTimeParts() {\n    if (!this.timeParts) {\n      let timeMatchData = this._getMatchData();\n\n      let year = timeMatchData[0];\n      this.timeParts = [year];\n      var month = timeMatchData[1];\n\n      if (month) {\n        // Remove other information from year\n        this.timeParts[0] = year.slice(0, year.length - month.length);\n        this.timeParts[1] = month;\n        let day = timeMatchData[2];\n\n        if (day) {\n          // Remove day information from month\n          this.timeParts[1] = month.slice(0, month.length - day.length);\n          this.timeParts[2] = day;\n          let time = timeMatchData[3];\n\n          if (time) {\n            // Remove time from day\n            this.timeParts[2] = day.slice(0, day.length - time.length);\n            if (time[0] === 'T') // remove T from hour\n              timeMatchData[3] = time.slice(1);\n            this.timeParts = this.timeParts.concat(super._getTimeParts(timeMatchData.slice(3)));\n          }\n        }\n      }\n    }\n\n    return this.timeParts;\n  }\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   * @param precision the new precision, which is assumed to be less than\n   *  or equal to the current precision.\n   */\n\n\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n\n    var timezoneOffset = this._getMatchData()[7]; // Get the date object first at the current precision.\n\n\n    var thisPrecision = this._getPrecision();\n\n    var year = parseInt(timeParts[0]);\n    var month = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) - 1 : 0;\n    var day = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 1;\n    var hour = thisPrecision > 2 ? parseInt(timeParts[3]) : 0;\n    var minutes = thisPrecision > 3 ? parseInt(timeParts[4].slice(1)) : 0;\n    var seconds = thisPrecision > 4 ? parseInt(timeParts[5].slice(1)) : 0;\n    var ms = timeParts.length > 6 ? parseInt(timeParts[6].slice(1)) : 0;\n\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset);\n\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      year = d.getFullYear();\n      month = precision > 0 ? d.getMonth() : 0;\n      day = precision > 1 ? d.getDate() : 1;\n      hour = precision > 2 ? d.getHours() : 0;\n      minutes = precision > 3 ? d.getMinutes() : 0; // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n\n      d = new Date(year, month, day, hour, minutes);\n    }\n\n    return d;\n  }\n\n}\n/**\n *  Tests str to see if it is convertible to a DateTime.\n * @return If str is convertible to a DateTime, returns an FP_DateTime;\n *  otherwise returns null.\n */\n\n\nFP_DateTime.checkString = function (str) {\n  let d = new FP_DateTime(str);\n  if (!d._getMatchData()) d = null;\n  return d;\n};\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\n\n\nFP_DateTime._timeUnitToDatePrecision = {\n  \"year\": 0,\n  \"month\": 1,\n  \"week\": 2,\n  // wk is just 7*d\n  \"day\": 2,\n  \"hour\": 3,\n  \"minute\": 4,\n  \"second\": 5,\n  \"millisecond\": 6\n};\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\n\nFP_DateTime._datePrecisionToTimeUnit = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"];\n\nclass FP_Time extends FP_TimeBase {\n  /**\n   *  Constructs an FP_Time, assuming dateStr is valid.  If you don't know\n   *  whether a string is a valid DateTime, use FP_Time.checkString instead.\n   */\n  constructor(timeStr) {\n    if (timeStr[0] == 'T') timeStr = timeStr.slice(1);\n    super(timeStr);\n  }\n  /**\n   *  Returns -1, 0, or 1 if this time is less then, equal to, or greater\n   *  than otherTime.  Comparisons are made at the lesser of the two time\n   *  precisions.\n   */\n\n\n  compare(otherTime) {\n    if (!(otherTime instanceof FP_Time)) throw 'Invalid comparison of a time with something else';\n    return super.compare(otherTime);\n  }\n  /**\n   *  Returns a new Date object for a time equal to what this time would be if\n   *  the string passed into the constructor had the given precision.\n   *  The \"date\" portion of the returned Date object is not meaningful, and\n   *  should be ignored.\n   * @param precision the new precision, which is assumed to be less than the\n   *  or equal to the current precision.  A precision of 0 means the hour.\n   */\n\n\n  _dateAtPrecision(precision) {\n    var timeParts = this._getTimeParts();\n\n    var timezoneOffset = this._getMatchData()[4]; // Get the date object first at the current precision.\n\n\n    var thisPrecision = this._getPrecision();\n\n    var year = 2010; // Have to pick some year for the date object\n\n    var month = 0;\n    var day = 1;\n    var hour = parseInt(timeParts[0]);\n    var minutes = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) : 0;\n    var seconds = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 0;\n    var ms = timeParts.length > 3 ? parseInt(timeParts[3].slice(1)) : 0;\n\n    var d = this._createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset);\n\n    if (timezoneOffset) {\n      // Keep the date the same (in the local timezone), so it is not a relevant\n      // factor when comparing different times.\n      d.setYear(year);\n      d.setMonth(month);\n      d.setDate(day);\n    }\n\n    if (precision < thisPrecision) {\n      // Adjust the precision\n      hour = d.getHours();\n      minutes = precision > 0 ? d.getMinutes() : 0; // Here the precision will always be less than the maximum\n      // due to the condition in the if statement: \"precision < thisPrecision\"\n\n      d = new Date(year, month, day, hour, minutes);\n    }\n\n    return d;\n  }\n  /**\n   *  Returns the match data from matching timeRE against the time string.\n   *  Also sets this.precision.\n   */\n\n\n  _getMatchData() {\n    return super._getMatchData(timeRE, 2);\n  }\n  /**\n   *  Returns an array of the pieces of the time string passed into the\n   *  constructor, for use in constructing lower precision versions of the\n   *  time. The returned array will contain separate elements for the hour,\n   *  minutes, seconds, and milliseconds (or as many of those are as present).\n   *  The length of the returned array will therefore be an indication of the\n   *  precision.  It will not include the timezone.\n   */\n\n\n  _getTimeParts() {\n    if (!this.timeParts) {\n      this.timeParts = super._getTimeParts(this._getMatchData());\n    }\n\n    return this.timeParts;\n  }\n\n}\n/**\n *  Tests str to see if it is convertible to a Time.\n * @return If str is convertible to a Time, returns an FP_Time;\n *  otherwise returns null.\n */\n\n\nFP_Time.checkString = function (str) {\n  let d = new FP_Time(str);\n  if (!d._getMatchData()) d = null;\n  return d;\n};\n/**\n *  A map from FHIRPath time units to the internal DateTime \"precision\" number.\n */\n\n\nFP_Time._timeUnitToDatePrecision = {\n  \"hour\": 0,\n  \"minute\": 1,\n  \"second\": 2,\n  \"millisecond\": 3\n};\n/**\n *  The inverse of _timeUnitToDatePrecision.\n */\n\nFP_Time._datePrecisionToTimeUnit = [\"hour\", \"minute\", \"second\", \"millisecond\"];\n/**\n *  Returns either the given number or a string with the number prefixed by\n *  zeros if the given number is less than the given length.\n * @param num the nubmer to format\n * @param len the number of returned digits.  For now this must either be 2 or\n *  3. (Optional-- default is 2).\n */\n\nfunction formatNum(num, len) {\n  // Could use String.repeat, but that requires convertin num to an string first\n  // to get its length.  This might be slightly faster given that we only need 2\n  // or three 3 digit return values.\n  var rtn = num;\n  if (len === 3 && num < 100) rtn = '0' + num;\n  if (num < 10) rtn = '0' + rtn;\n  return rtn;\n}\n/**\n *  Formats the given date object into an ISO8601 datetime string, expressing it\n *  in the local timezone.\n * @date the date to format\n * @precision the precision at which to terminate string string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\n\n\nFP_DateTime.isoDateTime = function (date, precision) {\n  if (precision === undefined) precision = 6; // maximum\n  // YYYY-MM-DDTHH:mm:ss.sss[+-]HH:mm\n  // Note:  Date.toISOString sets the timezone at 'Z', which I did not want.\n  // Actually, I wanted to keep the original timezone given in the constructor,\n  // but that is difficult due to daylight savings time changes.  (For instance,\n  // if you add 6 months, the timezone offset could change).\n\n  var rtn = '' + date.getFullYear();\n\n  if (precision > 0) {\n    rtn += '-' + formatNum(date.getMonth() + 1);\n\n    if (precision > 1) {\n      rtn += '-' + formatNum(date.getDate());\n\n      if (precision > 2) {\n        rtn += 'T' + formatNum(date.getHours());\n\n        if (precision > 3) {\n          rtn += ':' + formatNum(date.getMinutes());\n\n          if (precision > 4) {\n            rtn += ':' + formatNum(date.getSeconds());\n            if (date.getMilliseconds()) rtn += '.' + formatNum(date.getMilliseconds(), 3);\n          }\n        }\n      }\n    }\n  } // FHIRPath STU1 does not allow a timezone offset on a dateTime that does not\n  // have a time part (except that the grammar allows 'Z', which is\n  // inconsistent).\n\n\n  if (precision > 2) {\n    // Note:  getTimezoneoffset returns the offset for the local system at the\n    // given date.\n    var tzOffset = date.getTimezoneOffset(); // tzOffset is a number of minutes, and is positive for negative timezones,\n    // and negative for positive timezones.\n\n    var tzSign = tzOffset < 0 ? '+' : '-';\n    tzOffset = Math.abs(tzOffset);\n    var tzMin = tzOffset % 60;\n    var tzHour = (tzOffset - tzMin) / 60;\n    rtn += tzSign + formatNum(tzHour) + ':' + formatNum(tzMin);\n  }\n\n  return rtn;\n};\n/**\n *  Returns a date string in ISO format at the given precision level.\n * @date the date to format\n * @precision the precision at which to terminate string string.  (This is\n *  optional). If present, it will be an integer into the matching components of\n *  dateTimeRE.\n * @return a string in ISO8601 format.\n */\n\n\nFP_DateTime.isoDate = function (date, precision) {\n  if (precision === undefined || precision > 2) precision = 2;\n  return FP_DateTime.isoDateTime(date, precision);\n};\n/**\n *  A class that represents a node in a FHIR resource, with path and possibly type\n *  information.\n */\n\n\nclass ResourceNode {\n  /**\n   *  Constructs a instance for the given node (\"data\") of a resource.  If the\n   *  data is the top-level node of a resouce, the path and type parameters will\n   *  be ignored in favor of the resource's resourceType field.\n   * @param data the node's data or value (which might be an object with\n   *  sub-nodes, an array, or FHIR data type)\n   * @param path the node's path in the resource (e.g. Patient.name).  If the\n   *  data's type can be determined from data, that will take precedence over\n   *  this parameter.\n   * @param _data additional data stored in a property named with \"_\" prepended,\n   *  see https://www.hl7.org/fhir/element.html#json for details.\n   */\n  constructor(data, path, _data) {\n    // If data is a resource (maybe a contained resource) reset the path\n    // information to the resource type.\n    if (data.resourceType) path = data.resourceType;\n    this.path = path;\n    this.data = getResourceNodeData(data, path);\n    this._data = _data || {};\n  }\n  /**\n   * Returns resource node type info.\n   * @return {TypeInfo}\n   */\n\n\n  getTypeInfo() {\n    const namespace = TypeInfo.FHIR; // TODO: Here we should use property index which we will extract from the specification\n\n    if (this.path.indexOf('.') === -1) {\n      return new TypeInfo({\n        namespace,\n        name: this.path\n      });\n    }\n\n    return TypeInfo.createByValueInNamespace({\n      namespace,\n      value: this.data\n    });\n  }\n\n  toJSON() {\n    return JSON.stringify(this.data);\n  }\n\n}\n/**\n * Prepare data for ResourceNode:\n * Converts value from FHIR Quantity to FHIRPath System.Quantity.\n * The Mapping from FHIR Quantity to FHIRPath System.Quantity is explained here:\n * https://www.hl7.org/fhir/fhirpath.html#quantity\n * @param {Object|...} data\n * @param {string} path\n * @return {FP_Quantity|Object|...}\n */\n\n\nfunction getResourceNodeData(data, path) {\n  if (path === 'Quantity' && data.system === ucumSystemUrl) {\n    if (typeof data.value === 'number' && typeof data.code === 'string') {\n      data = new FP_Quantity(data.value, FP_Quantity.mapUCUMCodeToTimeUnits[data.code] || '\\'' + data.code + '\\'');\n    }\n  }\n\n  return data;\n}\n/**\n *  Returns a ResourceNode for the given data node, checking first to see if the\n *  given node is already a ResourceNode.  Takes the same arguments as the\n *  constructor for ResourceNode.\n */\n\n\nResourceNode.makeResNode = function (data, path, _data) {\n  return data instanceof ResourceNode ? data : new ResourceNode(data, path, _data);\n};\n/**\n * Object class defining type information.\n * Used for minimal type support.\n * (see http://hl7.org/fhirpath/#types-and-reflection)\n */\n\n\nclass TypeInfo {\n  constructor(_ref) {\n    let {\n      name,\n      namespace\n    } = _ref;\n    this.name = name;\n    this.namespace = namespace;\n  }\n  /**\n   * Checks for equality with another TypeInfo object, or that another TypeInfo\n   * object specifies a superclass for the type specified by this object.\n   * @param {TypeInfo} other\n   * @return {boolean}\n   */\n\n\n  is(other) {\n    // TODO: Here we should use type hierarchy index which we will extract from the specification\n    return other instanceof TypeInfo && this.name === other.name && (!this.namespace || !other.namespace || this.namespace === other.namespace);\n  }\n\n} // Available namespaces:\n\n\nTypeInfo.System = 'System';\nTypeInfo.FHIR = 'FHIR';\n/**\n * Creates new TypeInfo object for specified namespace and value\n * @param {String} namespace\n * @param {*} value\n * @return {TypeInfo}\n */\n\nTypeInfo.createByValueInNamespace = function (_ref2) {\n  let {\n    namespace,\n    value\n  } = _ref2;\n  let name = typeof value;\n\n  if (Number.isInteger(value)) {\n    name = 'integer';\n  } else if (name === \"number\") {\n    name = 'decimal';\n  } else if (value instanceof FP_DateTime) {\n    name = 'dateTime';\n  } else if (value instanceof FP_Time) {\n    name = 'time';\n  } else if (value instanceof FP_Quantity) {\n    name = 'Quantity';\n  }\n\n  if (namespace === TypeInfo.System) {\n    name = name.replace(/^\\w/, c => c.toUpperCase());\n  } // TODO: currently can return name = 'object\" or \"Object\" which is probably wrong\n\n\n  return new TypeInfo({\n    namespace,\n    name\n  });\n};\n/**\n * Retrieves TypeInfo by value\n * @param {*} value\n * @return {TypeInfo}\n */\n\n\nTypeInfo.fromValue = function (value) {\n  return value instanceof ResourceNode ? value.getTypeInfo() : TypeInfo.createByValueInNamespace({\n    namespace: TypeInfo.System,\n    value\n  });\n};\n/**\n * Basic \"type()\" function implementation\n * (see http://hl7.org/fhirpath/#reflection)\n * @param {Array<*>} coll - input collection\n * @return {Array<*>}\n */\n\n\nfunction typeFn(coll) {\n  return coll.map(value => {\n    return TypeInfo.fromValue(value);\n  });\n}\n/**\n * Implementation of function \"is(type : type specifier)\" and operator \"is\"\n * (see http://hl7.org/fhirpath/#is-type-specifier)\n * @param {Array<*>} coll - input collection\n * @param {TypeInfo} typeInfo\n * @return {boolean|[]}\n */\n\n\nfunction isFn(coll, typeInfo) {\n  if (coll.length === 0) {\n    return [];\n  }\n\n  if (coll.length > 1) {\n    throw new Error(\"Expected singleton on left side of is, got \" + JSON.stringify(coll));\n  }\n\n  return TypeInfo.fromValue(coll[0]).is(typeInfo);\n}\n\nmodule.exports = {\n  FP_Type: FP_Type,\n  FP_TimeBase: FP_TimeBase,\n  FP_DateTime: FP_DateTime,\n  FP_Time: FP_Time,\n  FP_Quantity: FP_Quantity,\n  timeRE: timeRE,\n  dateTimeRE: dateTimeRE,\n  ResourceNode: ResourceNode,\n  TypeInfo: TypeInfo,\n  typeFn,\n  isFn\n};","map":null,"metadata":{},"sourceType":"script"}