{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unit = void 0;\n\nvar _ucumFunctions = _interopRequireDefault(require(\"./ucumFunctions.js\"));\n\nvar intUtils_ = _interopRequireWildcard(require(\"./ucumInternalUtils.js\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * This class represents one unit of measure.  It includes\n * functions to cover constructor, accessor, and assignment tasks as\n * well as operators to calculate multiplication, division and raising\n * to a power.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\n\n\nvar Ucum = require('./config.js').Ucum;\n\nvar Dimension = require('./dimension.js').Dimension;\n\nvar UnitTables;\n\nvar isInteger = require(\"is-integer\");\n\nclass Unit {\n  /**\n   * Constructor.\n   *\n   * @param attrs an optional parameter that may be:\n   *  a string, which is parsed by the unit parser, which creates\n   *  the unit from the parsed string; or\n   *  a hash containing all or some values for the attributes of\n   *  the unit, where the keys are the attribute names, without a\n   *  trailing underscore, e.g., name instead of name_; or\n   *  null, in which case an empty hash is created and used to\n   *  set the values forthe attributes.\n   *  If a hash (empty or not) is used, attributes for which no value\n   *  is specified are assigned a default value.\n   *\n   */\n  constructor() {\n    let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Process the attrs hash passed in, which may be empty.\n    // Create and assign values (from the attrs hash or defaults) to all\n    // attributes.  From Class Declarations in Understanding ECMAScript,\n    // https://leanpub.com/understandinges6/read/#leanpub-auto-class-declarations,\n    //   \"Own properties, properties that occur on the instance rather than the\n    //    prototype, can only be created inside of a class constructor or method.\n    //    It's recommended to create all possible own properties inside of the\n    //    constructor function so there's a single place that's responsible for\n    //    all of them.\"\n\n    /*\n     * Flag indicating whether or not this is a base unit\n     */\n    this.isBase_ = attrs['isBase_'] || false;\n    /*\n     * The unit name, e.g., meter\n     */\n\n    this.name_ = attrs['name_'] || '';\n    /*\n     * The unit's case-sensitive code, e.g., m\n     */\n\n    this.csCode_ = attrs['csCode_'] || '';\n    /*\n     * The unit's case-insensitive code, e.g., M\n     */\n\n    this.ciCode_ = attrs['ciCode_'] || '';\n    /*\n     * The unit's property, e.g., length\n     */\n\n    this.property_ = attrs['property_'] || '';\n    /*\n     * The magnitude of the unit, e.g., 3600/3937 for a yard,\n     * where a yard - 3600/3973 * m(eter).  The Dimension\n     * property specifies the meter - which is the unit on which\n     * a yard is based, and this magnitude specifies how to figure\n     * this unit based on the base unit.\n     */\n\n    this.magnitude_ = attrs['magnitude_'] || 1;\n    /*\n     * The Dimension object of the unit\n     */\n\n    if (attrs['dim_'] === undefined || attrs['dim_'] === null) {\n      this.dim_ = new Dimension();\n    } // When the unit data stored in json format is reloaded, the dimension data\n    // is recognized as a a hash, not as a Dimension object.\n    else if (attrs['dim_']['dimVec_'] !== undefined) {\n      this.dim_ = new Dimension(attrs['dim_']['dimVec_']);\n    } else if (attrs['dim_'] instanceof Dimension) {\n      this.dim_ = attrs['dim_'];\n    } else if (attrs['dim_'] instanceof Array || isInteger(attrs['dim_'])) {\n      this.dim_ = new Dimension(attrs['dim_']);\n    } else {\n      this.dim_ = new Dimension();\n    }\n    /*\n     * The print symbol of the unit, e.g., m\n     */\n\n\n    this.printSymbol_ = attrs['printSymbol_'] || null;\n    /*\n     * The class of the unit, where given, e.g., dimless\n     */\n\n    this.class_ = attrs['class_'] || null;\n    /*\n     * A flag indicating whether or not the unit is metric\n     */\n\n    this.isMetric_ = attrs['isMetric_'] || false;\n    /*\n     * The \"variable\" - which I think is used only for base units\n     * The symbol for the variable as used in equations, e.g., s for distance\n     */\n\n    this.variable_ = attrs['variable_'] || null; // comes from 'dim' in XML\n\n    /*\n     * The conversion function\n     */\n\n    this.cnv_ = attrs['cnv_'] || null;\n    /*\n     * The conversion prefix\n     */\n\n    this.cnvPfx_ = attrs['cnvPfx_'] || 1;\n    /*\n     * Flag indicating whether or not this is a \"special\" unit, i.e., is\n     * constructed using a function specific to the measurement, e.g.,\n     * fahrenheit and celsius\n     */\n\n    this.isSpecial_ = attrs['isSpecial_'] || false;\n    /*\n     * Flag indicating whether or not this is an arbitrary unit\n     */\n\n    this.isArbitrary_ = attrs['isArbitrary_'] || false;\n    /*\n     * Integer indicating what level of exponent applies to a mole-based portion\n     * of the unit.  So, for the unit \"mol\", this will be 1.  For \"mol2\" this\n     * will be 2.  For \"1/mol\" this will be -1.  Any unit that does not include\n     * a mole will have a 0 in this field.  This is used to determine\n     * commensurability for mole<->mass conversions.\n     */\n\n    this.moleExp_ = attrs['moleExp_'] || 0;\n    /*\n     * Added when added LOINC list of units\n     * synonyms are used by the autocompleter to enhance lookup capabilities\n     * while source says where the unit first shows up.  Current sources are\n     * UCUM - which are units from the unitsofmeasure.org list and LOINC -\n     * which are units from the LOINC data.\n     */\n\n    this.synonyms_ = attrs['synonyms_'] || null;\n    this.source_ = attrs['source_'] || null;\n    this.loincProperty_ = attrs['loincProperty_'] || null;\n    this.category_ = attrs['category_'] || null;\n    this.guidance_ = attrs['guidance_'] || null;\n    /*\n     * Used to compute dimension; storing for now until I complete\n     * unit definition parsing\n     */\n\n    /*\n     * Case sensitive (cs) and case insensitive (ci) base unit strings,\n     * includes exponent and prefix if applicable - specified in\n     * <value Unit=x UNIT=X value=\"nnn\">nnn</value> -- the unit part --\n     * in the ucum-essence.xml file, and may be specified by a user\n     * when requesting conversion or validation of a unit string.  The\n     * magnitude (base factor) is used with this to determine the new unit.\n     * For example, a Newton (unit code N) is created from the string\n     * kg.m/s2, and the value of 1 (base factor defined below). An hour\n     * (unit code h) is created from the unit min (minute) with a value\n     * of 60.\n     */\n\n    this.csUnitString_ = attrs['csUnitString_'] || null;\n    this.ciUnitString_ = attrs['ciUnitString_'] || null;\n    /*\n     * String and numeric versions of factor applied to unit specified in\n     * <value Unit=x UNIT=X value=\"nnn\">nnn</value> -- the value part\n     */\n\n    this.baseFactorStr_ = attrs['baseFactorStr_'] || null;\n    this.baseFactor_ = attrs['baseFactor_'] || null;\n    /*\n     * Flag used to indicate units where the definition process failed\n     * when parsing units from the official units definitions file\n     * (currently using the ucum-essence.xml file).  We keep these\n     * so that we can use them to at least validate them as valid\n     * units, but we don't try to convert them.   This is temporary\n     * and only to account for instances where the code does not\n     * take into account various special cases in the xml file.\n     *\n     * This is NOT used when trying to validate a unit string\n     * submitted during a conversion or validation attempt.\n     */\n\n    this.defError_ = attrs['defError_'] || false;\n  } // end constructor\n\n  /**\n   * Assign the unity (= dimensionless unit 1) to this unit.\n   *\n   * @return this unit\n   */\n\n\n  assignUnity() {\n    this.name_ = \"\";\n    this.magnitude_ = 1;\n    if (!this.dim_) this.dim_ = new Dimension();\n    this.dim_.assignZero();\n    this.cnv_ = null;\n    this.cnvPfx_ = 1;\n    return this;\n  } // end assignUnity\n\n  /**\n   * This assigns one or more values, as provided in the hash passed in,\n   * to this unit.\n   *\n   * @param vals hash of values to be assigned to the attributes\n   *        specified by the key(s), which should be the attribute\n   *        name without the trailing underscore, e.g., name instead\n   *        of name_.\n   * @return nothing\n   */\n\n\n  assignVals(vals) {\n    for (let key in vals) {\n      let uKey = !key.charAt(key.length - 1) === '_' ? key + '_' : key;\n      if (this.hasOwnProperty(uKey)) this[uKey] = vals[key];else throw new Error(`Parameter error; ${key} is not a property of a Unit`);\n    }\n  } // end assignVals\n\n  /**\n   * This creates a clone of this unit.\n   *\n   * @return the clone\n   */\n\n\n  clone() {\n    let retUnit = new Unit();\n    Object.getOwnPropertyNames(this).forEach(val => {\n      if (val === 'dim_') {\n        if (this['dim_']) retUnit['dim_'] = this['dim_'].clone();else retUnit['dim_'] = null;\n      } else retUnit[val] = this[val];\n    });\n    return retUnit;\n  } // end clone\n\n  /**\n   * This assigns all properties of a unit passed to it to this unit.\n   *\n   * @param unit2 the unit whose properties are to be assigned to this one.\n   * @return nothing; this unit is updated\n   */\n\n\n  assign(unit2) {\n    Object.getOwnPropertyNames(unit2).forEach(val => {\n      if (val === 'dim_') {\n        if (unit2['dim_']) this['dim_'] = unit2['dim_'].clone();else this['dim_'] = null;\n      } else {\n        this[val] = unit2[val];\n      }\n    });\n  } // end assign\n\n  /**\n   * This determines whether or not object properties of the unit\n   * passed in are equal to the corresponding properties in this unit.\n   * The following properties are the only ones checked:\n   *   magnitude_, dim_, cnv_ and cnvPfx_\n   *\n   * @param unit2 the unit whose properties are to be checked.\n   * @return boolean indicating whether or not they match\n   */\n\n\n  equals(unit2) {\n    return this.magnitude_ === unit2.magnitude_ && this.cnv_ === unit2.cnv_ && this.cnvPfx_ === unit2.cnvPfx_ && (this.dim_ === null && unit2.dim_ === null || this.dim_.equals(unit2.dim_));\n  } // end equals\n\n  /**\n   * This method compares every attribute of two objects to determine\n   * if they all match.\n   *\n   * @param unit2 the unit that is to be compared to this unit\n   * @return boolean indicating whether or not every attribute matches\n   */\n\n\n  fullEquals(unit2) {\n    let thisAttr = Object.keys(this).sort();\n    let u2Attr = Object.keys(unit2).sort();\n    let keyLen = thisAttr.length;\n    let match = keyLen === u2Attr.length; // check each attribute.   Dimension objects have to checked using\n    // the equals function of the Dimension class.\n\n    for (let k = 0; k < keyLen && match; k++) {\n      if (thisAttr[k] === u2Attr[k]) {\n        if (thisAttr[k] === 'dim_') match = this.dim_.equals(unit2.dim_);else match = this[thisAttr[k]] === unit2[thisAttr[k]];\n      } else match = false;\n    } // end do for each key and attribute\n\n\n    return match;\n  } // end of fullEquals\n\n  /**\n   * This returns the value of the property named by the parameter\n   * passed in.\n   *\n   * @param propertyName name of the property to be returned, with\n   *        or without the trailing underscore.\n   * @return the requested property, if found for this unit\n   * @throws an error if the property is not found for this unit\n   */\n\n\n  getProperty(propertyName) {\n    let uProp = propertyName.charAt(propertyName.length - 1) === '_' ? propertyName : propertyName + '_';\n    return this[uProp];\n  } // end getProperty\n\n  /**\n   * Takes a measurement consisting of a number of units and a unit and returns\n   * the equivalent number of this unit.  So, 15 mL would translate\n   * to 1 tablespoon if this object is a tablespoon.\n   *\n   * Note that the number returned may not be what is normally expected.\n   * For example, converting 10 Celsius units to Fahrenheit would \"normally\"\n   * return a value of 50.   But in this case you'll get back something like\n   * 49.99999999999994.\n   *\n   * If either unit is an arbitrary unit an exception is raised.\n   *\n   * @param num the magnitude for the unit to be translated (e.g. 15 for 15 mL)\n   * @param fromUnit the unit to be translated to one of this type (e.g. a mL unit)\n   *\n   * @return the number of converted units (e.g. 1 for 1 tablespoon)\n   * @throws an error if the dimension of the fromUnit differs from this unit's\n   * dimension\n   */\n\n\n  convertFrom(num, fromUnit) {\n    let newNum = 0.0;\n    if (this.isArbitrary_) throw new Error(`Attempt to convert arbitrary unit ${this.name_}`);\n    if (fromUnit.isArbitrary_) throw new Error(`Attempt to convert to arbitrary unit ${fromUnit.name_}`); // reject request if both units have dimensions that are not equal\n\n    if (fromUnit.dim_ && this.dim_ && !fromUnit.dim_.equals(this.dim_)) {\n      // check first to see if a mole<->mass conversion is appropriate\n      if (this.isMoleMassCommensurable(fromUnit)) {\n        throw new Error(Ucum.needMoleWeightMsg_);\n      } else {\n        throw new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` + `to ${this.csCode_}.`);\n      }\n    } // reject request if there is a \"from\" dimension but no \"to\" dimension\n\n\n    if (fromUnit.dim_ && (!this.dim_ || this.dim_.isNull())) {\n      throw new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` + `to ${this.csCode_}.`);\n    } // reject request if there is a \"to\" dimension but no \"from\" dimension\n\n\n    if (this.dim_ && (!fromUnit.dim_ || fromUnit.dim_.isNull())) {\n      throw new Error(`Sorry.  ${fromUnit.csCode_} cannot be converted ` + `to ${this.csCode_}.`);\n    }\n\n    let fromCnv = fromUnit.cnv_;\n    let fromMag = fromUnit.magnitude_; // If the same conversion function is specified for both units, which\n    // includes neither unit having a conversion function, multiply the\n    // \"from\" unit's magnitude by the number passed in and then divide\n    // that result by this unit's magnitude.  Do this for units with\n    // and without dimension vectors.  PROBLEM with 2 non-commensurable\n    // units with no dimension vector or function, e.g., byte to mol\n\n    if (fromCnv === this.cnv_) {\n      newNum = num * fromMag / this.magnitude_;\n    } // else use a function to get the number to be returned\n    else {\n      let x = 0.0;\n\n      if (fromCnv != null) {\n        // turn num * fromUnit.magnitude into its ratio scale equivalent,\n        // e.g., convert Celsius to Kelvin\n        let fromFunc = _ucumFunctions.default.forName(fromCnv);\n\n        x = fromFunc.cnvFrom(num * fromUnit.cnvPfx_) * fromMag; //x = fromFunc.cnvFrom(num * fromMag) * fromUnit.cnvPfx_;\n      } else {\n        x = num * fromMag;\n      }\n\n      if (this.cnv_ != null) {\n        // turn mag * origUnit on ratio scale into a non-ratio unit,\n        // e.g. convert Kelvin to Fahrenheit\n        let toFunc = _ucumFunctions.default.forName(this.cnv_);\n\n        newNum = toFunc.cnvTo(x / this.magnitude_) / this.cnvPfx_;\n      } else {\n        newNum = x / this.magnitude_;\n      }\n    } // end if either unit has a conversion function\n\n\n    return newNum;\n  } // end convertFrom\n\n  /**\n   * Takes a number and a target unit and returns the number for a measurement\n   * of this unit that corresponds to the number of the target unit passed in.\n   * So, 1 tablespoon (where this unit represents a tablespoon) would translate\n   * to 15 mL.\n   *\n   * See the note on convertFrom about return values.\n   *\n   * @param mag the magnitude for this unit (e.g. 1 for 1 tablespoon)\n   * @param toUnit the unit to which this unit is to be translated\n   *  (e.g. an mL unit)\n   *\n   * @return the converted number value (e.g. 15 mL)\n   * @throws an error if the dimension of the toUnit differs from this unit's\n   *   dimension\n   */\n\n\n  convertTo(num, toUnit) {\n    return toUnit.convertFrom(num, this);\n  } // end convertTo\n\n  /**\n   * Takes a given number of this unit returns the number of this unit\n   * if it is converted into a coherent unit.  Does not change this unit.\n   *\n   * If this is a coherent unit already, just gives back the number\n   * passed in.\n   *\n   * @param num the number for the coherent version of this unit\n   * @return the number for the coherent version of this unit\n   */\n\n\n  convertCoherent(num) {\n    // convert mag' * u' into canonical number * u on ratio scale\n    if (this.cnv_ !== null) num = this.cnv_.f_from(num / this.cnvPfx_) * this.magnitude_;\n    return num;\n  } // end convertCoherent\n\n  /**\n   * Mutates this unit into a coherent unit and converts a given number of\n   * units to the appropriate value for this unit as a coherent unit\n   *\n   * @param num the number for this unit before conversion\n   * @return the number of this unit after conversion\n   * @throws an error if the dimensions differ\n   */\n\n\n  mutateCoherent(num) {\n    // convert mu' * u' into canonical mu * u on ratio scale\n    num = this.convertCoherent(num); // mutate to coherent unit\n\n    this.magnitude_ = 1;\n    this.cnv_ = null;\n    this.cnvPfx_ = 1;\n    this.name_ = \"\"; // build a name as a term of coherent base units\n    // This is probably ALL WRONG and a HORRIBLE MISTAKE\n    // but until we figure out what the heck the name being\n    // built here really is, it will have to stay.\n\n    for (let i = 0, max = Dimension.getMax(); i < max; i++) {\n      let elem = this.dim_.getElementAt(i);\n\n      let tabs = this._getUnitTables();\n\n      let uA = tabs.getUnitsByDimension(new Dimension(i));\n      if (uA == null) throw new Error(`Can't find base unit for dimension ${i}`);\n      this.name_ = uA.name + elem;\n    }\n\n    return num;\n  } // end mutateCoherent\n\n  /**\n   * Calculates the number of units that would result from converting a unit\n   * expressed in mass/grams to a unit expressed in moles.  The \"this\" unit is\n   * the unit expressed in some form of mass (g, mg, mmg, kg, whatever) and the\n   * target or \"to\" unit - the molUnit parameter - is a unit expressed in moles\n   * - mol, umol, mmol, etc.  The unit expressions surrounding the moles and\n   * mass must be convertible.  No validation of this requirement is performed.\n   *\n   * @param amt the quantity of this unit to be converted\n   * @param molUnit the target/to unit for which the converted # is wanted\n   * @param molecularWeight the molecular weight of the substance for which the\n   *  conversion is being made\n   * @return the equivalent amount in molUnit\n   */\n\n\n  convertMassToMol(amt, molUnit, molecularWeight) {\n    // The prefix values that have been applied to this unit, which is the mass\n    // (grams) unit, are reflected in the magnitude.  So the number of moles\n    // represented by this unit equals the number of grams -- amount * magnitude\n    // divided by the molecular Weight\n    let molAmt = this.magnitude_ * amt / molecularWeight; // The molUnit's basic magnitude, before prefixes are applied,\n    // is avogadro's number, get that and divide it out of the current magnitude.\n\n    let tabs = this._getUnitTables();\n\n    let avoNum = tabs.getUnitByCode('mol').magnitude_;\n    let molesFactor = molUnit.magnitude_ / avoNum; // return the molAmt divided by the molesFactor as the number of moles\n    // for the molUnit\n\n    return molAmt / molesFactor;\n  }\n  /**\n   * Calculates the number of units that would result from converting a unit\n   * expressed in moles to a unit expressed in mass (grams).  The \"this\" unit\n   * is the unit expressed in some form of moles, e.g., mol, umol, mmol, etc.,\n   * and the target or \"to\" unit is a unit expressed in some form of mass, e.g.,\n   * g, mg, mmg, kg, etc.  Any unit expressions surrounding the moles and mass\n   * must be convertible. No validation of this requirement is performed.\n   *\n   * @param amt the quantity of this unit to be converted\n   * @param massUnit the target/to unit for which the converted # is wanted\n   * @param molecularWeight the molecular weight of the substance for which the\n   *  conversion is being made\n   * @return the equivalent amount in massUnit\n   */\n\n\n  convertMolToMass(amt, massUnit, molecularWeight) {\n    // A simple mole unit has a magnitude of avogadro's number.  Get that\n    // number now (since not everyone agrees on what it is, and what is\n    // being used in this system might change).\n    let tabs = this._getUnitTables();\n\n    let avoNum = tabs.getUnitByCode('mol').magnitude_; // Determine what prefix values (mg or mg/dL, etc.) have been applied to\n    // this unit by dividing the simple mole unit magnitude out of the\n    // current mole unit magnitude.\n\n    let molesFactor = this.magnitude_ / avoNum; // The number of grams (mass) is equal to the number of moles (amt)\n    // times the molecular weight.  We also multiply that by the prefix values\n    // applied to the current unit (molesFactor) to get the grams for this\n    // particular unit.\n\n    let massAmt = molesFactor * amt * molecularWeight; // Finally, we return the mass amount/grams for this particular unit\n    // divided by any effects of prefixes applied to the \"to\" unit, which\n    // is assumed to be some form of a gram unit\n\n    return massAmt / massUnit.magnitude_;\n  }\n  /**\n   * Mutates this unit into a unit on a ratio scale and converts a specified\n   * number of units to an appropriate value for this converted unit\n   *\n   * @param num the number of this unit before it's converted\n   * @return the magnitude of this unit after it's converted\n   * @throw an error if the dimensions differ\n   */\n\n\n  mutateRatio(num) {\n    if (this.cnv_ == null) return this.mutateCoherent(num);else return num;\n  } // end mutateRatio\n\n  /**\n   * Multiplies this unit with a scalar. Special meaning for\n   * special units so that (0.1*B) is 1 dB.\n   *\n   * This function DOES NOT modify this unit.\n   *\n   * @param s the value by which this unit is to be multiplied\n   * @return a copy this unit multiplied by s\n   * */\n\n\n  multiplyThis(s) {\n    let retUnit = this.clone();\n    if (retUnit.cnv_ != null) retUnit.cnvPfx_ *= s;else retUnit.magnitude_ *= s;\n    let mulVal = s.toString();\n    retUnit.name_ = this._concatStrs(mulVal, '*', this.name_, '[', ']');\n    retUnit.csCode_ = this._concatStrs(mulVal, '.', this.csCode_, '(', ')');\n    retUnit.ciCode_ = this._concatStrs(mulVal, '.', this.ciCode_, '(', ')');\n    retUnit.printSymbol_ = this._concatStrs(mulVal, '.', this.printSymbol_, '(', ')');\n    return retUnit;\n  } // end multiplyThis\n\n  /**\n   * Multiplies this unit with another unit. If one of the\n   * units is a non-ratio unit the other must be dimensionless or\n   * else an exception is thrown.\n   *\n   * This function does NOT modify this unit\n   * @param unit2 the unit to be multiplied with this one\n   * @return this unit after it is multiplied\n   * @throws an error if one of the units is not on a ratio-scale\n   *         and the other is not dimensionless.\n   */\n\n\n  multiplyThese(unit2) {\n    var retUnit = this.clone();\n\n    if (retUnit.cnv_ != null) {\n      if (unit2.cnv_ == null && (!unit2.dim_ || unit2.dim_.isZero())) retUnit.cnvPfx_ *= unit2.magnitude_;else throw new Error(`Attempt to multiply non-ratio unit ${retUnit.name_} ` + 'failed.');\n    } // end if this unit has a conversion function\n    else if (unit2.cnv_ != null) {\n      if (!retUnit.dim_ || retUnit.dim_.isZero()) {\n        retUnit.cnvPfx_ = unit2.cnvPfx_ * retUnit.magnitude_;\n        retUnit.cnv_ = unit2.cnv_;\n      } else throw new Error(`Attempt to multiply non-ratio unit ${unit2.name_}`);\n    } // end if unit2 has a conversion function\n    // else neither unit has a conversion function\n    else {\n      retUnit.magnitude_ *= unit2.magnitude_;\n    } // end if unit2 does not have a conversion function\n    // If this.dim_ isn't there, clone the dimension in unit2 - if dimVec_\n    // is a dimension in unit2.dim_; else just transfer it to this dimension\n\n\n    if (!retUnit.dim_ || retUnit.dim_ && !retUnit.dim_.dimVec_) {\n      if (unit2.dim_) retUnit.dim_ = unit2.dim_.clone();else retUnit.dim_ = unit2.dim_;\n    } // Else this.dim_ is there.  If there is a dimension for unit2,\n    // add it to this one.\n    else if (unit2.dim_ && unit2.dim_ instanceof Dimension) {\n      retUnit.dim_.add(unit2.dim_);\n    } // Concatenate the unit info (name, code, etc) for all cases\n    // where the multiplication was performed (an error wasn't thrown)\n\n\n    retUnit.name_ = this._concatStrs(retUnit.name_, '*', unit2.name_, '[', ']');\n    retUnit.csCode_ = this._concatStrs(retUnit.csCode_, '.', unit2.csCode_, '(', ')');\n    if (retUnit.ciCode_ && unit2.ciCode_) retUnit.ciCode_ = this._concatStrs(retUnit.ciCode_, '.', unit2.ciCode_, '(', ')');else if (unit2.ciCode_) retUnit.ciCode_ = unit2.ciCode_;\n    retUnit.guidance_ = '';\n    if (retUnit.printSymbol_ && unit2.printSymbol_) retUnit.printSymbol_ = this._concatStrs(retUnit.printSymbol_, '.', unit2.printSymbol_, '(', ')');else if (unit2.printSymbol_) retUnit.printSymbol_ = unit2.printSymbol_; // Update the mole exponent count by adding the count for unit2 to the\n    // count for this unit.\n\n    retUnit.moleExp_ = retUnit.moleExp_ + unit2.moleExp_; // A unit that has the arbitrary attribute taints any unit created from it\n    // via an arithmetic operation.  Taint accordingly\n    // if (!retUnit.isMole_)\n    //   retUnit.isMole_ = unit2.isMole_ ;\n\n    if (!retUnit.isArbitrary_) retUnit.isArbitrary_ = unit2.isArbitrary_;\n    return retUnit;\n  } // end multiplyThese\n\n  /**\n   * Divides this unit by another unit. If this unit is not on a ratio\n   * scale an exception is raised. Mutating to a ratio scale unit\n   * is not possible for a unit, only for a measurement.\n   *\n   * This unit is NOT modified by this function.\n   * @param unit2 the unit by which to divide this one\n   * @return this unit after it is divided by unit2\n   * @throws an error if either of the units is not on a ratio scale.\n   * */\n\n\n  divide(unit2) {\n    var retUnit = this.clone();\n    if (retUnit.cnv_ != null) throw new Error(`Attempt to divide non-ratio unit ${retUnit.name_}`);\n    if (unit2.cnv_ != null) throw new Error(`Attempt to divide by non-ratio unit ${unit2.name_}`);\n    if (retUnit.name_ && unit2.name_) retUnit.name_ = this._concatStrs(retUnit.name_, '/', unit2.name_, '[', ']');else if (unit2.name_) retUnit.name_ = unit2.invertString(unit2.name_);\n    retUnit.csCode_ = this._concatStrs(retUnit.csCode_, '/', unit2.csCode_, '(', ')');\n    if (retUnit.ciCode_ && unit2.ciCode_) retUnit.ciCode_ = this._concatStrs(retUnit.ciCode_, '/', unit2.ciCode_, '(', ')');else if (unit2.ciCode_) retUnit.ciCode_ = unit2.invertString(unit2.ciCode_);\n    retUnit.guidance_ = '';\n    retUnit.magnitude_ /= unit2.magnitude_;\n    if (retUnit.printSymbol_ && unit2.printSymbol_) retUnit.printSymbol_ = this._concatStrs(retUnit.printSymbol_, '/', unit2.printSymbol_, '(', ')');else if (unit2.printSymbol_) retUnit.printSymbol_ = unit2.invertString(unit2.printSymbol_); // Continue if unit2 has a dimension object.\n    // If this object has a dimension object, subtract unit2's dim_ object from\n    // this one. The sub method will take care of cases where the dimVec_ arrays\n    // are missing on one or both dim_ objects.\n\n    if (unit2.dim_) {\n      if (retUnit.dim_) {\n        if (retUnit.dim_.isNull()) retUnit.dim_.assignZero();\n        retUnit.dim_ = retUnit.dim_.sub(unit2.dim_);\n      } // end if this.dim_ exists\n      // Else if this dim_ object is missing, clone unit2's dim_ object\n      // and give the inverted clone to this unit.\n      else retUnit.dim_ = unit2.dim_.clone().minus();\n    } // end if unit2 has a dimension object\n    // Update the mole exponent count by subtracting the count for unit2 from\n    // the // count for this unit.\n\n\n    retUnit.moleExp_ = retUnit.moleExp_ - unit2.moleExp_; // A unit that has the arbitrary attribute taints any unit created from\n    // it via an arithmetic operation.  Taint accordingly\n    // if (!retUnit.isMole_)\n    //   retUnit.isMole_ = unit2.isMole_ ;\n\n    if (!retUnit.isArbitrary_) retUnit.isArbitrary_ = unit2.isArbitrary_;\n    return retUnit;\n  } // end divide\n\n  /**\n   * Invert this unit with respect to multiplication. If this unit is not\n   * on a ratio scale an exception is thrown. Mutating to a ratio scale unit\n   * is not possible for a unit, only for a measurement (the magnitude and\n   * dimension).\n   *\n   *  This unit is modified by this function.\n   * @return this unit after being inverted\n   * @throws and error if this unit is not on a ratio scale\n   */\n\n\n  invert() {\n    if (this.cnv_ != null) throw new Error(`Attempt to invert a non-ratio unit - ${this.name_}`);\n    this.name_ = this.invertString(this.name_);\n    this.magnitude_ = 1 / this.magnitude_;\n    this.dim_.minus();\n    return this;\n  } // end invert\n\n  /**\n   * Inverts a string, where the string is assumed to be a code or a name\n   * of a division operation where the string is the divisor and the dividend\n   * is blank.\n   *\n   * @param the string to be inverted\n   * @return the inverted string\n   */\n\n\n  invertString(theString) {\n    if (theString.length > 0) {\n      let stringRep = theString.replace('/', \"!\").replace('.', '/').replace(\"!\", '.');\n\n      switch (stringRep.charAt(0)) {\n        case '.':\n          theString = stringRep.substr(1);\n          break;\n\n        case '/':\n          theString = stringRep;\n          break;\n\n        default:\n          theString = \"/\" + stringRep;\n      }\n    }\n\n    return theString;\n  } // end invertString\n\n  /**\n   * This function handles concatenation of two strings and an operator.\n   * It's called to build unit data, e.g., unit name, unit code, etc., from\n   * two different units, joined by the specified operator.\n   *\n   * @param str1 the first string to appear in the result\n   * @param operator the operator ('*', '.' or '/') to appear between the strings\n   * @param str2 the second string to appear in the result\n   * @param startChar the starting character to be used, when needed, to\n   *  enclose a string\n   * @param endChar the ending character to be used, when needed, to enclose\n   *  a string\n   * @returns the built string\n   */\n\n\n  _concatStrs(str1, operator, str2, startChar, endChar) {\n    return this._buildOneString(str1, startChar, endChar) + operator + this._buildOneString(str2, startChar, endChar);\n  }\n  /**\n   * This function handles creation of one string to be included in a\n   * concatenated string.   Basically it checks to see if the string\n   * needs to be enclosed either in parentheses or square brackets.\n   *\n   * The string is enclosed if it is not a number, does not start with\n   * a parenthesis or square bracket, and includes a period, and asterisk,\n   * a slash or a blank space.\n   *\n   * @param str the string\n   * @param startChar starting enclosing character\n   * @param endChar ending enclosing character\n   * @returns the string\n   */\n\n\n  _buildOneString(str, startChar, endChar) {\n    let ret = '';\n\n    if (intUtils_.isNumericString(str)) {\n      ret = str;\n    } else {\n      if (str.charAt(0) === '(' || str.charAt(0) === '[') {\n        ret = str;\n      } else if (/[./* ]/.test(str)) {\n        ret = startChar + str + endChar;\n      } else {\n        ret = str;\n      }\n    }\n\n    return ret;\n  }\n  /**\n   * Raises the unit to a power.  For example\n   *  kg.m/s2 raised to the -2 power would be kg-2.m-2/s-4\n   *\n   * If this unit is not on a ratio scale an error is thrown. Mutating\n   * to a ratio scale unit is not possible for a unit, only for a\n   * measurement (magnitude and dimension).\n   *\n   * This is based on the pow method in Gunter Schadow's java version,\n   * although it uses javascript capabilities to simplify the processing.\n   *\n   * This unit is modified by this function\n   *\n   * @param p the power to with this unit is to be raise\n   * @return this unit after it is raised\n   * @throws an error if this unit is not on a ratio scale.\n   */\n\n\n  power(p) {\n    if (this.cnv_ != null) throw new Error(`Attempt to raise a non-ratio unit, ${this.name_}, ` + 'to a power.'); //this.name_ = UnitString.pow(this.name_, p);\n    // the above line is replaced with the code below, as the pow method\n    // never actually existing in the UnitString class.  (Tried to use\n    // Schadow java code but this way ended up being a lot easier).\n\n    let uStr = this.csCode_;\n    let uArray = uStr.match(/([./]|[^./]+)/g);\n    let arLen = uArray.length;\n\n    for (let i = 0; i < arLen; i++) {\n      let un = uArray[i];\n\n      if (un !== '/' && un !== '.') {\n        let nun = parseInt(un);\n        if (isInteger(nun)) uArray[i] = Math.pow(nun, p).toString();else {\n          let uLen = un.length;\n\n          for (let u = uLen - 1; u >= 0; u--) {\n            let uChar = parseInt(un[u]);\n\n            if (!isInteger(uChar)) {\n              if (un[u] === '-' || un[u] === '+') {\n                u--;\n              }\n\n              if (u < uLen - 1) {\n                let exp = parseInt(un.substr(u));\n                exp = Math.pow(exp, p);\n                uArray[i] = un.substr(0, u) + exp.toString();\n                u = -1;\n              } else {\n                uArray[i] += p.toString();\n                u = -1;\n              } // end if there are/aren't some numbers at the end\n\n\n              u = -1;\n            } // end if this character is not a number\n\n          } // end searching backwards for start of exponent\n\n        } // end if this element is not a number\n      } // end if the current element is not an operator\n\n    } // end do for each element of the units array\n    // reassemble the updated units array to a string\n\n\n    this.csCode_ = uArray.join('');\n    this.magnitude_ = Math.pow(this.magnitude_, p);\n\n    if (this.dim_) {\n      this.dim_.mul(p);\n    }\n\n    return this;\n  } // end power\n\n  /*\n   * This function tests this unit against the unit passed in to see if the\n   * two are mole to mass commensurable.  It assumes that one of the units\n   * is a mole-based unit and the other is a mass-based unit.  It also assumes\n   * that the mole-based unit has a single mole unit in the numerator and that\n   * the mass-based unit has a single mass unit in the numerator.  It does NOT\n   * check to validate those assumptions.\n   *\n   * The check is made by setting the dimension vector element corresponding\n   * to the base mass unit (gram) in the mole unit, and then comparing the\n   * two dimension vectors.  If they match, the units are commensurable.\n   * Otherwise they are not.\n   *\n   * @param unit2 the unit to be compared to this one\n   * @returns boolean indicating commensurability\n   */\n\n\n  isMoleMassCommensurable(unit2) {\n    let tabs = this._getUnitTables();\n\n    let d = tabs.getMassDimensionIndex();\n    let commensurable = false;\n\n    if (this.moleExp_ === 1 && unit2.moleExp_ === 0) {\n      let testDim = this.dim_.clone();\n      let curVal = testDim.getElementAt(d);\n      testDim.setElementAt(d, curVal + this.moleExp_);\n      commensurable = testDim.equals(unit2.dim_);\n    } else if (unit2.moleExp_ === 1 && this.moleExp_ === 0) {\n      let testDim = unit2.dim_.clone();\n      let curVal = testDim.getElementAt(d);\n      testDim.setElementAt(d, curVal + unit2.moleExp_);\n      commensurable = testDim.equals(this.dim_);\n    }\n\n    return commensurable;\n  }\n  /**\n   * This returns the UnitTables singleton object.  Including the require\n   * statement included here causes a circular dependency condition that\n   * resulted in the UnitTables object not being defined for the Unit object.\n   * sigh.  Thanks, Paul, for figuring this out.\n   *\n   * @private\n   */\n\n\n  _getUnitTables() {\n    if (!UnitTables) UnitTables = require('./unitTables.js').UnitTables;\n    return UnitTables.getInstance();\n  }\n\n} // end Unit class\n\n\nexports.Unit = Unit;","map":null,"metadata":{},"sourceType":"script"}