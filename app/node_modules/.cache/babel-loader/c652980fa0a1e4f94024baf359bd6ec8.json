{"ast":null,"code":"// This is fhirpath interpreter\n// everything starts at evaluate function,\n// which is passed  fhirpath AST and resource.\n//\n// We reduce/eval recursively each node in AST\n// passing the context and current data\n//\n// each AST node has eval function, which should be registered in evalTable\n// and named after node type\n// if node needs to eval father it's children it has to call `doEval` function\n//\n// most of nodes do function or operator invocation at the end\n//\n// For invocation's and operator's there is one lookup table -\n// invocationTable and two helper functions doInvoke and infixInvoke for\n// operators\n// 1. operator or function is looked up in table\n// 2. using signature (in  .arity property) unpack parameters\n// 3. check params types\n// 4. do call function\n// 5. wrap result by util.arraify\n//\n// if function is nullable\n// and one of parameters is empty/null - function will not be invoked and empty\n// result returned\n//\n// Not solved problem is overloading functions by types - for example + operator defined\n// for strings and numbers\n// we can make dispatching params type dependent - let see\nconst parser = require(\"./parser\");\n\nconst util = require(\"./utilities\");\n\nrequire(\"./polyfill\");\n\nconst constants = require('./constants');\n\nlet engine = {}; // the object with all FHIRPath functions and operations\n\nlet existence = require(\"./existence\");\n\nlet filtering = require(\"./filtering\");\n\nlet aggregate = require(\"./aggregate\");\n\nlet combining = require(\"./combining\");\n\nlet misc = require(\"./misc\");\n\nlet equality = require(\"./equality\");\n\nlet collections = require(\"./collections\");\n\nlet math = require(\"./math\");\n\nlet strings = require(\"./strings\");\n\nlet navigation = require(\"./navigation\");\n\nlet datetime = require(\"./datetime\");\n\nlet logic = require(\"./logic\");\n\nconst types = require(\"./types\");\n\nconst {\n  FP_DateTime,\n  FP_Time,\n  FP_Quantity,\n  FP_Type,\n  ResourceNode,\n  TypeInfo\n} = types;\nlet makeResNode = ResourceNode.makeResNode; // * fn: handler\n// * arity: is index map with type signature\n//   if type is in array (like [Boolean]) - this means\n//   function accepts value of this type or empty value {}\n// * nullable - means propagate empty result, i.e. instead\n//   calling function if one of params is  empty return empty\n\nengine.invocationTable = {\n  empty: {\n    fn: existence.emptyFn\n  },\n  not: {\n    fn: existence.notFn\n  },\n  exists: {\n    fn: existence.existsMacro,\n    arity: {\n      0: [],\n      1: [\"Expr\"]\n    }\n  },\n  all: {\n    fn: existence.allMacro,\n    arity: {\n      1: [\"Expr\"]\n    }\n  },\n  allTrue: {\n    fn: existence.allTrueFn\n  },\n  anyTrue: {\n    fn: existence.anyTrueFn\n  },\n  allFalse: {\n    fn: existence.allFalseFn\n  },\n  anyFalse: {\n    fn: existence.anyFalseFn\n  },\n  subsetOf: {\n    fn: existence.subsetOfFn,\n    arity: {\n      1: [\"AnyAtRoot\"]\n    }\n  },\n  supersetOf: {\n    fn: existence.supersetOfFn,\n    arity: {\n      1: [\"AnyAtRoot\"]\n    }\n  },\n  isDistinct: {\n    fn: existence.isDistinctFn\n  },\n  distinct: {\n    fn: existence.distinctFn\n  },\n  count: {\n    fn: aggregate.countFn\n  },\n  where: {\n    fn: filtering.whereMacro,\n    arity: {\n      1: [\"Expr\"]\n    }\n  },\n  extension: {\n    fn: filtering.extension,\n    arity: {\n      1: [\"String\"]\n    }\n  },\n  select: {\n    fn: filtering.selectMacro,\n    arity: {\n      1: [\"Expr\"]\n    }\n  },\n  aggregate: {\n    fn: aggregate.aggregateMacro,\n    arity: {\n      1: [\"Expr\"],\n      2: [\"Expr\", \"Integer\"]\n    }\n  },\n  sum: {\n    fn: aggregate.sumFn\n  },\n  min: {\n    fn: aggregate.minFn\n  },\n  max: {\n    fn: aggregate.maxFn\n  },\n  avg: {\n    fn: aggregate.avgFn\n  },\n  single: {\n    fn: filtering.singleFn\n  },\n  first: {\n    fn: filtering.firstFn\n  },\n  last: {\n    fn: filtering.lastFn\n  },\n  type: {\n    fn: types.typeFn,\n    arity: {\n      0: []\n    }\n  },\n  ofType: {\n    fn: filtering.ofTypeFn,\n    arity: {\n      1: [\"TypeSpecifier\"]\n    }\n  },\n  is: {\n    fn: types.isFn,\n    arity: {\n      1: [\"TypeSpecifier\"]\n    }\n  },\n  tail: {\n    fn: filtering.tailFn\n  },\n  take: {\n    fn: filtering.takeFn,\n    arity: {\n      1: [\"Integer\"]\n    }\n  },\n  skip: {\n    fn: filtering.skipFn,\n    arity: {\n      1: [\"Integer\"]\n    }\n  },\n  combine: {\n    fn: combining.combineFn,\n    arity: {\n      1: [\"AnyAtRoot\"]\n    }\n  },\n  union: {\n    fn: combining.union,\n    arity: {\n      1: [\"AnyAtRoot\"]\n    }\n  },\n  iif: {\n    fn: misc.iifMacro,\n    arity: {\n      2: [\"Expr\", \"Expr\"],\n      3: [\"Expr\", \"Expr\", \"Expr\"]\n    }\n  },\n  trace: {\n    fn: misc.traceFn,\n    arity: {\n      0: [],\n      1: [\"String\"]\n    }\n  },\n  toInteger: {\n    fn: misc.toInteger\n  },\n  toDecimal: {\n    fn: misc.toDecimal\n  },\n  toString: {\n    fn: misc.toString\n  },\n  toDateTime: {\n    fn: misc.toDateTime\n  },\n  toTime: {\n    fn: misc.toTime\n  },\n  toBoolean: {\n    fn: misc.toBoolean\n  },\n  toQuantity: {\n    fn: misc.toQuantity,\n    arity: {\n      0: [],\n      1: [\"String\"]\n    }\n  },\n  convertsToBoolean: {\n    fn: misc.createConvertsToFn(misc.toBoolean, 'boolean')\n  },\n  convertsToInteger: {\n    fn: misc.createConvertsToFn(misc.toInteger, 'number')\n  },\n  convertsToDecimal: {\n    fn: misc.createConvertsToFn(misc.toDecimal, 'number')\n  },\n  convertsToString: {\n    fn: misc.createConvertsToFn(misc.toString, 'string')\n  },\n  convertsToDateTime: {\n    fn: misc.createConvertsToFn(misc.toDateTime, FP_DateTime)\n  },\n  convertsToTime: {\n    fn: misc.createConvertsToFn(misc.toTime, FP_Time)\n  },\n  convertsToQuantity: {\n    fn: misc.createConvertsToFn(misc.toQuantity, FP_Quantity)\n  },\n  indexOf: {\n    fn: strings.indexOf,\n    arity: {\n      1: [\"String\"]\n    }\n  },\n  substring: {\n    fn: strings.substring,\n    arity: {\n      1: [\"Integer\"],\n      2: [\"Integer\", \"Integer\"]\n    }\n  },\n  startsWith: {\n    fn: strings.startsWith,\n    arity: {\n      1: [\"String\"]\n    }\n  },\n  endsWith: {\n    fn: strings.endsWith,\n    arity: {\n      1: [\"String\"]\n    }\n  },\n  contains: {\n    fn: strings.containsFn,\n    arity: {\n      1: [\"String\"]\n    }\n  },\n  upper: {\n    fn: strings.upper\n  },\n  lower: {\n    fn: strings.lower\n  },\n  replace: {\n    fn: strings.replace,\n    arity: {\n      2: [\"String\", \"String\"]\n    }\n  },\n  matches: {\n    fn: strings.matches,\n    arity: {\n      1: [\"String\"]\n    }\n  },\n  replaceMatches: {\n    fn: strings.replaceMatches,\n    arity: {\n      2: [\"String\", \"String\"]\n    }\n  },\n  length: {\n    fn: strings.length\n  },\n  toChars: {\n    fn: strings.toChars\n  },\n  abs: {\n    fn: math.abs\n  },\n  ceiling: {\n    fn: math.ceiling\n  },\n  exp: {\n    fn: math.exp\n  },\n  floor: {\n    fn: math.floor\n  },\n  ln: {\n    fn: math.ln\n  },\n  log: {\n    fn: math.log,\n    arity: {\n      1: [\"Number\"]\n    },\n    nullable: true\n  },\n  power: {\n    fn: math.power,\n    arity: {\n      1: [\"Number\"]\n    },\n    nullable: true\n  },\n  round: {\n    fn: math.round,\n    arity: {\n      1: [\"Number\"]\n    }\n  },\n  sqrt: {\n    fn: math.sqrt\n  },\n  truncate: {\n    fn: math.truncate\n  },\n  now: {\n    fn: datetime.now\n  },\n  today: {\n    fn: datetime.today\n  },\n  repeat: {\n    fn: filtering.repeatMacro,\n    arity: {\n      1: [\"Expr\"]\n    }\n  },\n  children: {\n    fn: navigation.children\n  },\n  descendants: {\n    fn: navigation.descendants\n  },\n  \"|\": {\n    fn: combining.union,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    }\n  },\n  \"=\": {\n    fn: equality.equal,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \"!=\": {\n    fn: equality.unequal,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \"~\": {\n    fn: equality.equival,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    }\n  },\n  \"!~\": {\n    fn: equality.unequival,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    }\n  },\n  \"<\": {\n    fn: equality.lt,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \">\": {\n    fn: equality.gt,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \"<=\": {\n    fn: equality.lte,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \">=\": {\n    fn: equality.gte,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \"containsOp\": {\n    fn: collections.contains,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    }\n  },\n  \"inOp\": {\n    fn: collections.in,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    }\n  },\n  \"isOp\": {\n    fn: types.isFn,\n    arity: {\n      2: [\"Any\", \"TypeSpecifier\"]\n    }\n  },\n  \"&\": {\n    fn: math.amp,\n    arity: {\n      2: [\"String\", \"String\"]\n    }\n  },\n  \"+\": {\n    fn: math.plus,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \"-\": {\n    fn: math.minus,\n    arity: {\n      2: [\"Any\", \"Any\"]\n    },\n    nullable: true\n  },\n  \"*\": {\n    fn: math.mul,\n    arity: {\n      2: [\"Number\", \"Number\"]\n    },\n    nullable: true\n  },\n  \"/\": {\n    fn: math.div,\n    arity: {\n      2: [\"Number\", \"Number\"]\n    },\n    nullable: true\n  },\n  \"mod\": {\n    fn: math.mod,\n    arity: {\n      2: [\"Number\", \"Number\"]\n    },\n    nullable: true\n  },\n  \"div\": {\n    fn: math.intdiv,\n    arity: {\n      2: [\"Number\", \"Number\"]\n    },\n    nullable: true\n  },\n  \"or\": {\n    fn: logic.orOp,\n    arity: {\n      2: [[\"Boolean\"], [\"Boolean\"]]\n    }\n  },\n  \"and\": {\n    fn: logic.andOp,\n    arity: {\n      2: [[\"Boolean\"], [\"Boolean\"]]\n    }\n  },\n  \"xor\": {\n    fn: logic.xorOp,\n    arity: {\n      2: [[\"Boolean\"], [\"Boolean\"]]\n    }\n  },\n  \"implies\": {\n    fn: logic.impliesOp,\n    arity: {\n      2: [[\"Boolean\"], [\"Boolean\"]]\n    }\n  }\n};\n\nengine.InvocationExpression = function (ctx, parentData, node) {\n  return node.children.reduce(function (acc, ch) {\n    return engine.doEval(ctx, acc, ch);\n  }, parentData);\n};\n\nengine.TermExpression = function (ctx, parentData, node) {\n  if (parentData) {\n    parentData = parentData.map(x => {\n      if (x instanceof Object && x.resourceType) {\n        return makeResNode(x, x.resourceType);\n      }\n\n      return x;\n    });\n  }\n\n  return engine.doEval(ctx, parentData, node.children[0]);\n};\n\nengine.PolarityExpression = function (ctx, parentData, node) {\n  var sign = node.terminalNodeText[0]; // either - or + per grammar\n\n  var rtn = engine.doEval(ctx, parentData, node.children[0]);\n\n  if (rtn.length != 1) {\n    // not yet in spec, but per Bryn Rhodes\n    throw new Error('Unary ' + sign + ' can only be applied to an individual number.');\n  }\n\n  if (typeof rtn[0] != 'number' || isNaN(rtn[0])) throw new Error('Unary ' + sign + ' can only be applied to a number.');\n  if (sign === '-') rtn[0] = -rtn[0];\n  return rtn;\n};\n\nengine.TypeSpecifier = function (ctx, parentData, node) {\n  let namespace, name;\n  const identifiers = node.text.split('.').map(i => i.replace(/(^`|`$)/g, \"\"));\n\n  switch (identifiers.length) {\n    case 2:\n      [namespace, name] = identifiers;\n      break;\n\n    case 1:\n      [name] = identifiers;\n      break;\n\n    default:\n      throw new Error(\"Expected TypeSpecifier node, got \" + JSON.stringify(node));\n  }\n\n  return new TypeInfo({\n    namespace,\n    name\n  });\n};\n\nengine.ExternalConstantTerm = function (ctx, parentData, node) {\n  var extConstant = node.children[0];\n  var identifier = extConstant.children[0];\n  var varName = engine.Identifier(ctx, parentData, identifier)[0];\n  var value = ctx.vars[varName];\n\n  if (!(varName in ctx.vars)) {\n    throw new Error(\"Attempting to access an undefined environment variable: \" + varName);\n  } // For convenience, we all variable values to be passed in without their array\n  // wrapper.  However, when evaluating, we need to put the array back in.\n\n\n  return value === undefined || value === null ? [] : value instanceof Array ? value : [value];\n};\n\nengine.LiteralTerm = function (ctx, parentData, node) {\n  var term = node.children[0];\n\n  if (term) {\n    return engine.doEval(ctx, parentData, term);\n  } else {\n    return [node.text];\n  }\n};\n\nengine.StringLiteral = function (ctx, parentData, node) {\n  // Remove the beginning and ending quotes.\n  var rtn = node.text.replace(/(^'|'$)/g, \"\");\n  rtn = rtn.replace(/\\\\(u\\d{4}|.)/g, function (match, submatch) {\n    switch (match) {\n      case '\\\\r':\n        return '\\r';\n\n      case '\\\\n':\n        return \"\\n\";\n\n      case '\\\\t':\n        return '\\t';\n\n      case '\\\\f':\n        return '\\f';\n\n      default:\n        if (submatch.length > 1) return String.fromCharCode('0x' + submatch.slice(1));else return submatch;\n    }\n  });\n  return [rtn];\n};\n\nengine.BooleanLiteral = function (ctx, parentData, node) {\n  if (node.text === \"true\") {\n    return [true];\n  } else {\n    return [false];\n  }\n};\n\nengine.QuantityLiteral = function (ctx, parentData, node) {\n  var valueNode = node.children[0];\n  var value = Number(valueNode.terminalNodeText[0]);\n  var unitNode = valueNode.children[0];\n  var unit = unitNode.terminalNodeText[0]; // Sometimes the unit is in a child node of the child\n\n  if (!unit && unitNode.children) unit = unitNode.children[0].terminalNodeText[0];\n  return [new FP_Quantity(value, unit)];\n};\n\nengine.DateTimeLiteral = function (ctx, parentData, node) {\n  var dateStr = node.text.slice(1); // Remove the @\n\n  return [new FP_DateTime(dateStr)];\n};\n\nengine.TimeLiteral = function (ctx, parentData, node) {\n  var timeStr = node.text.slice(1); // Remove the @\n\n  return [new FP_Time(timeStr)];\n};\n\nengine.NumberLiteral = function (ctx, parentData, node) {\n  return [Number(node.text)];\n};\n\nengine.Identifier = function (ctx, parentData, node) {\n  return [node.text.replace(/(^`|`$)/g, \"\")];\n};\n\nengine.InvocationTerm = function (ctx, parentData, node) {\n  return engine.doEval(ctx, parentData, node.children[0]);\n};\n\nengine.MemberInvocation = function (ctx, parentData, node) {\n  const key = engine.doEval(ctx, parentData, node.children[0])[0];\n  const model = ctx.model;\n\n  if (parentData) {\n    if (util.isCapitalized(key)) {\n      return parentData.filter(x => x instanceof ResourceNode && x.path === key);\n    } else {\n      const path = parentData.path || parentData.__path__;\n      return parentData.reduce(function (acc, res) {\n        res = makeResNode(res, path);\n        var childPath = res.path + '.' + key;\n\n        if (model) {\n          let defPath = model.pathsDefinedElsewhere[childPath];\n          if (defPath) childPath = defPath;\n        }\n\n        let toAdd, _toAdd;\n\n        let actualTypes = model && model.choiceTypePaths[childPath];\n\n        if (actualTypes) {\n          // Use actualTypes to find the field's value\n          for (let t of actualTypes) {\n            let field = key + t;\n            toAdd = res.data[field];\n\n            if (toAdd !== undefined) {\n              childPath = t;\n              _toAdd = res.data['_' + key];\n              break;\n            } else {\n              toAdd = res._data[key];\n            }\n          }\n        } else {\n          toAdd = res.data[key];\n\n          if (toAdd !== undefined) {\n            _toAdd = res.data['_' + key];\n          } else {\n            toAdd = res._data[key];\n          }\n\n          if (key === 'extension') {\n            childPath = 'Extension';\n          }\n        }\n\n        if (util.isSome(toAdd)) {\n          if (Array.isArray(toAdd)) {\n            acc = acc.concat(toAdd.map((x, i) => makeResNode(x, childPath, _toAdd && _toAdd[i])));\n          } else {\n            acc.push(makeResNode(toAdd, childPath, _toAdd));\n          }\n\n          return acc;\n        } else {\n          return acc;\n        }\n      }, []);\n    }\n  } else {\n    return [];\n  }\n};\n\nengine.IndexerExpression = function (ctx, parentData, node) {\n  const coll_node = node.children[0];\n  const idx_node = node.children[1];\n  var coll = engine.doEval(ctx, parentData, coll_node);\n  var idx = engine.doEval(ctx, parentData, idx_node);\n\n  if (util.isEmpty(idx)) {\n    return [];\n  }\n\n  var idxNum = parseInt(idx[0]);\n\n  if (coll && util.isSome(idxNum) && coll.length > idxNum && idxNum >= 0) {\n    return [coll[idxNum]];\n  } else {\n    return [];\n  }\n};\n\nengine.Functn = function (ctx, parentData, node) {\n  return node.children.map(function (x) {\n    return engine.doEval(ctx, parentData, x);\n  });\n};\n\nengine.realizeParams = function (ctx, parentData, args) {\n  if (args && args[0] && args[0].children) {\n    return args[0].children.map(function (x) {\n      return engine.doEval(ctx, parentData, x);\n    });\n  } else {\n    return [];\n  }\n};\n\nfunction makeParam(ctx, parentData, type, param) {\n  if (type === \"Expr\") {\n    return function (data) {\n      ctx.$this = data;\n      return engine.doEval(ctx, util.arraify(data), param);\n    };\n  }\n\n  if (type === \"AnyAtRoot\") {\n    ctx.$this = ctx.dataRoot;\n    return engine.doEval(ctx, ctx.dataRoot, param);\n  }\n\n  if (type === \"Identifier\") {\n    if (param.type == \"TermExpression\") {\n      return param.text;\n    } else {\n      throw new Error(\"Expected identifier node, got \" + JSON.stringify(param));\n    }\n  }\n\n  if (type === \"TypeSpecifier\") {\n    return engine.TypeSpecifier(ctx, parentData, param);\n  }\n\n  ctx.$this = parentData;\n  var res = engine.doEval(ctx, parentData, param);\n\n  if (type === \"Any\") {\n    return res;\n  }\n\n  if (Array.isArray(type)) {\n    if (res.length == 0) {\n      return [];\n    } else {\n      type = type[0];\n    }\n  }\n\n  return misc.singleton(res, type);\n}\n\nfunction doInvoke(ctx, fnName, data, rawParams) {\n  var invoc = engine.invocationTable[fnName];\n  var res;\n\n  if (invoc) {\n    if (!invoc.arity) {\n      if (!rawParams) {\n        res = invoc.fn.call(ctx, util.arraify(data));\n        return util.arraify(res);\n      } else {\n        throw new Error(fnName + \" expects no params\");\n      }\n    } else {\n      var paramsNumber = rawParams ? rawParams.length : 0;\n      var argTypes = invoc.arity[paramsNumber];\n\n      if (argTypes) {\n        var params = [];\n\n        for (var i = 0; i < paramsNumber; i++) {\n          var tp = argTypes[i];\n          var pr = rawParams[i];\n          params.push(makeParam(ctx, data, tp, pr));\n        }\n\n        params.unshift(data);\n\n        if (invoc.nullable) {\n          if (params.some(isNullable)) {\n            return [];\n          }\n        }\n\n        res = invoc.fn.apply(ctx, params);\n        return util.arraify(res);\n      } else {\n        console.log(fnName + \" wrong arity: got \" + paramsNumber);\n        return [];\n      }\n    }\n  } else {\n    throw new Error(\"Not implemented: \" + fnName);\n  }\n}\n\nfunction isNullable(x) {\n  var res = x === null || x === undefined || util.isEmpty(x);\n  return res;\n}\n\nfunction infixInvoke(ctx, fnName, data, rawParams) {\n  var invoc = engine.invocationTable[fnName];\n\n  if (invoc && invoc.fn) {\n    var paramsNumber = rawParams ? rawParams.length : 0;\n\n    if (paramsNumber != 2) {\n      throw new Error(\"Infix invoke should have arity 2\");\n    }\n\n    var argTypes = invoc.arity[paramsNumber];\n\n    if (argTypes) {\n      var params = [];\n\n      for (var i = 0; i < paramsNumber; i++) {\n        var tp = argTypes[i];\n        var pr = rawParams[i];\n        params.push(makeParam(ctx, data, tp, pr));\n      }\n\n      if (invoc.nullable) {\n        if (params.some(isNullable)) {\n          return [];\n        }\n      }\n\n      var res = invoc.fn.apply(ctx, params);\n      return util.arraify(res);\n    } else {\n      console.log(fnName + \" wrong arity: got \" + paramsNumber);\n      return [];\n    }\n  } else {\n    throw new Error(\"Not impl \" + fnName);\n  }\n}\n\nengine.FunctionInvocation = function (ctx, parentData, node) {\n  var args = engine.doEval(ctx, parentData, node.children[0]);\n  const fnName = args[0];\n  args.shift();\n  var rawParams = args && args[0] && args[0].children;\n  return doInvoke(ctx, fnName, parentData, rawParams);\n};\n\nengine.ParamList = function (ctx, parentData, node) {\n  // we do not eval param list because sometimes it should be passed as\n  // lambda/macro (for example in case of where(...)\n  return node;\n};\n\nengine.UnionExpression = function (ctx, parentData, node) {\n  return infixInvoke(ctx, '|', parentData, node.children);\n};\n\nengine.ThisInvocation = function (ctx) {\n  return util.arraify(ctx.$this);\n};\n\nengine.TotalInvocation = function (ctx) {\n  return util.arraify(ctx.$total);\n};\n\nengine.IndexInvocation = function (ctx) {\n  return util.arraify(ctx.$index);\n};\n\nengine.OpExpression = function (ctx, parentData, node) {\n  var op = node.terminalNodeText[0];\n  return infixInvoke(ctx, op, parentData, node.children);\n};\n\nengine.AliasOpExpression = function (map) {\n  return function (ctx, parentData, node) {\n    var op = node.terminalNodeText[0];\n    var alias = map[op];\n\n    if (!alias) {\n      throw new Error(\"Do not know how to alias \" + op + \" by \" + JSON.stringify(map));\n    }\n\n    return infixInvoke(ctx, alias, parentData, node.children);\n  };\n};\n\nengine.NullLiteral = function () {\n  return [];\n};\n\nengine.ParenthesizedTerm = function (ctx, parentData, node) {\n  return engine.doEval(ctx, parentData, node.children[0]);\n};\n\nengine.evalTable = {\n  // not every evaluator is listed if they are defined on engine\n  BooleanLiteral: engine.BooleanLiteral,\n  EqualityExpression: engine.OpExpression,\n  FunctionInvocation: engine.FunctionInvocation,\n  Functn: engine.Functn,\n  Identifier: engine.Identifier,\n  IndexerExpression: engine.IndexerExpression,\n  InequalityExpression: engine.OpExpression,\n  InvocationExpression: engine.InvocationExpression,\n  AdditiveExpression: engine.OpExpression,\n  MultiplicativeExpression: engine.OpExpression,\n  TypeExpression: engine.AliasOpExpression({\n    \"is\": \"isOp\"\n  }),\n  MembershipExpression: engine.AliasOpExpression({\n    \"contains\": \"containsOp\",\n    \"in\": \"inOp\"\n  }),\n  NullLiteral: engine.NullLiteral,\n  EntireExpression: engine.InvocationTerm,\n  InvocationTerm: engine.InvocationTerm,\n  LiteralTerm: engine.LiteralTerm,\n  MemberInvocation: engine.MemberInvocation,\n  NumberLiteral: engine.NumberLiteral,\n  ParamList: engine.ParamList,\n  ParenthesizedTerm: engine.ParenthesizedTerm,\n  StringLiteral: engine.StringLiteral,\n  TermExpression: engine.TermExpression,\n  ThisInvocation: engine.ThisInvocation,\n  TotalInvocation: engine.TotalInvocation,\n  IndexInvocation: engine.IndexInvocation,\n  UnionExpression: engine.UnionExpression,\n  OrExpression: engine.OpExpression,\n  ImpliesExpression: engine.OpExpression,\n  AndExpression: engine.OpExpression,\n  XorExpression: engine.OpExpression\n};\n\nengine.doEval = function (ctx, parentData, node) {\n  const evaluator = engine.evalTable[node.type] || engine[node.type];\n\n  if (evaluator) {\n    return evaluator.call(engine, ctx, parentData, node);\n  } else {\n    throw new Error(\"No \" + node.type + \" evaluator \");\n  }\n};\n\nfunction parse(path) {\n  return parser.parse(path);\n}\n/**\n *  Applies the given parsed FHIRPath expression to the given resource,\n *  returning the result of doEval.\n * @param {(object|object[])} resource -  FHIR resource, bundle as js object or array of resources\n *  This resource will be modified by this function to add type information.\n * @param {string} parsedPath - fhirpath expression, sample 'Patient.name.given'\n * @param {object} context - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n */\n\n\nfunction applyParsedPath(resource, parsedPath, context, model) {\n  constants.reset();\n  let dataRoot = util.arraify(resource); // doEval takes a \"ctx\" object, and we store things in that as we parse, so we\n  // need to put user-provided variable data in a sub-object, ctx.vars.\n  // Set up default standard variables, and allow override from the variables.\n  // However, we'll keep our own copy of dataRoot for internal processing.\n\n  let vars = {\n    context: resource,\n    ucum: 'http://unitsofmeasure.org'\n  };\n  let ctx = {\n    dataRoot,\n    vars: Object.assign(vars, context),\n    model\n  };\n  let rtn = engine.doEval(ctx, dataRoot, parsedPath.children[0]);\n  let firstRtn = Array.isArray(rtn) ? rtn[0] : rtn; // Path for the data extracted from the resource.\n\n  let path = firstRtn instanceof ResourceNode ? firstRtn.path : null; // Resolve any internal \"ResourceNode\" instances.  Continue to let FP_Type\n  // subclasses through.\n\n  rtn = function visit(n) {\n    n = util.valData(n);\n\n    if (Array.isArray(n)) {\n      for (let i = 0, len = n.length; i < len; ++i) n[i] = visit(n[i]);\n    } else if (typeof n === 'object' && !(n instanceof FP_Type)) {\n      for (let k of Object.keys(n)) n[k] = visit(n[k]);\n    }\n\n    return n;\n  }(rtn); // Add a hidden (non-enumerable) property with the path to the data extracted\n  // from the resource.\n\n\n  if (path && typeof rtn === 'object') {\n    Object.defineProperty(rtn, '__path__', {\n      value: path\n    });\n  }\n\n  return rtn;\n}\n/**\n *  Evaluates the \"path\" FHIRPath expression on the given resource or part of the resource,\n *  using data from \"context\" for variables mentioned in the \"path\" expression.\n * @param {(object|object[])} fhirData -  FHIR resource, part of a resource (in this case\n *  path.base should be provided), bundle as js object or array of resources.\n *  This object/array will be modified by this function to add type information.\n * @param {string|object} path - string with FHIRPath expression, sample 'Patient.name.given',\n *  or object, if fhirData represents the part of the FHIR resource:\n * @param {string} path.base - base path in resource from which fhirData was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} context - a hash of variable name/value pairs.\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n */\n\n\nfunction evaluate(fhirData, path, context, model) {\n  return compile(path, model)(fhirData, context);\n}\n/**\n *  Returns a function that takes a resource or part of the resource and an\n *  optional context hash (see \"evaluate\"), and returns the result of evaluating\n *  the given FHIRPath expression on that resource.  The advantage of this\n *  function over \"evaluate\" is that if you have multiple resources, the given\n *  FHIRPath expression will only be parsed once.\n * @param {string|object} path - string with FHIRPath expression to be parsed or object:\n * @param {string} path.base - base path in resource from which a part of\n *   the resource was extracted\n * @param {string} path.expression - FHIRPath expression relative to path.base\n * @param {object} model - The \"model\" data object specific to a domain, e.g. R4.\n *  For example, you could pass in the result of require(\"fhirpath/fhir-context/r4\");\n */\n\n\nfunction compile(path, model) {\n  if (typeof path === 'object') {\n    const node = parse(path.expression);\n    return function (fhirData, context) {\n      const inObjPath = fhirData && fhirData.__path__;\n      const resource = makeResNode(fhirData, path.base || inObjPath);\n      return applyParsedPath(resource, node, context, model);\n    };\n  } else {\n    const node = parse(path);\n    return function (fhirData, context) {\n      const inObjPath = fhirData && fhirData.__path__;\n      const resource = inObjPath ? makeResNode(fhirData, inObjPath) : fhirData;\n      return applyParsedPath(resource, node, context, model);\n    };\n  }\n}\n\nmodule.exports = {\n  parse,\n  compile,\n  evaluate,\n  // Might as well export the UCUM library, since we are using it.\n  ucumUtils: require('@lhncbc/ucum-lhc').UcumLhcUtils.getInstance()\n};","map":null,"metadata":{},"sourceType":"script"}