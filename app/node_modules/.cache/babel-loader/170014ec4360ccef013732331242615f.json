{"ast":null,"code":"// This file holds code to hande the FHIRPath Math functions.\nvar types = require('./types');\n\nvar FP_TimeBase = types.FP_TimeBase,\n    FP_Quantity = types.FP_Quantity;\n\nvar util = require(\"./utilities\");\n/**\n *  Adds the math functions to the given FHIRPath engine.\n */\n\n\nvar engine = {};\n\nfunction ensureNumberSingleton(x) {\n  var d = util.valData(x);\n\n  if (typeof d !== 'number') {\n    if (d.length == 1 && typeof (d = util.valData(d[0])) === 'number') {\n      return d;\n    } else {\n      throw new Error(\"Expected number, but got \" + JSON.stringify(d || x));\n    }\n  } else return d;\n}\n\nfunction isEmpty(x) {\n  if (typeof x == 'number') {\n    return false;\n  }\n\n  return x.length == 0;\n}\n\nengine.amp = function (x, y) {\n  return (x || \"\") + (y || \"\");\n}; //HACK: for only polymorphic function\n//  Actually, \"minus\" is now also polymorphic\n\n\nengine.plus = function (xs, ys) {\n  if (xs.length == 1 && ys.length == 1) {\n    var x = util.valData(xs[0]);\n    var y = util.valData(ys[0]); // In the future, this and other functions might need to return ResourceNode\n    // to preserve the type information (integer vs decimal, and maybe decimal\n    // vs string if decimals are represented as strings), in order to support\n    // \"as\" and \"is\", but that support is deferred for now.\n\n    if (typeof x == \"string\" && typeof y == \"string\") {\n      return x + y;\n    }\n\n    if (typeof x == \"number\" && typeof y == \"number\") {\n      return x + y;\n    }\n\n    if (x instanceof FP_TimeBase && y instanceof FP_Quantity) {\n      return x.plus(y);\n    }\n  }\n\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" + \" + JSON.stringify(ys));\n};\n\nengine.minus = function (xs, ys) {\n  if (xs.length == 1 && ys.length == 1) {\n    var x = util.valData(xs[0]);\n    var y = util.valData(ys[0]);\n    if (typeof x == \"number\" && typeof y == \"number\") return x - y;\n    if (x instanceof FP_TimeBase && y instanceof FP_Quantity) return x.plus(new FP_Quantity(-y.value, y.unit));\n  }\n\n  throw new Error(\"Cannot \" + JSON.stringify(xs) + \" - \" + JSON.stringify(ys));\n};\n\nengine.mul = function (x, y) {\n  return x * y;\n};\n\nengine.div = function (x, y) {\n  if (y === 0) return [];\n  return x / y;\n};\n\nengine.intdiv = function (x, y) {\n  if (y === 0) return [];\n  return Math.floor(x / y);\n};\n\nengine.mod = function (x, y) {\n  if (y === 0) return [];\n  return x % y;\n};\n\nengine.abs = function (x) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    return Math.abs(num);\n  }\n};\n\nengine.ceiling = function (x) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    return Math.ceil(num);\n  }\n};\n\nengine.exp = function (x) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    return Math.exp(num);\n  }\n};\n\nengine.floor = function (x) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    return Math.floor(num);\n  }\n};\n\nengine.ln = function (x) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    return Math.log(num);\n  }\n};\n\nengine.log = function (x, base) {\n  if (isEmpty(x) || isEmpty(base)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    var num2 = ensureNumberSingleton(base);\n    return Math.log(num) / Math.log(num2);\n  }\n};\n\nengine.power = function (x, degree) {\n  if (isEmpty(x) || isEmpty(degree)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    var num2 = ensureNumberSingleton(degree);\n\n    if (num < 0 && Math.floor(num2) != num2) {\n      return [];\n    } else {\n      return Math.pow(num, num2);\n    }\n  }\n};\n\nengine.round = function (x, acc) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n\n    if (isEmpty(acc)) {\n      return Math.round(num);\n    } else {\n      var num2 = ensureNumberSingleton(acc);\n      var degree = Math.pow(10, num2);\n      return Math.round(num * degree) / degree;\n    }\n  }\n};\n\nengine.sqrt = function (x) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n\n    if (num < 0) {\n      return [];\n    } else {\n      return Math.sqrt(num);\n    }\n  }\n};\n\nengine.truncate = function (x) {\n  if (isEmpty(x)) {\n    return [];\n  } else {\n    var num = ensureNumberSingleton(x);\n    return Math.trunc(num);\n  }\n};\n\nmodule.exports = engine;","map":null,"metadata":{},"sourceType":"script"}