{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _asyncToGenerator = require(\"/home/teboho/opensrp-fhir-web-source/fhir-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.ready = exports.buildTokenRequest = exports.completeAuth = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nvar lib_1 = require(\"./lib\");\n\nvar Client_1 = require(\"./Client\");\n\nvar settings_1 = require(\"./settings\");\n\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function get() {\n    return settings_1.SMART_KEY;\n  }\n});\nvar debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson() {\n  var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  var requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  var url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(function (ex) {\n    throw new Error(\"Failed to fetch the well-known json \\\"\".concat(url, \"\\\". \").concat(ex.message));\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson() {\n  var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  var requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  return fetchWellKnownJson(baseUrl, requestOptions).then(function (meta) {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement() {\n  var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  var requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(function (meta) {\n    var nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    var extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(function (e) {\n      return e.url === nsUri;\n    }).map(function (o) {\n      return o.extension;\n    })[0];\n    var out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(function (ext) {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  var len = tasks.length;\n  var errors = [];\n  var resolved = false;\n  return new Promise(function (resolve, reject) {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(function (t) {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(function (e) {\n          return e.message;\n        }).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(function (t) {\n      t.promise.then(function (result) {\n        return onSuccess(t, result);\n      }, onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env) {\n  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"/\";\n  var AbortController = env.getAbortController();\n  var abortController1 = new AbortController();\n  var abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\n\nfunction authorize(_x) {\n  return _authorize.apply(this, arguments);\n}\n\nfunction _authorize() {\n  _authorize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(env) {\n    var params,\n        url,\n        urlISS,\n        cfg,\n        redirect_uri,\n        clientSecret,\n        fakeTokenResponse,\n        patientId,\n        encounterId,\n        client_id,\n        target,\n        width,\n        height,\n        iss,\n        launch,\n        fhirServiceUrl,\n        redirectUri,\n        noRedirect,\n        _params$scope,\n        scope,\n        clientId,\n        completeInTarget,\n        storage,\n        serverUrl,\n        inFrame,\n        inPopUp,\n        oldKey,\n        stateKey,\n        state,\n        fullSessionStorageSupport,\n        redirectUrl,\n        extensions,\n        redirectParams,\n        win,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            params = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            url = env.getUrl(); // Multiple config for EHR launches ---------------------------------------\n\n            if (!Array.isArray(params)) {\n              _context.next = 11;\n              break;\n            }\n\n            urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n\n            if (urlISS) {\n              _context.next = 6;\n              break;\n            }\n\n            throw new Error('Passing in an \"iss\" url parameter is required if authorize ' + 'uses multiple configurations');\n\n          case 6:\n            // pick the right config\n            cfg = params.find(function (x) {\n              if (x.issMatch) {\n                if (typeof x.issMatch === \"function\") {\n                  return !!x.issMatch(urlISS);\n                }\n\n                if (typeof x.issMatch === \"string\") {\n                  return x.issMatch === urlISS;\n                }\n\n                if (x.issMatch instanceof RegExp) {\n                  return x.issMatch.test(urlISS);\n                }\n              }\n\n              return false;\n            });\n            lib_1.assert(cfg, \"No configuration found matching the current \\\"iss\\\" parameter \\\"\".concat(urlISS, \"\\\"\"));\n            _context.next = 10;\n            return authorize(env, cfg);\n\n          case 10:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 11:\n            // ------------------------------------------------------------------------\n            // Obtain input\n            redirect_uri = params.redirect_uri, clientSecret = params.clientSecret, fakeTokenResponse = params.fakeTokenResponse, patientId = params.patientId, encounterId = params.encounterId, client_id = params.client_id, target = params.target, width = params.width, height = params.height;\n            iss = params.iss, launch = params.launch, fhirServiceUrl = params.fhirServiceUrl, redirectUri = params.redirectUri, noRedirect = params.noRedirect, _params$scope = params.scope, scope = _params$scope === void 0 ? \"\" : _params$scope, clientId = params.clientId, completeInTarget = params.completeInTarget;\n            storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n            iss = url.searchParams.get(\"iss\") || iss;\n            fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n            launch = url.searchParams.get(\"launch\") || launch;\n\n            if (!clientId) {\n              clientId = client_id;\n            }\n\n            if (!redirectUri) {\n              redirectUri = redirect_uri;\n            }\n\n            if (!redirectUri) {\n              redirectUri = env.relative(\".\");\n            } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n              redirectUri = env.relative(redirectUri);\n            }\n\n            serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n            if (serverUrl) {\n              _context.next = 23;\n              break;\n            }\n\n            throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n\n          case 23:\n            if (iss) {\n              debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n            } // append launch scope if needed\n\n\n            if (launch && !scope.match(/launch/)) {\n              scope += \" launch\";\n            }\n\n            if (isBrowser()) {\n              inFrame = isInFrame();\n              inPopUp = isInPopUp();\n\n              if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n                // completeInTarget will default to true if authorize is called from\n                // within an iframe. This is to avoid issues when the entire app\n                // happens to be rendered in an iframe (including in some EHRs),\n                // even though that was not how the app developer's intention.\n                completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n                // to be explicit in their configuration.\n\n                console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n              }\n            } // If `authorize` is called, make sure we clear any previous state (in case\n            // this is a re-authorize)\n\n\n            _context.next = 28;\n            return storage.get(settings_1.SMART_KEY);\n\n          case 28:\n            oldKey = _context.sent;\n            _context.next = 31;\n            return storage.unset(oldKey);\n\n          case 31:\n            // create initial state\n            stateKey = lib_1.randomString(16);\n            state = {\n              clientId: clientId,\n              scope: scope,\n              redirectUri: redirectUri,\n              serverUrl: serverUrl,\n              clientSecret: clientSecret,\n              tokenResponse: {},\n              key: stateKey,\n              completeInTarget: completeInTarget\n            };\n            fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n            if (!fullSessionStorageSupport) {\n              _context.next = 37;\n              break;\n            }\n\n            _context.next = 37;\n            return storage.set(settings_1.SMART_KEY, stateKey);\n\n          case 37:\n            // fakeTokenResponse to override stuff (useful in development)\n            if (fakeTokenResponse) {\n              Object.assign(state.tokenResponse, fakeTokenResponse);\n            } // Fixed patientId (useful in development)\n\n\n            if (patientId) {\n              Object.assign(state.tokenResponse, {\n                patient: patientId\n              });\n            } // Fixed encounterId (useful in development)\n\n\n            if (encounterId) {\n              Object.assign(state.tokenResponse, {\n                encounter: encounterId\n              });\n            }\n\n            redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n            if (!(fhirServiceUrl && !iss)) {\n              _context.next = 50;\n              break;\n            }\n\n            debug(\"Making fake launch...\");\n            _context.next = 45;\n            return storage.set(stateKey, state);\n\n          case 45:\n            if (!noRedirect) {\n              _context.next = 47;\n              break;\n            }\n\n            return _context.abrupt(\"return\", redirectUrl);\n\n          case 47:\n            _context.next = 49;\n            return env.redirect(redirectUrl);\n\n          case 49:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 50:\n            _context.next = 52;\n            return getSecurityExtensions(env, serverUrl);\n\n          case 52:\n            extensions = _context.sent;\n            Object.assign(state, extensions);\n            _context.next = 56;\n            return storage.set(stateKey, state);\n\n          case 56:\n            if (state.authorizeUri) {\n              _context.next = 62;\n              break;\n            }\n\n            if (!noRedirect) {\n              _context.next = 59;\n              break;\n            }\n\n            return _context.abrupt(\"return\", redirectUrl);\n\n          case 59:\n            _context.next = 61;\n            return env.redirect(redirectUrl);\n\n          case 61:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 62:\n            // build the redirect uri\n            redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n            if (launch) {\n              redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n            }\n\n            redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n            if (!noRedirect) {\n              _context.next = 67;\n              break;\n            }\n\n            return _context.abrupt(\"return\", redirectUrl);\n\n          case 67:\n            if (!(target && isBrowser())) {\n              _context.next = 76;\n              break;\n            }\n\n            _context.next = 70;\n            return lib_1.getTargetWindow(target, width, height);\n\n          case 70:\n            win = _context.sent;\n\n            if (win !== self) {\n              try {\n                // Also remove any old state from the target window and then\n                // transfer the current state there\n                win.sessionStorage.removeItem(oldKey);\n                win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n              } catch (ex) {\n                lib_1.debug(\"Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \\\"_self\\\". %s\", ex);\n                win = self;\n              }\n            }\n\n            if (win !== self) {\n              try {\n                win.location.href = redirectUrl;\n                self.addEventListener(\"message\", onMessage);\n              } catch (ex) {\n                lib_1.debug(\"Failed to modify window.location. Perhaps it is from different origin?. Failing back to \\\"_self\\\". %s\", ex);\n                self.location.href = redirectUrl;\n              }\n            } else {\n              self.location.href = redirectUrl;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 76:\n            _context.next = 78;\n            return env.redirect(redirectUrl);\n\n          case 78:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 79:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _authorize.apply(this, arguments);\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nfunction completeAuth(_x2) {\n  return _completeAuth.apply(this, arguments);\n}\n\nfunction _completeAuth() {\n  _completeAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(env) {\n    var _a, _b, url, Storage, params, key, code, authError, authErrorDescription, state, fullSessionStorageSupport, inFrame, inPopUp, href, origin, hasState, authorized, requestOptions, tokenResponse, client;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            url = env.getUrl();\n            Storage = env.getStorage();\n            params = url.searchParams;\n            key = params.get(\"state\");\n            code = params.get(\"code\");\n            authError = params.get(\"error\");\n            authErrorDescription = params.get(\"error_description\");\n\n            if (key) {\n              _context2.next = 11;\n              break;\n            }\n\n            _context2.next = 10;\n            return Storage.get(settings_1.SMART_KEY);\n\n          case 10:\n            key = _context2.sent;\n\n          case 11:\n            if (!(authError || authErrorDescription)) {\n              _context2.next = 13;\n              break;\n            }\n\n            throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n\n          case 13:\n            debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n            lib_1.assert(key, \"No 'state' parameter found. Please (re)launch the app.\"); // Check if we have a previous state\n\n            _context2.next = 17;\n            return Storage.get(key);\n\n          case 17:\n            state = _context2.sent;\n            fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n            // complete, send the location back to our opener and exit.\n\n            if (!(isBrowser() && state && !state.completeInTarget)) {\n              _context2.next = 28;\n              break;\n            }\n\n            inFrame = isInFrame();\n            inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n            // be called again. In rare cases the opener or parent might also be\n            // a frame or popup. Then inFrame or inPopUp will be true but we still\n            // have to stop going up the chain. To guard against that weird form of\n            // recursion we pass one additional parameter to the url which we later\n            // remove.\n\n            if (!((inFrame || inPopUp) && !url.searchParams.get(\"complete\"))) {\n              _context2.next = 28;\n              break;\n            }\n\n            url.searchParams.set(\"complete\", \"1\");\n            href = url.href, origin = url.origin;\n\n            if (inFrame) {\n              parent.postMessage({\n                type: \"completeAuth\",\n                url: href\n              }, origin);\n            }\n\n            if (inPopUp) {\n              opener.postMessage({\n                type: \"completeAuth\",\n                url: href\n              }, origin);\n              window.close();\n            }\n\n            return _context2.abrupt(\"return\", new Promise(function () {}));\n\n          case 28:\n            url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n            hasState = params.has(\"state\");\n\n            if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n              // `code` is the flag that tell us to request an access token.\n              // We have to remove it, otherwise the page will authorize on\n              // every load!\n              if (code) {\n                params.delete(\"code\");\n                debug(\"Removed code parameter from the url.\");\n              } // If we have `fullSessionStorageSupport` it means we no longer\n              // need the `state` key. It will be stored to a well know\n              // location - sessionStorage[SMART_KEY]. However, no\n              // fullSessionStorageSupport means that this \"well know location\"\n              // might be shared between windows and tabs. In this case we\n              // MUST keep the `state` url parameter.\n\n\n              if (hasState && fullSessionStorageSupport) {\n                params.delete(\"state\");\n                debug(\"Removed state parameter from the url.\");\n              } // If the browser does not support the replaceState method for the\n              // History Web API, the \"code\" parameter cannot be removed. As a\n              // consequence, the page will (re)authorize on every load. The\n              // workaround is to reload the page to new location without those\n              // parameters. If that is not acceptable replaceBrowserHistory\n              // should be set to false.\n\n\n              if (window.history.replaceState) {\n                window.history.replaceState({}, \"\", url.href);\n              }\n            } // If the state does not exist, it means the page has been loaded directly.\n\n\n            lib_1.assert(state, \"No state found! Please (re)launch the app.\"); // Assume the client has already completed a token exchange when\n            // there is no code (but we have a state) or access token is found in state\n\n            authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n            // Otherwise, we have to complete the code flow\n\n            if (!(!authorized && state.tokenUri)) {\n              _context2.next = 50;\n              break;\n            }\n\n            lib_1.assert(code, \"'code' url parameter is required\");\n            debug(\"Preparing to exchange the code for access token...\");\n            requestOptions = buildTokenRequest(env, code, state);\n            debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n            // includes an access token or a message indicating that the\n            // authorization request has been denied.\n\n            _context2.next = 40;\n            return lib_1.request(state.tokenUri, requestOptions);\n\n          case 40:\n            tokenResponse = _context2.sent;\n            debug(\"Token response: %O\", tokenResponse);\n            lib_1.assert(tokenResponse.access_token, \"Failed to obtain access token.\"); // Now we need to determine when is this authorization going to expire\n\n            state.expiresAt = lib_1.getAccessTokenExpiration(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n            // every page reload\n\n            state = Object.assign(Object.assign({}, state), {\n              tokenResponse: tokenResponse\n            });\n            _context2.next = 47;\n            return Storage.set(key, state);\n\n          case 47:\n            debug(\"Authorization successful!\");\n            _context2.next = 51;\n            break;\n\n          case 50:\n            debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n\n          case 51:\n            if (!fullSessionStorageSupport) {\n              _context2.next = 54;\n              break;\n            }\n\n            _context2.next = 54;\n            return Storage.set(settings_1.SMART_KEY, key);\n\n          case 54:\n            client = new Client_1.default(env, state);\n            debug(\"Created client instance: %O\", client);\n            return _context2.abrupt(\"return\", client);\n\n          case 57:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _completeAuth.apply(this, arguments);\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  var redirectUri = state.redirectUri,\n      clientSecret = state.clientSecret,\n      tokenUri = state.tokenUri,\n      clientId = state.clientId;\n  lib_1.assert(redirectUri, \"Missing state.redirectUri\");\n  lib_1.assert(tokenUri, \"Missing state.tokenUri\");\n  lib_1.assert(clientId, \"Missing state.clientId\");\n  var requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: \"code=\".concat(code, \"&grant_type=authorization_code&redirect_uri=\").concat(encodeURIComponent(redirectUri))\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += \"&client_id=\".concat(encodeURIComponent(clientId));\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nfunction ready(_x3, _x4, _x5) {\n  return _ready.apply(this, arguments);\n}\n\nfunction _ready() {\n  _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(env, onSuccess, onError) {\n    var task;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            task = completeAuth(env);\n\n            if (onSuccess) {\n              task = task.then(onSuccess);\n            }\n\n            if (onError) {\n              task = task.catch(onError);\n            }\n\n            return _context3.abrupt(\"return\", task);\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _ready.apply(this, arguments);\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nfunction init(_x6, _x7) {\n  return _init.apply(this, arguments);\n}\n\nfunction _init() {\n  _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(env, options) {\n    var url, code, state, storage, key, cached;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            url = env.getUrl();\n            code = url.searchParams.get(\"code\");\n            state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n            if (!(code && state)) {\n              _context4.next = 5;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", completeAuth(env));\n\n          case 5:\n            // Check for existing client state. If state is found, it means a client\n            // instance have already been created in this session and we should try to\n            // \"revive\" it.\n            storage = env.getStorage();\n            _context4.t0 = state;\n\n            if (_context4.t0) {\n              _context4.next = 11;\n              break;\n            }\n\n            _context4.next = 10;\n            return storage.get(settings_1.SMART_KEY);\n\n          case 10:\n            _context4.t0 = _context4.sent;\n\n          case 11:\n            key = _context4.t0;\n            _context4.next = 14;\n            return storage.get(key);\n\n          case 14:\n            cached = _context4.sent;\n\n            if (!cached) {\n              _context4.next = 17;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", new Client_1.default(env, cached));\n\n          case 17:\n            return _context4.abrupt(\"return\", authorize(env, options).then(function () {\n              // `init` promises a Client but that cannot happen in this case. The\n              // browser will be redirected (unload the page and be redirected back\n              // to it later and the same init function will be called again). On\n              // success, authorize will resolve with the redirect url but we don't\n              // want to return that from this promise chain because it is not a\n              // Client instance. At the same time, if authorize fails, we do want to\n              // pass the error to those waiting for a client instance.\n              return new Promise(function () {});\n            }));\n\n          case 18:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _init.apply(this, arguments);\n}\n\nexports.init = init;","map":null,"metadata":{},"sourceType":"script"}